/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010 Facebook, Inc. (http://www.facebook.com)          |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
// @generated by HipHop Compiler

#include <runtime/base/hphp_system.h>
#include <runtime/ext/ext.h>
#include <runtime/eval/eval.h>
#include <sys/literal_strings.h>


using namespace std;

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////


// Class Invoke Tables
#define M(x, y) MethodIndex(x, y)
#define H(x,y,z) MethodIndexHMap(#x,MethodIndex(y,z))
#define Z MethodIndexHMap(0,MethodIndex(0,0))
const unsigned g_methodIndexHMapSizeSys = 878;
extern const MethodIndexHMap g_methodIndexHMapSys [];
const MethodIndexHMap g_methodIndexHMapSys [g_methodIndexHMapSizeSys] = {
Z, H(getArrayCopy,14,1), Z, 
H(__destruct,35,1), Z, Z, 
Z, Z, H(addCompletion,162,1), 
Z, H(insertData,66,1), H(getserverstatus,216,1), 
H(endDTDEntity,410,1), H(hasChildren,258,1), Z, 
H(openFile,197,1), Z, Z, 
Z, Z, H(getElementsByTagNameNS,75,1), 
Z, Z, H(setValue,327,1), 
H(getInterfaceNames,280,1), Z, H(getTraceAsString,31,1), 
H(closecursor,248,1), Z, Z, 
Z, Z, Z, 
Z, Z, Z, 
H(isFinal,271,1), Z, Z, 
Z, H(getClassNames,299,1), Z, 
Z, H(getCTime,184,1), Z, 
Z, H(rewind,9,1), H(startDTD,427,1), 
H(setFileClass,178,1), H(getFlags,22,1), Z, 
Z, Z, Z, 
Z, H(isDestructor,315,1), H(normalize,57,1), 
H(__getfunctions,367,1), H(loadHTML,78,1), Z, 
Z, H(fwrite,394,1), H(startElement,412,1), 
H(openblob,337,1), H(setFlags,17,1), H(query,124,1), 
H(xend,145,1), H(getParentClass,278,1), H(asXML,354,1), 
H(close,171,1), Z, H(createAttributens,85,1), 
Z, H(getInterfaces,293,1), H(registerPHPFunctions,126,1), 
H(escapestring,333,1), H(appendChild,50,1), H(endAttribute,436,1), 
H(registerNamespace,127,1), H(seek,21,1), H(numcolumns,342,1), 
H(__toString,26,1), H(insertBefore,46,1), H(startDTDEntity,404,1), 
H(cloneNode,52,1), H(endPI,426,1), H(setclass,377,1), 
H(endElement,423,1), Z, H(endDTDElement,429,1), 
Z, Z, Z, 
H(setfetchmode,245,1), Z, H(fgetcsv,381,1), 
H(arg,141,1), Z, H(getClosure,308,1), 
H(hasMethod,269,1), H(relaxNGValidateSource,89,1), Z, 
H(load,84,1), H(argRest,163,1), H(lasterrorcode,338,1), 
Z, H(args,161,1), Z, 
Z, Z, Z, 
H(__get,62,1), Z, Z, 
Z, Z, Z, 
Z, H(getSubPathname,256,1), H(delete,223,1), 
Z, H(getExtensionName,277,1), Z, 
Z, H(isInstantiable,292,1), H(getcolumnmeta,242,1), 
Z, Z, Z, 
H(setMaxLineLen,384,1), H(open,335,1), Z, 
H(getDeclaringClass,312,1), H(createaggregate,334,1), H(addChild,357,1), 
Z, Z, Z, 
Z, Z, Z, 
Z, Z, H(helpCmds,142,1), 
Z, Z, Z, 
Z, Z, H(getLinkTarget,180,1), 
Z, H(columntype,341,1), Z, 
H(begintransaction,237,1), Z, Z, 
H(getPath,185,1), H(fetchcolumn,241,1), Z, 
H(getPathInfo,183,1), H(isConstructor,313,1), H(isInternal,295,1), 
Z, Z, Z, 
Z, H(loadXML,92,1), H(helpSection,156,1), 
Z, Z, H(isSubclassOf,286,1), 
Z, Z, Z, 
Z, H(attributes,359,1), Z, 
Z, Z, Z, 
Z, Z, Z, 
Z, H(replaceData,68,1), H(startAttributens,411,1), 
H(isSupported,63,1), H(substringData,65,1), H(startCData,431,1), 
Z, Z, H(bindcolumn,244,1), 
H(loadImages,205,1), Z, Z, 
Z, Z, H(createElementNS,87,1), 
H(addsoapheader,372,1), H(getversion,222,1), H(onClient,168,1), 
H(getFileInfo,194,1), H(getConstant,282,1), Z, 
H(getTimezone,132,1), H(startComment,439,1), Z, 
Z, Z, Z, 
H(registerXPathNamespace,351,1), H(setAttributeNS,108,1), H(hasFeature,119,1), 
H(__sleep,240,1), H(hasAttributeNS,106,1), H(prepare,238,1), 
Z, Z, H(rollback,233,1), 
H(outputMemory,402,1), H(getTrace,32,1), H(getAttributeNS,109,1), 
Z, H(lookupNamespaceUri,49,1), Z, 
H(sortwithsortkeys,34,1), H(c14n,55,1), H(geterrormessage,43,1), 
Z, Z, Z, 
H(setInfoClass,179,1), Z, Z, 
Z, Z, Z, 
Z, H(valid,3,1), Z, 
H(invoke,307,1), H(__isset,358,1), H(saveHTML,91,1), 
H(getConstants,283,1), H(setAttributeNode,116,1), Z, 
Z, Z, Z, 
H(fetcharray,343,1), H(getNamedItem,120,1), Z, 
Z, Z, H(writeElement,422,1), 
Z, H(querysingle,339,1), Z, 
H(getFrame,159,1), Z, H(removeAttribute,115,1), 
H(getProperty,296,1), H(startDocument,403,1), H(getNamedItemNS,123,1), 
H(export,273,1), H(send,166,1), H(setIDAttributeNode,113,1), 
H(isFile,190,1), H(getErrors,207,1), Z, 
Z, Z, H(getlocale,42,1), 
Z, Z, H(onServer,169,1), 
Z, H(implementsInterface,279,1), Z, 
Z, H(getavailabledrivers,235,1), Z, 
Z, H(rowcount,249,1), H(mapping,203,1), 
H(fault,376,1), H(execute,250,1), H(getExtension,265,1), 
H(replace,225,1), H(getMethods,260,1), H(setIDAttribute,112,1), 
H(getextendedstats,227,1), H(commit,234,1), Z, 
Z, H(getDocNamespaces,355,1), Z, 
Z, H(getLineNo,45,1), H(hasProperty,287,1), 
Z, Z, H(debugdumpparams,255,1), 
Z, Z, Z, 
Z, Z, Z, 
H(setstrength,39,1), Z, Z, 
H(getType,199,1), Z, Z, 
H(getName,139,1), H(lookupPrefix,56,1), H(natsort,16,1), 
H(item,121,1), H(format,128,1), H(setTime,131,1), 
H(schemaValidate,80,1), H(ksort,23,1), H(saveHTMLFile,97,1), 
H(createDocument,117,1), Z, H(getInnerIterator,4,1), 
Z, Z, H(getIterator,122,1), 
Z, Z, Z, 
H(isAbstract,294,1), H(__soapcall,364,1), H(read,172,1), 
H(eof,387,1), H(getNodePath,58,1), Z, 
Z, H(onAutoComplete,167,1), H(createProcessingInstruction,82,1), 
H(getStaticProperties,289,1), H(writeAttribute,407,1), H(hasAttribute,105,1), 
Z, Z, Z, 
Z, Z, H(getMTime,192,1), 
H(xpath,350,1), Z, Z, 
H(quit,157,1), H(ftell,393,1), Z, 
Z, Z, Z, 
H(loadDims,202,1), Z, Z, 
Z, Z, Z, 
Z, Z, H(getStartLine,281,1), 
Z, Z, Z, 
H(isDefaultValueAvailable,316,1), H(createDocumentFragment,101,1), H(hasChildNodes,64,1), 
H(serialize,348,1), H(isPublic,314,1), Z, 
Z, H(createComment,99,1), Z, 
Z, H(relaxNGValidate,77,1), H(setDate,129,1), 
Z, H(getCommand,147,1), Z, 
H(unserialize,347,1), Z, H(getattribute,33,1), 
H(decrement,214,1), Z, Z, 
Z, Z, Z, 
Z, H(getFunctions,297,1), H(addserver,210,1), 
H(listAbbreviations,138,1), H(errorinfo,239,1), Z, 
H(next,1,1), H(schemaValidateSource,76,1), Z, 
Z, Z, Z, 
H(writeDTD,409,1), H(__wakeup,232,1), H(__getlastresponseheaders,368,1), 
Z, Z, Z, 
H(getPathname,176,1), H(createTextNode,90,1), H(c14nfile,59,1), 
H(getATime,195,1), H(removeAttributeNS,110,1), H(getstats,215,1), 
H(isDir,193,1), H(endDTDAttlist,401,1), H(writeDTDEntity,425,1), 
H(setTimezone,134,1), H(normalizeDocument,100,1), H(text,438,1), 
H(css,204,1), H(importNode,88,1), H(modify,135,1), 
H(__set,51,1), Z, Z, 
H(getDocComment,284,1), Z, H(finalize,345,1), 
H(getCsvControl,383,1), H(loadextension,329,1), Z, 
Z, Z, H(paramcount,346,1), 
H(createElement,86,1), H(xinclude,95,1), H(error,144,1), 
Z, H(fgets,391,1), Z, 
Z, Z, H(newInstance,264,1), 
H(columnname,340,1), H(lastinsertrowid,331,1), H(getGroup,177,1), 
Z, H(getCurrentLocation,164,1), Z, 
Z, H(setIndentString,420,1), Z, 
Z, Z, Z, 
H(current,7,1), Z, Z, 
Z, Z, H(test,288,1), 
Z, Z, H(offsetSet,13,1), 
Z, H(writeCData,415,1), Z, 
H(contains,398,1), Z, H(attach,396,1), 
Z, H(append,5,1), Z, 
H(setattribute,41,1), Z, H(__call,8,1), 
Z, H(createDocumentType,118,1), H(nextrowset,243,1), 
H(returnsReference,306,1), Z, Z, 
Z, Z, Z, 
H(print,154,1), H(isPassedByReference,323,1), Z, 
Z, Z, H(getElementsByTagName,72,1), 
H(isStatic,311,1), H(quote,236,1), H(getStaticVariables,303,1), 
H(getFilename,189,1), H(offsetUnset,12,1), H(fflush,388,1), 
H(isDefaultNamespace,47,1), H(getAttributeNode,111,1), H(isExecutable,196,1), 
H(sort,36,1), H(addString,201,1), H(fseek,379,1), 
Z, Z, Z, 
Z, Z, H(saveXML,81,1), 
Z, Z, Z, 
Z, H(isId,48,1), H(getPerms,173,1), 
Z, Z, H(count,15,1), 
Z, H(offsetGet,11,1), H(isPrivate,309,1), 
H(setobject,375,1), H(output,150,1), Z, 
H(createfunction,330,1), Z, Z, 
Z, H(add,221,1), Z, 
H(appendXML,102,1), H(__getlastrequestheaders,366,1), H(pconnect,220,1), 
H(flush,226,1), H(setStaticPropertyValue,291,1), H(replaceChild,53,1), 
H(key,2,1), H(__getlastresponse,369,1), H(writeRaw,424,1), 
Z, Z, Z, 
Z, H(isLocal,170,1), Z, 
Z, Z, Z, 
H(increment,213,1), H(fgetc,389,1), H(startDTDAttlist,430,1), 
H(getMethod,276,1), Z, Z, 
Z, Z, Z, 
H(getFile,30,1), Z, Z, 
Z, Z, H(getParameters,304,1), 
Z, Z, H(deleteData,69,1), 
H(fpassthru,390,1), H(isArray,320,1), H(getMaxLineLen,385,1), 
H(exec,230,1), H(setserverparams,212,1), Z, 
Z, Z, Z, 
Z, Z, Z, 
H(__setsoapheaders,362,1), Z, H(isDefault,325,1), 
Z, H(isSameNode,60,1), Z, 
H(setIndent,428,1), H(isLink,187,1), H(addUrl,208,1), 
H(writeAttributeNS,418,1), Z, H(createAttribute,94,1), 
Z, Z, Z, 
Z, Z, Z, 
Z, H(getClasses,300,1), H(set,211,1), 
H(getEndLine,268,1), Z, Z, 
H(isnormalized,228,1), H(setpersistence,373,1), Z, 
H(get,219,1), H(removeChild,61,1), H(setAccessible,326,1), 
Z, Z, Z, 
Z, Z, Z, 
Z, Z, H(columncount,246,1), 
H(setcompressthreshold,218,1), Z, Z, 
H(changes,336,1), Z, H(writeComment,406,1), 
Z, Z, Z, 
Z, Z, H(getINIEntries,298,1), 
H(newInstanceArgs,267,1), Z, Z, 
Z, H(compare,44,1), Z, 
Z, Z, H(getChildren,259,1), 
H(isOptional,321,1), H(isUserDefined,263,1), H(allowsNull,318,1), 
Z, Z, H(ask,143,1), 
H(save,93,1), H(startElementNS,413,1), H(isInstance,270,1), 
H(endComment,408,1), H(createEntityReference,79,1), H(handle,374,1), 
Z, H(getPosition,319,1), Z, 
H(endDTD,433,1), Z, Z, 
Z, Z, Z, 
Z, H(printFrame,153,1), H(getConstructor,266,1), 
H(__construct,6,1), Z, H(__unset,353,1), 
H(natcasesort,19,1), H(getOwner,191,1), H(fetchall,252,1), 
H(__dorequest,360,1), H(setCsvControl,382,1), H(getMessage,25,1), 
H(asort,20,1), H(__setlocation,365,1), Z, 
Z, Z, Z, 
Z, Z, H(lasterrormsg,332,1), 
Z, H(getNamespaces,352,1), H(getLine,28,1), 
Z, Z, Z, 
H(getSeverity,200,1), Z, Z, 
Z, Z, Z, 
H(setAttributeNodeNS,107,1), H(addAttribute,349,1), H(fgetss,380,1), 
H(getBasename,175,1), Z, Z, 
H(startAttribute,421,1), Z, Z, 
Z, Z, Z, 
H(isInterface,285,1), H(getAttributeNodeNS,104,1), Z, 
H(bindparam,247,1), Z, Z, 
H(isIterateable,261,1), H(argValue,149,1), Z, 
H(setISODate,133,1), H(hasConstant,275,1), Z, 
H(getStackTrace,151,1), Z, H(addfunction,371,1), 
H(uksort,18,1), H(getElementById,98,1), Z, 
H(code,155,1), H(getstrength,38,1), Z, 
Z, Z, H(writePI,419,1), 
H(registerNodeClass,83,1), H(ftruncate,386,1), H(getNumberOfRequiredParameters,301,1), 
H(listIdentifiers,137,1), H(invokeArgs,305,1), H(helpBody,158,1), 
H(getCode,27,1), Z, Z, 
Z, Z, Z, 
Z, Z, Z, 
Z, Z, Z, 
H(fetch,254,1), H(getTransitions,136,1), H(writeDTDAttlist,432,1), 
Z, H(lastinsertid,231,1), H(isWhitespaceInElementContent,70,1), 
H(__gettypes,370,1), H(isDot,198,1), H(isReadable,181,1), 
Z, Z, H(getDefaultProperties,290,1), 
H(connect,224,1), H(setIDAttributeNS,103,1), H(startPI,437,1), 
Z, H(bindvalue,253,1), H(endCData,405,1), 
H(getSubPath,257,1), Z, H(__setcookie,363,1), 
Z, Z, Z, 
H(helpTitle,146,1), Z, Z, 
H(argCount,140,1), H(evaluate,125,1), H(startDTDElement,414,1), 
H(hasAttributes,54,1), H(writeDTDElement,417,1), H(loadHTMLFile,96,1), 
Z, Z, Z, 
Z, Z, H(appendData,67,1), 
Z, Z, Z, 
Z, H(removeAttributeNode,114,1), H(detach,397,1), 
Z, H(splitText,71,1), H(__getlastrequest,361,1), 
Z, Z, Z, 
Z, Z, H(getStaticPropertyValue,262,1), 
Z, Z, H(clear,206,1), 
Z, H(setoptimeout,217,1), H(geterrorcode,37,1), 
H(validate,74,1), H(getDefaultValue,322,1), Z, 
Z, Z, Z, 
Z, Z, Z, 
Z, Z, Z, 
Z, Z, H(reset,344,1), 
H(getSize,188,1), Z, H(create,40,1), 
Z, H(openURI,435,1), Z, 
Z, H(getProperties,274,1), H(endDocument,416,1), 
H(errorcode,229,1), Z, H(fullEndElement,400,1), 
H(offsetExists,10,1), H(addFile,209,1), H(getRealPath,182,1), 
H(fetchobject,251,1), H(getClass,317,1), H(getNumberOfParameters,302,1), 
H(fstat,395,1), H(flock,392,1), H(children,356,1), 
H(fscanf,378,1), H(isProtected,310,1), H(isWritable,174,1), 
H(uasort,24,1), Z, Z, 
H(createCDATASection,73,1), H(getInode,186,1), Z, 
H(openMemory,434,1), Z, Z, 
H(getValue,324,1), Z, H(getOffset,130,1), 
Z, H(info,152,1), H(tutorial,148,1), 
Z, H(help,160,1), Z, 
H(writeElementNS,399,1), Z, H(getModifiers,272,1), 
H(version,328,1), H(__init__,29,1), Z, 
Z, H(wrap,165,1)};
#undef M
#undef H
#undef Z
extern const unsigned g_methodIndexReverseCallIndexSys[];
const unsigned g_methodIndexReverseCallIndexSys[] = {0, 
1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,
39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,
59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,
79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,
99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,
119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,
139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,
159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,
179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,
199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,
219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,
239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,
259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,
279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,
299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,
319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,
339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,
359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,
379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,
399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,
419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438
};
extern const char * g_methodIndexReverseIndexSys[];
const char * g_methodIndexReverseIndexSys[] = {
"next", "key", "valid", "getInnerIterator", "append", 
"__construct", "current", "__call", "rewind", "offsetExists", 
"offsetGet", "offsetUnset", "offsetSet", "getArrayCopy", "count", 
"natsort", "setFlags", "uksort", "natcasesort", "asort", 
"seek", "getFlags", "ksort", "uasort", "getMessage", 
"__toString", "getCode", "getLine", "__init__", "getFile", 
"getTraceAsString", "getTrace", "getattribute", "sortwithsortkeys", "__destruct", 
"sort", "geterrorcode", "getstrength", "setstrength", "create", 
"setattribute", "getlocale", "geterrormessage", "compare", "getLineNo", 
"insertBefore", "isDefaultNamespace", "isId", "lookupNamespaceUri", "appendChild", 
"__set", "cloneNode", "replaceChild", "hasAttributes", "c14n", 
"lookupPrefix", "normalize", "getNodePath", "c14nfile", "isSameNode", 
"removeChild", "__get", "isSupported", "hasChildNodes", "substringData", 
"insertData", "appendData", "replaceData", "deleteData", "isWhitespaceInElementContent", 
"splitText", "getElementsByTagName", "createCDATASection", "validate", "getElementsByTagNameNS", 
"schemaValidateSource", "relaxNGValidate", "loadHTML", "createEntityReference", "schemaValidate", 
"saveXML", "createProcessingInstruction", "registerNodeClass", "load", "createAttributens", 
"createElement", "createElementNS", "importNode", "relaxNGValidateSource", "createTextNode", 
"saveHTML", "loadXML", "save", "createAttribute", "xinclude", 
"loadHTMLFile", "saveHTMLFile", "getElementById", "createComment", "normalizeDocument", 
"createDocumentFragment", "appendXML", "setIDAttributeNS", "getAttributeNodeNS", "hasAttribute", 
"hasAttributeNS", "setAttributeNodeNS", "setAttributeNS", "getAttributeNS", "removeAttributeNS", 
"getAttributeNode", "setIDAttribute", "setIDAttributeNode", "removeAttributeNode", "removeAttribute", 
"setAttributeNode", "createDocument", "createDocumentType", "hasFeature", "getNamedItem", 
"item", "getIterator", "getNamedItemNS", "query", "evaluate", 
"registerPHPFunctions", "registerNamespace", "format", "setDate", "getOffset", 
"setTime", "getTimezone", "setISODate", "setTimezone", "modify", 
"getTransitions", "listIdentifiers", "listAbbreviations", "getName", "argCount", 
"arg", "helpCmds", "ask", "error", "xend", 
"helpTitle", "getCommand", "tutorial", "argValue", "output", 
"getStackTrace", "info", "printFrame", "print", "code", 
"helpSection", "quit", "helpBody", "getFrame", "help", 
"args", "addCompletion", "argRest", "getCurrentLocation", "wrap", 
"send", "onAutoComplete", "onClient", "onServer", "isLocal", 
"close", "read", "getPerms", "isWritable", "getBasename", 
"getPathname", "getGroup", "setFileClass", "setInfoClass", "getLinkTarget", 
"isReadable", "getRealPath", "getPathInfo", "getCTime", "getPath", 
"getInode", "isLink", "getSize", "getFilename", "isFile", 
"getOwner", "getMTime", "isDir", "getFileInfo", "getATime", 
"isExecutable", "openFile", "isDot", "getType", "getSeverity", 
"addString", "loadDims", "mapping", "css", "loadImages", 
"clear", "getErrors", "addUrl", "addFile", "addserver", 
"set", "setserverparams", "increment", "decrement", "getstats", 
"getserverstatus", "setoptimeout", "setcompressthreshold", "get", "pconnect", 
"add", "getversion", "delete", "connect", "replace", 
"flush", "getextendedstats", "isnormalized", "errorcode", "exec", 
"lastinsertid", "__wakeup", "rollback", "commit", "getavailabledrivers", 
"quote", "begintransaction", "prepare", "errorinfo", "__sleep", 
"fetchcolumn", "getcolumnmeta", "nextrowset", "bindcolumn", "setfetchmode", 
"columncount", "bindparam", "closecursor", "rowcount", "execute", 
"fetchobject", "fetchall", "bindvalue", "fetch", "debugdumpparams", 
"getSubPathname", "getSubPath", "hasChildren", "getChildren", "getMethods", 
"isIterateable", "getStaticPropertyValue", "isUserDefined", "newInstance", "getExtension", 
"getConstructor", "newInstanceArgs", "getEndLine", "hasMethod", "isInstance", 
"isFinal", "getModifiers", "export", "getProperties", "hasConstant", 
"getMethod", "getExtensionName", "getParentClass", "implementsInterface", "getInterfaceNames", 
"getStartLine", "getConstant", "getConstants", "getDocComment", "isInterface", 
"isSubclassOf", "hasProperty", "test", "getStaticProperties", "getDefaultProperties", 
"setStaticPropertyValue", "isInstantiable", "getInterfaces", "isAbstract", "isInternal", 
"getProperty", "getFunctions", "getINIEntries", "getClassNames", "getClasses", 
"getNumberOfRequiredParameters", "getNumberOfParameters", "getStaticVariables", "getParameters", "invokeArgs", 
"returnsReference", "invoke", "getClosure", "isPrivate", "isProtected", 
"isStatic", "getDeclaringClass", "isConstructor", "isPublic", "isDestructor", 
"isDefaultValueAvailable", "getClass", "allowsNull", "getPosition", "isArray", 
"isOptional", "getDefaultValue", "isPassedByReference", "getValue", "isDefault", 
"setAccessible", "setValue", "version", "loadextension", "createfunction", 
"lastinsertrowid", "lasterrormsg", "escapestring", "createaggregate", "open", 
"changes", "openblob", "lasterrorcode", "querysingle", "columnname", 
"columntype", "numcolumns", "fetcharray", "reset", "finalize", 
"paramcount", "unserialize", "serialize", "addAttribute", "xpath", 
"registerXPathNamespace", "getNamespaces", "__unset", "asXML", "getDocNamespaces", 
"children", "addChild", "__isset", "attributes", "__dorequest", 
"__getlastrequest", "__setsoapheaders", "__setcookie", "__soapcall", "__setlocation", 
"__getlastrequestheaders", "__getfunctions", "__getlastresponseheaders", "__getlastresponse", "__gettypes", 
"addfunction", "addsoapheader", "setpersistence", "handle", "setobject", 
"fault", "setclass", "fscanf", "fseek", "fgetss", 
"fgetcsv", "setCsvControl", "getCsvControl", "setMaxLineLen", "getMaxLineLen", 
"ftruncate", "eof", "fflush", "fgetc", "fpassthru", 
"fgets", "flock", "ftell", "fwrite", "fstat", 
"attach", "detach", "contains", "writeElementNS", "fullEndElement", 
"endDTDAttlist", "outputMemory", "startDocument", "startDTDEntity", "endCData", 
"writeComment", "writeAttribute", "endComment", "writeDTD", "endDTDEntity", 
"startAttributens", "startElement", "startElementNS", "startDTDElement", "writeCData", 
"endDocument", "writeDTDElement", "writeAttributeNS", "writePI", "setIndentString", 
"startAttribute", "writeElement", "endElement", "writeRaw", "writeDTDEntity", 
"endPI", "startDTD", "setIndent", "endDTDElement", "startDTDAttlist", 
"startCData", "writeDTDAttlist", "endDTD", "openMemory", "openURI", 
"endAttribute", "startPI", "text", "startComment"};
extern struct ObjectStaticCallbacks cw_ReflectionFunctionAbstract;
extern struct ObjectStaticCallbacks cw_ReflectionObject;
extern struct ObjectStaticCallbacks cw_SplFileObject;
extern struct ObjectStaticCallbacks cw_UnexpectedValueException;
extern struct ObjectStaticCallbacks cw_stdClass;
extern struct ObjectStaticCallbacks cw_ReflectionException;
extern struct ObjectStaticCallbacks cw_OverflowException;
extern struct ObjectStaticCallbacks cw_SplFileInfo;
extern struct ObjectStaticCallbacks cw_ArrayIterator;
extern struct ObjectStaticCallbacks cw_AppendIterator;
extern struct ObjectStaticCallbacks cw_OutOfBoundsException;
extern struct ObjectStaticCallbacks cw_LogicException;
extern struct ObjectStaticCallbacks cw_RangeException;
extern struct ObjectStaticCallbacks cw_SplObjectStorage;
extern struct ObjectStaticCallbacks cw_InvalidArgumentException;
extern struct ObjectStaticCallbacks cw_ReflectionClass;
extern struct ObjectStaticCallbacks cw_UnderflowException;
extern struct ObjectStaticCallbacks cw_ReflectionExtension;
extern struct ObjectStaticCallbacks cw_OutOfRangeException;
extern struct ObjectStaticCallbacks cw_ReflectionMethod;
extern struct ObjectStaticCallbacks cw_BadMethodCallException;
extern struct ObjectStaticCallbacks cw_ReflectionProperty;
extern struct ObjectStaticCallbacks cw___PHP_Incomplete_Class;
extern struct ObjectStaticCallbacks cw_RuntimeException;
extern struct ObjectStaticCallbacks cw_Exception;
extern struct ObjectStaticCallbacks cw_ReflectionFunction;
extern struct ObjectStaticCallbacks cw_ErrorException;
extern struct ObjectStaticCallbacks cw_RecursiveDirectoryIterator;
extern struct ObjectStaticCallbacks cw_DirectoryIterator;
extern struct ObjectStaticCallbacks cw_BadFunctionCallException;
extern struct ObjectStaticCallbacks cw_LengthException;
extern struct ObjectStaticCallbacks cw_DomainException;
extern struct ObjectStaticCallbacks cw_RecursiveIteratorIterator;
extern struct ObjectStaticCallbacks cw_Directory;
extern struct ObjectStaticCallbacks cw_FilterIterator;
extern struct ObjectStaticCallbacks cw_ReflectionParameter;
Object co_PDOException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_PDOException)())->dynCreate(params, init));
}
Object coo_PDOException() {
  Object r(NEW(c_PDOException)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_PDOException
Variant c_PDOException::os_getInit(CStrRef s) {
  return c_Exception::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_PDOException
Variant c_PDOException::os_get(CStrRef s) {
  return c_Exception::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_PDOException
Variant &c_PDOException::os_lval(CStrRef s) {
  return c_Exception::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_PDOException
void c_PDOException::o_getArray(Array &props) const {
  c_Exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_PDOException
void c_PDOException::o_setArray(CArrRef props) {
  c_Exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PDOException
Variant * c_PDOException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_PDOException
Variant * c_PDOException::o_realPropPublic(CStrRef s, int flags) const {
  return c_Exception::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_PDOException
Variant * c_PDOException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_PDOException
Variant c_PDOException::os_constant(const char *s) {
  return c_Exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_PDOException
IMPLEMENT_CLASS(PDOException)
void c_PDOException::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_PDOException::cloneImpl() {
  c_PDOException *obj = NEW(c_PDOException)();
  cloneSet(obj);
  return obj;
}
void c_PDOException::cloneSet(c_PDOException *clone) {
  c_Exception::cloneSet(clone);
}
Variant c_PDOException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_Exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_PDOException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_Exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_PDOException::ci___destruct((void*)&c_PDOException::i___destruct, (void*)&c_PDOException::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_PDOException::ci___construct((void*)&c_PDOException::i___construct, (void*)&c_PDOException::ifa___construct, 0, 0, 0x0000000000000000LL);
Variant c_PDOException::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOException *self = NULL;
  p_PDOException pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_PDOException::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOException *self = NULL;
  p_PDOException pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_PDOException::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOException *self = NULL;
  p_PDOException pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_PDOException::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOException *self = NULL;
  p_PDOException pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
bool c_PDOException::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_PDOException::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_PDOException::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_Exception::os_get_call_info(mcp, hash);
}
bool c_PDOException::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_PDOException::ci___destruct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_PDOException::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_Exception::o_get_call_info(mcp, hash);
}
c_PDOException *c_PDOException::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_PDOException::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_PDOException::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_PDOException::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_PDOException::ci___construct;
  mcp.obj = this;
}
void c_PDOException::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_PDOException = {
  c_PDOException::os_getInit,
  c_PDOException::os_get,
  c_PDOException::os_lval,
  c_PDOException::os_invoke,
  c_PDOException::os_constant,
  c_PDOException::os_get_call_info
};
Object co_DOMDocumentFragment(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMDocumentFragment)())->dynCreate(params, init));
}
Object coo_DOMDocumentFragment() {
  Object r(NEW(c_DOMDocumentFragment)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMDocumentFragment
Variant c_DOMDocumentFragment::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMDocumentFragment
Variant c_DOMDocumentFragment::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMDocumentFragment
Variant &c_DOMDocumentFragment::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMDocumentFragment
void c_DOMDocumentFragment::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMDocumentFragment
void c_DOMDocumentFragment::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMDocumentFragment
Variant * c_DOMDocumentFragment::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMDocumentFragment
Variant * c_DOMDocumentFragment::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMDocumentFragment
Variant * c_DOMDocumentFragment::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMDocumentFragment
Variant c_DOMDocumentFragment::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMDocumentFragment
IMPLEMENT_CLASS(DOMDocumentFragment)
void c_DOMDocumentFragment::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMDocumentFragment::cloneImpl() {
  c_DOMDocumentFragment *obj = NEW(c_DOMDocumentFragment)();
  cloneSet(obj);
  return obj;
}
void c_DOMDocumentFragment::cloneSet(c_DOMDocumentFragment *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMDocumentFragment::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 1:
      HASH_GUARD_LITSTR(0x1E44C8E8C1920931LL, NAMSTR(s_sys_ss3e6df6cf, "appendXML")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendxml(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMDocumentFragment::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMDocumentFragment::ci___destruct((void*)&c_DOMDocumentFragment::i___destruct, (void*)&c_DOMDocumentFragment::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMDocumentFragment::ci___construct((void*)&c_DOMDocumentFragment::i___construct, (void*)&c_DOMDocumentFragment::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMDocumentFragment::ci_appendxml((void*)&c_DOMDocumentFragment::i_appendxml, (void*)&c_DOMDocumentFragment::ifa_appendxml, 1, 0, 0x0000000000000000LL);
Variant c_DOMDocumentFragment::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocumentFragment *self = NULL;
  p_DOMDocumentFragment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentFragment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMDocumentFragment::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocumentFragment *self = NULL;
  p_DOMDocumentFragment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentFragment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMDocumentFragment::i_appendxml(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocumentFragment *self = NULL;
  p_DOMDocumentFragment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentFragment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_appendxml(arg0));
  }
}
Variant c_DOMDocumentFragment::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocumentFragment *self = NULL;
  p_DOMDocumentFragment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentFragment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMDocumentFragment::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocumentFragment *self = NULL;
  p_DOMDocumentFragment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentFragment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMDocumentFragment::ifa_appendxml(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocumentFragment *self = NULL;
  p_DOMDocumentFragment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentFragment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
  return (self->t_appendxml(a0));
}
bool c_DOMDocumentFragment::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 1:
      HASH_GUARD_LITSTR(0x1E44C8E8C1920931LL, NAMSTR(s_sys_ss3e6df6cf, "appendXML")) {
        mcp.ci = &c_DOMDocumentFragment::ci_appendxml;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMDocumentFragment::ci___destruct;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMDocumentFragment::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMDocumentFragment::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 1:
      HASH_GUARD_LITSTR(0x1E44C8E8C1920931LL, NAMSTR(s_sys_ss3e6df6cf, "appendXML")) {
        mcp.ci = &c_DOMDocumentFragment::ci_appendxml;
        mcp.obj = this;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMDocumentFragment::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMDocumentFragment::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_get_call_info(mcp, hash);
}
c_DOMDocumentFragment *c_DOMDocumentFragment::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMDocumentFragment::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMDocumentFragment::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMDocumentFragment::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMDocumentFragment::ci___construct;
  mcp.obj = this;
}
void c_DOMDocumentFragment::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMDocumentFragment = {
  c_DOMDocumentFragment::os_getInit,
  c_DOMDocumentFragment::os_get,
  c_DOMDocumentFragment::os_lval,
  c_DOMDocumentFragment::os_invoke,
  c_DOMDocumentFragment::os_constant,
  c_DOMDocumentFragment::os_get_call_info
};
Object co_DOMText(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMText)())->dynCreate(params, init));
}
Object coo_DOMText() {
  Object r(NEW(c_DOMText)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMText
Variant c_DOMText::os_getInit(CStrRef s) {
  return c_DOMCharacterData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMText
Variant c_DOMText::os_get(CStrRef s) {
  return c_DOMCharacterData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMText
Variant &c_DOMText::os_lval(CStrRef s) {
  return c_DOMCharacterData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMText
void c_DOMText::o_getArray(Array &props) const {
  c_DOMCharacterData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMText
void c_DOMText::o_setArray(CArrRef props) {
  c_DOMCharacterData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMText
Variant * c_DOMText::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMText
Variant * c_DOMText::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMCharacterData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMText
Variant * c_DOMText::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMText
Variant c_DOMText::os_constant(const char *s) {
  return c_DOMCharacterData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMText
IMPLEMENT_CLASS(DOMText)
void c_DOMText::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMText::cloneImpl() {
  c_DOMText *obj = NEW(c_DOMText)();
  cloneSet(obj);
  return obj;
}
void c_DOMText::cloneSet(c_DOMText *clone) {
  c_DOMCharacterData::cloneSet(clone);
}
Variant c_DOMText::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x714D38308D8212B7LL, NAMSTR(s_sys_ss727ded49, "splitText")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_splittext(a0));
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x28FBAB4F0F6C02DDLL, NAMSTR(s_sys_ss0f6c02dd, "isWhitespaceInElementContent")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else return (t___construct(a0), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_DOMCharacterData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMText::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMCharacterData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMText::ci___destruct((void*)&c_DOMText::i___destruct, (void*)&c_DOMText::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMText::ci___set((void*)&c_DOMText::i___set, (void*)&c_DOMText::ifa___set, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMText::ci___construct((void*)&c_DOMText::i___construct, (void*)&c_DOMText::ifa___construct, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMText::ci___get((void*)&c_DOMText::i___get, (void*)&c_DOMText::ifa___get, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMText::ci_iswhitespaceinelementcontent((void*)&c_DOMText::i_iswhitespaceinelementcontent, (void*)&c_DOMText::ifa_iswhitespaceinelementcontent, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMText::ci_splittext((void*)&c_DOMText::i_splittext, (void*)&c_DOMText::ifa_splittext, 1, 0, 0x0000000000000000LL);
Variant c_DOMText::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMText::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMText::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t___construct(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___construct(arg0), null);
  }
}
Variant c_DOMText::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMText::i_iswhitespaceinelementcontent(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
  return (self->t_iswhitespaceinelementcontent());
}
Variant c_DOMText::i_splittext(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_splittext(arg0));
  }
}
Variant c_DOMText::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMText::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMText::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
  if (count <= 0) return (self->t___construct(), null);
  return (self->t___construct(a0), null);
}
Variant c_DOMText::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
Variant c_DOMText::ifa_iswhitespaceinelementcontent(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
  return (self->t_iswhitespaceinelementcontent());
}
Variant c_DOMText::ifa_splittext(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
  return (self->t_splittext(a0));
}
bool c_DOMText::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMText::ci___destruct;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMText::ci___set;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x714D38308D8212B7LL, NAMSTR(s_sys_ss727ded49, "splitText")) {
        mcp.ci = &c_DOMText::ci_splittext;
        return true;
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x28FBAB4F0F6C02DDLL, NAMSTR(s_sys_ss0f6c02dd, "isWhitespaceInElementContent")) {
        mcp.ci = &c_DOMText::ci_iswhitespaceinelementcontent;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMText::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMText::ci___get;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMCharacterData::os_get_call_info(mcp, hash);
}
bool c_DOMText::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMText::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMText::ci___set;
        mcp.obj = this;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x714D38308D8212B7LL, NAMSTR(s_sys_ss727ded49, "splitText")) {
        mcp.ci = &c_DOMText::ci_splittext;
        mcp.obj = this;
        return true;
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x28FBAB4F0F6C02DDLL, NAMSTR(s_sys_ss0f6c02dd, "isWhitespaceInElementContent")) {
        mcp.ci = &c_DOMText::ci_iswhitespaceinelementcontent;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMText::ci___construct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMText::ci___get;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMCharacterData::o_get_call_info(mcp, hash);
}
c_DOMText *c_DOMText::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_DOMText::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 1) throw_toomany_arguments("__construct", 1, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    } while (false);
  }
  return this;
}
void c_DOMText::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  } while (false);
}
void c_DOMText::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMText::ci___construct;
  mcp.obj = this;
}
void c_DOMText::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else (t___construct(a0), null);
}
struct ObjectStaticCallbacks cw_DOMText = {
  c_DOMText::os_getInit,
  c_DOMText::os_get,
  c_DOMText::os_lval,
  c_DOMText::os_invoke,
  c_DOMText::os_constant,
  c_DOMText::os_get_call_info
};
Object co_DebuggerClient(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DebuggerClient)())->dynCreate(params, init));
}
Object coo_DebuggerClient() {
  Object r(NEW(c_DebuggerClient)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DebuggerClient
Variant c_DebuggerClient::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DebuggerClient
Variant c_DebuggerClient::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DebuggerClient
Variant &c_DebuggerClient::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DebuggerClient
void c_DebuggerClient::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DebuggerClient
void c_DebuggerClient::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DebuggerClient
Variant * c_DebuggerClient::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DebuggerClient
Variant * c_DebuggerClient::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DebuggerClient
Variant * c_DebuggerClient::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DebuggerClient
Variant c_DebuggerClient::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 2:
      HASH_RETURN(0x2038737F45604DE2LL, q_DebuggerClient_AUTO_COMPLETE_VARIABLES, "AUTO_COMPLETE_VARIABLES");
      break;
    case 7:
      HASH_RETURN(0x1B352E31B034F827LL, q_DebuggerClient_AUTO_COMPLETE_FILENAMES, "AUTO_COMPLETE_FILENAMES");
      HASH_RETURN(0x0F17BB5BEC004CA7LL, q_DebuggerClient_AUTO_COMPLETE_CLASSES, "AUTO_COMPLETE_CLASSES");
      break;
    case 9:
      HASH_RETURN(0x6A811D407DC24A29LL, q_DebuggerClient_AUTO_COMPLETE_CLASS_CONSTANTS, "AUTO_COMPLETE_CLASS_CONSTANTS");
      break;
    case 11:
      HASH_RETURN(0x1858E5511222BC8BLL, q_DebuggerClient_AUTO_COMPLETE_CLASS_PROPERTIES, "AUTO_COMPLETE_CLASS_PROPERTIES");
      HASH_RETURN(0x1DE12226E1E87B6BLL, q_DebuggerClient_AUTO_COMPLETE_CODE, "AUTO_COMPLETE_CODE");
      break;
    case 15:
      HASH_RETURN(0x2C29DCF63AAC70EFLL, q_DebuggerClient_AUTO_COMPLETE_CLASS_METHODS, "AUTO_COMPLETE_CLASS_METHODS");
      HASH_RETURN(0x76A6B174D3E2108FLL, q_DebuggerClient_AUTO_COMPLETE_KEYWORDS, "AUTO_COMPLETE_KEYWORDS");
      break;
    case 19:
      HASH_RETURN(0x78221A7B002235D3LL, q_DebuggerClient_AUTO_COMPLETE_CONSTANTS, "AUTO_COMPLETE_CONSTANTS");
      break;
    case 31:
      HASH_RETURN(0x7CAE318E6EF6449FLL, q_DebuggerClient_AUTO_COMPLETE_FUNCTIONS, "AUTO_COMPLETE_FUNCTIONS");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DebuggerClient
IMPLEMENT_CLASS(DebuggerClient)
void c_DebuggerClient::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DebuggerClient::cloneImpl() {
  c_DebuggerClient *obj = NEW(c_DebuggerClient)();
  cloneSet(obj);
  return obj;
}
void c_DebuggerClient::cloneSet(c_DebuggerClient *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DebuggerClient::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x07768FF90B181780LL, NAMSTR(s_sys_ss0b181780, "addCompletion")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addcompletion(a0), null);
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x20F2EA2BBFF5AA42LL, NAMSTR(s_sys_ss400a55be, "ask")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("ask", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_ask(count, a0));
        return (t_ask(count, a0,vargs));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x0E836DA3377C4984LL, NAMSTR(s_sys_ss377c4984, "getFrame")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getframe());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x1D033DFD1DCAEA85LL, NAMSTR(s_sys_ss1dcaea85, "printFrame")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_printframe(a0), null);
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss7fd1c778, "send")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_send(a0));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7A24AFD8ADE43B8ELL, NAMSTR(s_sys_ss521bc472, "args")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("args", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_args());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      HASH_GUARD_LITSTR(0x6B3BF595A55159CFLL, NAMSTR(s_sys_ss5aaea631, "helpBody")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_helpbody(a0), null);
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x687DF38195F5B951LL, NAMSTR(s_sys_ss6a0a46af, "helpCmds")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2) return throw_missing_arguments("helpcmds", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 2) return (t_helpcmds(count, a0, a1), null);
        return (t_helpcmds(count, a0, a1,vargs), null);
      }
      HASH_GUARD_LITSTR(0x1015EB3F52B098D1LL, NAMSTR(s_sys_ss52b098d1, "print")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("print", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_print(count, a0), null);
        return (t_print(count, a0,vargs), null);
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x182AC39D2C493A97LL, NAMSTR(s_sys_ss2c493a97, "getCommand")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcommand());
      }
      HASH_GUARD_LITSTR(0x67A7ABCB74D168D7LL, NAMSTR(s_sys_ss74d168d7, "argRest")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_argrest(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x016509DCA13DB6DFLL, NAMSTR(s_sys_ss5ec24921, "error")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("error", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_error(count, a0), null);
        return (t_error(count, a0,vargs), null);
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x0F2EF58F157D479FLL, NAMSTR(s_sys_ss157d479f, "info")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("info", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_info(count, a0), null);
        return (t_info(count, a0,vargs), null);
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x5F8B4ACA3731C423LL, NAMSTR(s_sys_ss3731c423, "helpTitle")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_helptitle(a0), null);
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x2191643700554726LL, NAMSTR(s_sys_ss00554726, "getCurrentLocation")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcurrentlocation());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x620C55BAC770E928LL, NAMSTR(s_sys_ss388f16d8, "argValue")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_argvalue(a0));
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x6CB0A07E0516B6ACLL, NAMSTR(s_sys_ss0516b6ac, "tutorial")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_tutorial(a0), null);
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x5412C8462A696DEFLL, NAMSTR(s_sys_ss2a696def, "argCount")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_argcount());
      }
      HASH_GUARD_LITSTR(0x5CE665973E2B4C6FLL, NAMSTR(s_sys_ss3e2b4c6f, "helpSection")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_helpsection(a0), null);
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x64C0B4BCDA99F6F4LL, NAMSTR(s_sys_ss2566090c, "arg")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_arg(a0, a1));
      }
      HASH_GUARD_LITSTR(0x665AFB5CDFD23534LL, NAMSTR(s_sys_ss202dcacc, "help")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("help", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_help(count, a0), null);
        return (t_help(count, a0,vargs), null);
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x04A108469024B7B6LL, NAMSTR(s_sys_ss6fdb484a, "xend")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_xend(a0));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7C41EEC813FC6FB7LL, NAMSTR(s_sys_ss13fc6fb7, "getStackTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstacktrace());
      }
      HASH_GUARD_LITSTR(0x6C5E35754AA2B277LL, NAMSTR(s_sys_ss4aa2b277, "wrap")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_wrap(a0));
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x58C72230857ACDB9LL, NAMSTR(s_sys_ss7a853247, "code")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("code", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_code(a0), null);
        else if (count == 2) return (t_code(a0, a1), null);
        else if (count == 3) return (t_code(a0, a1, a2), null);
        else return (t_code(a0, a1, a2, a3), null);
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0732FA520631017ALL, NAMSTR(s_sys_ss0631017a, "quit")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("quit", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_quit(), null);
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x07B89E83B77C677FLL, NAMSTR(s_sys_ss48839881, "output")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("output", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_output(count, a0), null);
        return (t_output(count, a0,vargs), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DebuggerClient::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DebuggerClient::ci_argcount((void*)&c_DebuggerClient::i_argcount, (void*)&c_DebuggerClient::ifa_argcount, 0, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_arg((void*)&c_DebuggerClient::i_arg, (void*)&c_DebuggerClient::ifa_arg, 2, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_helpcmds((void*)&c_DebuggerClient::i_helpcmds, (void*)&c_DebuggerClient::ifa_helpcmds, 2, 1, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_ask((void*)&c_DebuggerClient::i_ask, (void*)&c_DebuggerClient::ifa_ask, 1, 1, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_error((void*)&c_DebuggerClient::i_error, (void*)&c_DebuggerClient::ifa_error, 1, 1, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_xend((void*)&c_DebuggerClient::i_xend, (void*)&c_DebuggerClient::ifa_xend, 1, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci___destruct((void*)&c_DebuggerClient::i___destruct, (void*)&c_DebuggerClient::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_helptitle((void*)&c_DebuggerClient::i_helptitle, (void*)&c_DebuggerClient::ifa_helptitle, 1, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_getcommand((void*)&c_DebuggerClient::i_getcommand, (void*)&c_DebuggerClient::ifa_getcommand, 0, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_tutorial((void*)&c_DebuggerClient::i_tutorial, (void*)&c_DebuggerClient::ifa_tutorial, 1, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci___construct((void*)&c_DebuggerClient::i___construct, (void*)&c_DebuggerClient::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_getcode((void*)&c_DebuggerClient::i_getcode, (void*)&c_DebuggerClient::ifa_getcode, 0, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_argvalue((void*)&c_DebuggerClient::i_argvalue, (void*)&c_DebuggerClient::ifa_argvalue, 1, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_output((void*)&c_DebuggerClient::i_output, (void*)&c_DebuggerClient::ifa_output, 1, 1, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_getstacktrace((void*)&c_DebuggerClient::i_getstacktrace, (void*)&c_DebuggerClient::ifa_getstacktrace, 0, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_info((void*)&c_DebuggerClient::i_info, (void*)&c_DebuggerClient::ifa_info, 1, 1, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_printframe((void*)&c_DebuggerClient::i_printframe, (void*)&c_DebuggerClient::ifa_printframe, 1, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_print((void*)&c_DebuggerClient::i_print, (void*)&c_DebuggerClient::ifa_print, 1, 1, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_code((void*)&c_DebuggerClient::i_code, (void*)&c_DebuggerClient::ifa_code, 4, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_helpsection((void*)&c_DebuggerClient::i_helpsection, (void*)&c_DebuggerClient::ifa_helpsection, 1, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_quit((void*)&c_DebuggerClient::i_quit, (void*)&c_DebuggerClient::ifa_quit, 0, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_helpbody((void*)&c_DebuggerClient::i_helpbody, (void*)&c_DebuggerClient::ifa_helpbody, 1, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_getframe((void*)&c_DebuggerClient::i_getframe, (void*)&c_DebuggerClient::ifa_getframe, 0, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_help((void*)&c_DebuggerClient::i_help, (void*)&c_DebuggerClient::ifa_help, 1, 1, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_args((void*)&c_DebuggerClient::i_args, (void*)&c_DebuggerClient::ifa_args, 0, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_addcompletion((void*)&c_DebuggerClient::i_addcompletion, (void*)&c_DebuggerClient::ifa_addcompletion, 1, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_argrest((void*)&c_DebuggerClient::i_argrest, (void*)&c_DebuggerClient::ifa_argrest, 1, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_getcurrentlocation((void*)&c_DebuggerClient::i_getcurrentlocation, (void*)&c_DebuggerClient::ifa_getcurrentlocation, 0, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_send((void*)&c_DebuggerClient::i_send, (void*)&c_DebuggerClient::ifa_send, 1, 0, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_wrap((void*)&c_DebuggerClient::i_wrap, (void*)&c_DebuggerClient::ifa_wrap, 1, 0, 0x0000000000000000LL);
Variant c_DebuggerClient::i_argcount(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
  return (self->t_argcount());
}
Variant c_DebuggerClient::i_arg(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_arg(arg0, arg1));
  }
}
Variant c_DebuggerClient::i_helpcmds(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2) return throw_missing_arguments("helpcmds", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_helpcmds(count, arg0, arg1), null);
    return (self->t_helpcmds(count,arg0, arg1, params.slice(2, count - 2, false)), null);
  }
}
Variant c_DebuggerClient::i_ask(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("ask", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_ask(count, arg0));
    return (self->t_ask(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant c_DebuggerClient::i_error(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("error", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_error(count, arg0), null);
    return (self->t_error(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant c_DebuggerClient::i_xend(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_xend(arg0));
  }
}
Variant c_DebuggerClient::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DebuggerClient::i_helptitle(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_helptitle(arg0), null);
  }
}
Variant c_DebuggerClient::i_getcommand(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
  return (self->t_getcommand());
}
Variant c_DebuggerClient::i_tutorial(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_tutorial(arg0), null);
  }
}
Variant c_DebuggerClient::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DebuggerClient::i_getcode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
  return (self->t_getcode());
}
Variant c_DebuggerClient::i_argvalue(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_argvalue(arg0));
  }
}
Variant c_DebuggerClient::i_output(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("output", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_output(count, arg0), null);
    return (self->t_output(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant c_DebuggerClient::i_getstacktrace(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
  return (self->t_getstacktrace());
}
Variant c_DebuggerClient::i_info(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("info", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_info(count, arg0), null);
    return (self->t_info(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant c_DebuggerClient::i_printframe(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_printframe(arg0), null);
  }
}
Variant c_DebuggerClient::i_print(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("print", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_print(count, arg0), null);
    return (self->t_print(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant c_DebuggerClient::i_code(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("code", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_code(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_code(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_code(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_code(arg0, arg1, arg2, arg3), null);
  }
}
Variant c_DebuggerClient::i_helpsection(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_helpsection(arg0), null);
  }
}
Variant c_DebuggerClient::i_quit(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("quit", 0, 1);
  return (self->t_quit(), null);
}
Variant c_DebuggerClient::i_helpbody(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_helpbody(arg0), null);
  }
}
Variant c_DebuggerClient::i_getframe(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
  return (self->t_getframe());
}
Variant c_DebuggerClient::i_help(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("help", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_help(count, arg0), null);
    return (self->t_help(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant c_DebuggerClient::i_args(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("args", 0, 1);
  return (self->t_args());
}
Variant c_DebuggerClient::i_addcompletion(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_addcompletion(arg0), null);
  }
}
Variant c_DebuggerClient::i_argrest(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_argrest(arg0));
  }
}
Variant c_DebuggerClient::i_getcurrentlocation(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
  return (self->t_getcurrentlocation());
}
Variant c_DebuggerClient::i_send(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_send(arg0));
  }
}
Variant c_DebuggerClient::i_wrap(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_wrap(arg0));
  }
}
Variant c_DebuggerClient::ifa_argcount(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
  return (self->t_argcount());
}
Variant c_DebuggerClient::ifa_arg(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
  return (self->t_arg(a0, a1));
}
Variant c_DebuggerClient::ifa_helpcmds(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2) return throw_missing_arguments("helpcmds", count+1, 1);
  if (count <= 2) return (self->t_helpcmds(count, a0, a1), null);
  Array params;
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (self->t_helpcmds(count,a0, a1, params), null);
}
Variant c_DebuggerClient::ifa_ask(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("ask", count+1, 1);
  if (count <= 1) return (self->t_ask(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (self->t_ask(count,a0, params));
}
Variant c_DebuggerClient::ifa_error(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("error", count+1, 1);
  if (count <= 1) return (self->t_error(count, a0), null);
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (self->t_error(count,a0, params), null);
}
Variant c_DebuggerClient::ifa_xend(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
  return (self->t_xend(a0));
}
Variant c_DebuggerClient::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DebuggerClient::ifa_helptitle(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
  return (self->t_helptitle(a0), null);
}
Variant c_DebuggerClient::ifa_getcommand(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
  return (self->t_getcommand());
}
Variant c_DebuggerClient::ifa_tutorial(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
  return (self->t_tutorial(a0), null);
}
Variant c_DebuggerClient::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DebuggerClient::ifa_getcode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
  return (self->t_getcode());
}
Variant c_DebuggerClient::ifa_argvalue(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
  return (self->t_argvalue(a0));
}
Variant c_DebuggerClient::ifa_output(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("output", count+1, 1);
  if (count <= 1) return (self->t_output(count, a0), null);
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (self->t_output(count,a0, params), null);
}
Variant c_DebuggerClient::ifa_getstacktrace(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
  return (self->t_getstacktrace());
}
Variant c_DebuggerClient::ifa_info(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("info", count+1, 1);
  if (count <= 1) return (self->t_info(count, a0), null);
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (self->t_info(count,a0, params), null);
}
Variant c_DebuggerClient::ifa_printframe(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
  return (self->t_printframe(a0), null);
}
Variant c_DebuggerClient::ifa_print(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("print", count+1, 1);
  if (count <= 1) return (self->t_print(count, a0), null);
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (self->t_print(count,a0, params), null);
}
Variant c_DebuggerClient::ifa_code(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("code", count, 1, 4, 1);
  if (count <= 1) return (self->t_code(a0), null);
  if (count == 2) return (self->t_code(a0, a1), null);
  if (count == 3) return (self->t_code(a0, a1, a2), null);
  return (self->t_code(a0, a1, a2, a3), null);
}
Variant c_DebuggerClient::ifa_helpsection(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
  return (self->t_helpsection(a0), null);
}
Variant c_DebuggerClient::ifa_quit(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("quit", 0, 1);
  return (self->t_quit(), null);
}
Variant c_DebuggerClient::ifa_helpbody(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
  return (self->t_helpbody(a0), null);
}
Variant c_DebuggerClient::ifa_getframe(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
  return (self->t_getframe());
}
Variant c_DebuggerClient::ifa_help(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("help", count+1, 1);
  if (count <= 1) return (self->t_help(count, a0), null);
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (self->t_help(count,a0, params), null);
}
Variant c_DebuggerClient::ifa_args(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("args", 0, 1);
  return (self->t_args());
}
Variant c_DebuggerClient::ifa_addcompletion(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
  return (self->t_addcompletion(a0), null);
}
Variant c_DebuggerClient::ifa_argrest(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
  return (self->t_argrest(a0));
}
Variant c_DebuggerClient::ifa_getcurrentlocation(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
  return (self->t_getcurrentlocation());
}
Variant c_DebuggerClient::ifa_send(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
  return (self->t_send(a0));
}
Variant c_DebuggerClient::ifa_wrap(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
  return (self->t_wrap(a0));
}
bool c_DebuggerClient::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x07768FF90B181780LL, NAMSTR(s_sys_ss0b181780, "addCompletion")) {
        mcp.ci = &c_DebuggerClient::ci_addcompletion;
        return true;
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x20F2EA2BBFF5AA42LL, NAMSTR(s_sys_ss400a55be, "ask")) {
        mcp.ci = &c_DebuggerClient::ci_ask;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x0E836DA3377C4984LL, NAMSTR(s_sys_ss377c4984, "getFrame")) {
        mcp.ci = &c_DebuggerClient::ci_getframe;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x1D033DFD1DCAEA85LL, NAMSTR(s_sys_ss1dcaea85, "printFrame")) {
        mcp.ci = &c_DebuggerClient::ci_printframe;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss7fd1c778, "send")) {
        mcp.ci = &c_DebuggerClient::ci_send;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7A24AFD8ADE43B8ELL, NAMSTR(s_sys_ss521bc472, "args")) {
        mcp.ci = &c_DebuggerClient::ci_args;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        mcp.ci = &c_DebuggerClient::ci_getcode;
        return true;
      }
      HASH_GUARD_LITSTR(0x6B3BF595A55159CFLL, NAMSTR(s_sys_ss5aaea631, "helpBody")) {
        mcp.ci = &c_DebuggerClient::ci_helpbody;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x687DF38195F5B951LL, NAMSTR(s_sys_ss6a0a46af, "helpCmds")) {
        mcp.ci = &c_DebuggerClient::ci_helpcmds;
        return true;
      }
      HASH_GUARD_LITSTR(0x1015EB3F52B098D1LL, NAMSTR(s_sys_ss52b098d1, "print")) {
        mcp.ci = &c_DebuggerClient::ci_print;
        return true;
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x182AC39D2C493A97LL, NAMSTR(s_sys_ss2c493a97, "getCommand")) {
        mcp.ci = &c_DebuggerClient::ci_getcommand;
        return true;
      }
      HASH_GUARD_LITSTR(0x67A7ABCB74D168D7LL, NAMSTR(s_sys_ss74d168d7, "argRest")) {
        mcp.ci = &c_DebuggerClient::ci_argrest;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x016509DCA13DB6DFLL, NAMSTR(s_sys_ss5ec24921, "error")) {
        mcp.ci = &c_DebuggerClient::ci_error;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DebuggerClient::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0F2EF58F157D479FLL, NAMSTR(s_sys_ss157d479f, "info")) {
        mcp.ci = &c_DebuggerClient::ci_info;
        return true;
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x5F8B4ACA3731C423LL, NAMSTR(s_sys_ss3731c423, "helpTitle")) {
        mcp.ci = &c_DebuggerClient::ci_helptitle;
        return true;
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x2191643700554726LL, NAMSTR(s_sys_ss00554726, "getCurrentLocation")) {
        mcp.ci = &c_DebuggerClient::ci_getcurrentlocation;
        return true;
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x620C55BAC770E928LL, NAMSTR(s_sys_ss388f16d8, "argValue")) {
        mcp.ci = &c_DebuggerClient::ci_argvalue;
        return true;
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x6CB0A07E0516B6ACLL, NAMSTR(s_sys_ss0516b6ac, "tutorial")) {
        mcp.ci = &c_DebuggerClient::ci_tutorial;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x5412C8462A696DEFLL, NAMSTR(s_sys_ss2a696def, "argCount")) {
        mcp.ci = &c_DebuggerClient::ci_argcount;
        return true;
      }
      HASH_GUARD_LITSTR(0x5CE665973E2B4C6FLL, NAMSTR(s_sys_ss3e2b4c6f, "helpSection")) {
        mcp.ci = &c_DebuggerClient::ci_helpsection;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DebuggerClient::ci___destruct;
        return true;
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x64C0B4BCDA99F6F4LL, NAMSTR(s_sys_ss2566090c, "arg")) {
        mcp.ci = &c_DebuggerClient::ci_arg;
        return true;
      }
      HASH_GUARD_LITSTR(0x665AFB5CDFD23534LL, NAMSTR(s_sys_ss202dcacc, "help")) {
        mcp.ci = &c_DebuggerClient::ci_help;
        return true;
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x04A108469024B7B6LL, NAMSTR(s_sys_ss6fdb484a, "xend")) {
        mcp.ci = &c_DebuggerClient::ci_xend;
        return true;
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7C41EEC813FC6FB7LL, NAMSTR(s_sys_ss13fc6fb7, "getStackTrace")) {
        mcp.ci = &c_DebuggerClient::ci_getstacktrace;
        return true;
      }
      HASH_GUARD_LITSTR(0x6C5E35754AA2B277LL, NAMSTR(s_sys_ss4aa2b277, "wrap")) {
        mcp.ci = &c_DebuggerClient::ci_wrap;
        return true;
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x58C72230857ACDB9LL, NAMSTR(s_sys_ss7a853247, "code")) {
        mcp.ci = &c_DebuggerClient::ci_code;
        return true;
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0732FA520631017ALL, NAMSTR(s_sys_ss0631017a, "quit")) {
        mcp.ci = &c_DebuggerClient::ci_quit;
        return true;
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x07B89E83B77C677FLL, NAMSTR(s_sys_ss48839881, "output")) {
        mcp.ci = &c_DebuggerClient::ci_output;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DebuggerClient::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x07768FF90B181780LL, NAMSTR(s_sys_ss0b181780, "addCompletion")) {
        mcp.ci = &c_DebuggerClient::ci_addcompletion;
        mcp.obj = this;
        return true;
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x20F2EA2BBFF5AA42LL, NAMSTR(s_sys_ss400a55be, "ask")) {
        mcp.ci = &c_DebuggerClient::ci_ask;
        mcp.obj = this;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x0E836DA3377C4984LL, NAMSTR(s_sys_ss377c4984, "getFrame")) {
        mcp.ci = &c_DebuggerClient::ci_getframe;
        mcp.obj = this;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x1D033DFD1DCAEA85LL, NAMSTR(s_sys_ss1dcaea85, "printFrame")) {
        mcp.ci = &c_DebuggerClient::ci_printframe;
        mcp.obj = this;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss7fd1c778, "send")) {
        mcp.ci = &c_DebuggerClient::ci_send;
        mcp.obj = this;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7A24AFD8ADE43B8ELL, NAMSTR(s_sys_ss521bc472, "args")) {
        mcp.ci = &c_DebuggerClient::ci_args;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        mcp.ci = &c_DebuggerClient::ci_getcode;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x6B3BF595A55159CFLL, NAMSTR(s_sys_ss5aaea631, "helpBody")) {
        mcp.ci = &c_DebuggerClient::ci_helpbody;
        mcp.obj = this;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x687DF38195F5B951LL, NAMSTR(s_sys_ss6a0a46af, "helpCmds")) {
        mcp.ci = &c_DebuggerClient::ci_helpcmds;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x1015EB3F52B098D1LL, NAMSTR(s_sys_ss52b098d1, "print")) {
        mcp.ci = &c_DebuggerClient::ci_print;
        mcp.obj = this;
        return true;
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x182AC39D2C493A97LL, NAMSTR(s_sys_ss2c493a97, "getCommand")) {
        mcp.ci = &c_DebuggerClient::ci_getcommand;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x67A7ABCB74D168D7LL, NAMSTR(s_sys_ss74d168d7, "argRest")) {
        mcp.ci = &c_DebuggerClient::ci_argrest;
        mcp.obj = this;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x016509DCA13DB6DFLL, NAMSTR(s_sys_ss5ec24921, "error")) {
        mcp.ci = &c_DebuggerClient::ci_error;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DebuggerClient::ci___construct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x0F2EF58F157D479FLL, NAMSTR(s_sys_ss157d479f, "info")) {
        mcp.ci = &c_DebuggerClient::ci_info;
        mcp.obj = this;
        return true;
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x5F8B4ACA3731C423LL, NAMSTR(s_sys_ss3731c423, "helpTitle")) {
        mcp.ci = &c_DebuggerClient::ci_helptitle;
        mcp.obj = this;
        return true;
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x2191643700554726LL, NAMSTR(s_sys_ss00554726, "getCurrentLocation")) {
        mcp.ci = &c_DebuggerClient::ci_getcurrentlocation;
        mcp.obj = this;
        return true;
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x620C55BAC770E928LL, NAMSTR(s_sys_ss388f16d8, "argValue")) {
        mcp.ci = &c_DebuggerClient::ci_argvalue;
        mcp.obj = this;
        return true;
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x6CB0A07E0516B6ACLL, NAMSTR(s_sys_ss0516b6ac, "tutorial")) {
        mcp.ci = &c_DebuggerClient::ci_tutorial;
        mcp.obj = this;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x5412C8462A696DEFLL, NAMSTR(s_sys_ss2a696def, "argCount")) {
        mcp.ci = &c_DebuggerClient::ci_argcount;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x5CE665973E2B4C6FLL, NAMSTR(s_sys_ss3e2b4c6f, "helpSection")) {
        mcp.ci = &c_DebuggerClient::ci_helpsection;
        mcp.obj = this;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DebuggerClient::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x64C0B4BCDA99F6F4LL, NAMSTR(s_sys_ss2566090c, "arg")) {
        mcp.ci = &c_DebuggerClient::ci_arg;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x665AFB5CDFD23534LL, NAMSTR(s_sys_ss202dcacc, "help")) {
        mcp.ci = &c_DebuggerClient::ci_help;
        mcp.obj = this;
        return true;
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x04A108469024B7B6LL, NAMSTR(s_sys_ss6fdb484a, "xend")) {
        mcp.ci = &c_DebuggerClient::ci_xend;
        mcp.obj = this;
        return true;
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7C41EEC813FC6FB7LL, NAMSTR(s_sys_ss13fc6fb7, "getStackTrace")) {
        mcp.ci = &c_DebuggerClient::ci_getstacktrace;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x6C5E35754AA2B277LL, NAMSTR(s_sys_ss4aa2b277, "wrap")) {
        mcp.ci = &c_DebuggerClient::ci_wrap;
        mcp.obj = this;
        return true;
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x58C72230857ACDB9LL, NAMSTR(s_sys_ss7a853247, "code")) {
        mcp.ci = &c_DebuggerClient::ci_code;
        mcp.obj = this;
        return true;
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0732FA520631017ALL, NAMSTR(s_sys_ss0631017a, "quit")) {
        mcp.ci = &c_DebuggerClient::ci_quit;
        mcp.obj = this;
        return true;
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x07B89E83B77C677FLL, NAMSTR(s_sys_ss48839881, "output")) {
        mcp.ci = &c_DebuggerClient::ci_output;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_DebuggerClient *c_DebuggerClient::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DebuggerClient::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DebuggerClient::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DebuggerClient::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DebuggerClient::ci___construct;
  mcp.obj = this;
}
void c_DebuggerClient::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DebuggerClient = {
  c_DebuggerClient::os_getInit,
  c_DebuggerClient::os_get,
  c_DebuggerClient::os_lval,
  c_DebuggerClient::os_invoke,
  c_DebuggerClient::os_constant,
  c_DebuggerClient::os_get_call_info
};
Object co_DOMCDATASection(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMCDATASection)())->dynCreate(params, init));
}
Object coo_DOMCDATASection() {
  Object r(NEW(c_DOMCDATASection)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMCDATASection
Variant c_DOMCDATASection::os_getInit(CStrRef s) {
  return c_DOMText::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMCDATASection
Variant c_DOMCDATASection::os_get(CStrRef s) {
  return c_DOMText::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMCDATASection
Variant &c_DOMCDATASection::os_lval(CStrRef s) {
  return c_DOMText::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMCDATASection
void c_DOMCDATASection::o_getArray(Array &props) const {
  c_DOMText::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMCDATASection
void c_DOMCDATASection::o_setArray(CArrRef props) {
  c_DOMText::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMCDATASection
Variant * c_DOMCDATASection::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMCDATASection
Variant * c_DOMCDATASection::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMText::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMCDATASection
Variant * c_DOMCDATASection::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMCDATASection
Variant c_DOMCDATASection::os_constant(const char *s) {
  return c_DOMText::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMCDATASection
IMPLEMENT_CLASS(DOMCDATASection)
void c_DOMCDATASection::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMCDATASection::cloneImpl() {
  c_DOMCDATASection *obj = NEW(c_DOMCDATASection)();
  cloneSet(obj);
  return obj;
}
void c_DOMCDATASection::cloneSet(c_DOMCDATASection *clone) {
  c_DOMText::cloneSet(clone);
}
Variant c_DOMCDATASection::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_DOMText::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMCDATASection::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMText::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMCDATASection::ci___destruct((void*)&c_DOMCDATASection::i___destruct, (void*)&c_DOMCDATASection::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMCDATASection::ci___construct((void*)&c_DOMCDATASection::i___construct, (void*)&c_DOMCDATASection::ifa___construct, 1, 0, 0x0000000000000000LL);
Variant c_DOMCDATASection::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCDATASection *self = NULL;
  p_DOMCDATASection pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCDATASection*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMCDATASection::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCDATASection *self = NULL;
  p_DOMCDATASection pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCDATASection*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___construct(arg0), null);
  }
}
Variant c_DOMCDATASection::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCDATASection *self = NULL;
  p_DOMCDATASection pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCDATASection*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMCDATASection::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCDATASection *self = NULL;
  p_DOMCDATASection pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCDATASection*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  return (self->t___construct(a0), null);
}
bool c_DOMCDATASection::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMCDATASection::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMCDATASection::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMText::os_get_call_info(mcp, hash);
}
bool c_DOMCDATASection::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMCDATASection::ci___destruct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMCDATASection::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMText::o_get_call_info(mcp, hash);
}
c_DOMCDATASection *c_DOMCDATASection::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_DOMCDATASection::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_DOMCDATASection::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_DOMCDATASection::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMCDATASection::ci___construct;
  mcp.obj = this;
}
void c_DOMCDATASection::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
struct ObjectStaticCallbacks cw_DOMCDATASection = {
  c_DOMCDATASection::os_getInit,
  c_DOMCDATASection::os_get,
  c_DOMCDATASection::os_lval,
  c_DOMCDATASection::os_invoke,
  c_DOMCDATASection::os_constant,
  c_DOMCDATASection::os_get_call_info
};
Object co_Locale(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_Locale)())->dynCreate(params, init));
}
Object coo_Locale() {
  Object r(NEW(c_Locale)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Locale
Variant c_Locale::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_Locale
Variant c_Locale::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Locale
Variant &c_Locale::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_Locale
void c_Locale::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_Locale
void c_Locale::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_Locale
Variant * c_Locale::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Locale
Variant * c_Locale::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Locale
Variant * c_Locale::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_Locale
Variant c_Locale::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 3) {
    case 1:
      HASH_RETURN(0x78695696B47AF8CDLL, q_Locale_ACTUAL_LOCALE, "ACTUAL_LOCALE");
      HASH_RETURN(0x35B10383BBF3BAE1LL, q_Locale_VALID_LOCALE, "VALID_LOCALE");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_Locale
IMPLEMENT_CLASS(Locale)
void c_Locale::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_Locale::cloneImpl() {
  c_Locale *obj = NEW(c_Locale)();
  cloneSet(obj);
  return obj;
}
void c_Locale::cloneSet(c_Locale *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_Locale::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_Locale::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_Locale::ci___destruct((void*)&c_Locale::i___destruct, (void*)&c_Locale::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_Locale::ci___construct((void*)&c_Locale::i___construct, (void*)&c_Locale::ifa___construct, 0, 0, 0x0000000000000000LL);
Variant c_Locale::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Locale *self = NULL;
  p_Locale pobj;
  if (mcp.obj) {
    self = static_cast<c_Locale*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_Locale::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Locale *self = NULL;
  p_Locale pobj;
  if (mcp.obj) {
    self = static_cast<c_Locale*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_Locale::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Locale *self = NULL;
  p_Locale pobj;
  if (mcp.obj) {
    self = static_cast<c_Locale*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_Locale::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Locale *self = NULL;
  p_Locale pobj;
  if (mcp.obj) {
    self = static_cast<c_Locale*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
bool c_Locale::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_Locale::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_Locale::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_Locale::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_Locale::ci___destruct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_Locale::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_Locale *c_Locale::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_Locale::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_Locale::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_Locale::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_Locale::ci___construct;
  mcp.obj = this;
}
void c_Locale::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_Locale = {
  c_Locale::os_getInit,
  c_Locale::os_get,
  c_Locale::os_lval,
  c_Locale::os_invoke,
  c_Locale::os_constant,
  c_Locale::os_get_call_info
};
Object co_DOMDocumentType(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMDocumentType)())->dynCreate(params, init));
}
Object coo_DOMDocumentType() {
  Object r(NEW(c_DOMDocumentType)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMDocumentType
Variant c_DOMDocumentType::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMDocumentType
Variant c_DOMDocumentType::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMDocumentType
Variant &c_DOMDocumentType::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMDocumentType
void c_DOMDocumentType::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMDocumentType
void c_DOMDocumentType::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMDocumentType
Variant * c_DOMDocumentType::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMDocumentType
Variant * c_DOMDocumentType::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMDocumentType
Variant * c_DOMDocumentType::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMDocumentType
Variant c_DOMDocumentType::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMDocumentType
IMPLEMENT_CLASS(DOMDocumentType)
void c_DOMDocumentType::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMDocumentType::cloneImpl() {
  c_DOMDocumentType *obj = NEW(c_DOMDocumentType)();
  cloneSet(obj);
  return obj;
}
void c_DOMDocumentType::cloneSet(c_DOMDocumentType *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMDocumentType::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMDocumentType::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMDocumentType::ci___destruct((void*)&c_DOMDocumentType::i___destruct, (void*)&c_DOMDocumentType::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMDocumentType::ci___set((void*)&c_DOMDocumentType::i___set, (void*)&c_DOMDocumentType::ifa___set, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMDocumentType::ci___construct((void*)&c_DOMDocumentType::i___construct, (void*)&c_DOMDocumentType::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMDocumentType::ci___get((void*)&c_DOMDocumentType::i___get, (void*)&c_DOMDocumentType::ifa___get, 1, 0, 0x0000000000000000LL);
Variant c_DOMDocumentType::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocumentType *self = NULL;
  p_DOMDocumentType pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentType*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMDocumentType::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocumentType *self = NULL;
  p_DOMDocumentType pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentType*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMDocumentType::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocumentType *self = NULL;
  p_DOMDocumentType pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentType*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMDocumentType::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocumentType *self = NULL;
  p_DOMDocumentType pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentType*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMDocumentType::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocumentType *self = NULL;
  p_DOMDocumentType pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentType*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMDocumentType::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocumentType *self = NULL;
  p_DOMDocumentType pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentType*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMDocumentType::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocumentType *self = NULL;
  p_DOMDocumentType pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentType*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMDocumentType::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocumentType *self = NULL;
  p_DOMDocumentType pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentType*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
bool c_DOMDocumentType::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMDocumentType::ci___destruct;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMDocumentType::ci___set;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMDocumentType::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMDocumentType::ci___get;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMDocumentType::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMDocumentType::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMDocumentType::ci___set;
        mcp.obj = this;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMDocumentType::ci___construct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMDocumentType::ci___get;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_get_call_info(mcp, hash);
}
c_DOMDocumentType *c_DOMDocumentType::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMDocumentType::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMDocumentType::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMDocumentType::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMDocumentType::ci___construct;
  mcp.obj = this;
}
void c_DOMDocumentType::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMDocumentType = {
  c_DOMDocumentType::os_getInit,
  c_DOMDocumentType::os_get,
  c_DOMDocumentType::os_lval,
  c_DOMDocumentType::os_invoke,
  c_DOMDocumentType::os_constant,
  c_DOMDocumentType::os_get_call_info
};
Object co_SQLite3Stmt(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SQLite3Stmt)())->dynCreate(params, init));
}
Object coo_SQLite3Stmt() {
  Object r(NEW(c_SQLite3Stmt)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SQLite3Stmt
Variant c_SQLite3Stmt::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SQLite3Stmt
Variant c_SQLite3Stmt::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SQLite3Stmt
Variant &c_SQLite3Stmt::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SQLite3Stmt
void c_SQLite3Stmt::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SQLite3Stmt
void c_SQLite3Stmt::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SQLite3Stmt
Variant * c_SQLite3Stmt::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SQLite3Stmt
Variant * c_SQLite3Stmt::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SQLite3Stmt
Variant * c_SQLite3Stmt::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SQLite3Stmt
Variant c_SQLite3Stmt::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SQLite3Stmt
IMPLEMENT_CLASS(SQLite3Stmt)
void c_SQLite3Stmt::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SQLite3Stmt::cloneImpl() {
  c_SQLite3Stmt *obj = NEW(c_SQLite3Stmt)();
  cloneSet(obj);
  return obj;
}
void c_SQLite3Stmt::cloneSet(c_SQLite3Stmt *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SQLite3Stmt::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss22a924e0, "reset")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_reset());
      }
      break;
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss3628e403, "bindvalue")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindvalue(a0, a1));
        else return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x31DA235C5A226667LL, NAMSTR(s_sys_ss5a226667, "clear")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_clear());
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss14a88eb2, "execute")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_execute());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1ba41696, "bindparam")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        else return (t_bindparam(a0, ref(a1), a2));
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x72FA987001E93357LL, NAMSTR(s_sys_ss01e93357, "paramcount")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_paramcount());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SQLite3Stmt::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SQLite3Stmt::ci___destruct((void*)&c_SQLite3Stmt::i___destruct, (void*)&c_SQLite3Stmt::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_SQLite3Stmt::ci___construct((void*)&c_SQLite3Stmt::i___construct, (void*)&c_SQLite3Stmt::ifa___construct, 2, 0, 0x0000000000000000LL);
CallInfo c_SQLite3Stmt::ci_close((void*)&c_SQLite3Stmt::i_close, (void*)&c_SQLite3Stmt::ifa_close, 0, 0, 0x0000000000000000LL);
CallInfo c_SQLite3Stmt::ci_paramcount((void*)&c_SQLite3Stmt::i_paramcount, (void*)&c_SQLite3Stmt::ifa_paramcount, 0, 0, 0x0000000000000000LL);
CallInfo c_SQLite3Stmt::ci_bindparam((void*)&c_SQLite3Stmt::i_bindparam, (void*)&c_SQLite3Stmt::ifa_bindparam, 3, 0, 0x0000000000000002LL);
CallInfo c_SQLite3Stmt::ci_execute((void*)&c_SQLite3Stmt::i_execute, (void*)&c_SQLite3Stmt::ifa_execute, 0, 0, 0x0000000000000000LL);
CallInfo c_SQLite3Stmt::ci_reset((void*)&c_SQLite3Stmt::i_reset, (void*)&c_SQLite3Stmt::ifa_reset, 0, 0, 0x0000000000000000LL);
CallInfo c_SQLite3Stmt::ci_clear((void*)&c_SQLite3Stmt::i_clear, (void*)&c_SQLite3Stmt::ifa_clear, 0, 0, 0x0000000000000000LL);
CallInfo c_SQLite3Stmt::ci_bindvalue((void*)&c_SQLite3Stmt::i_bindvalue, (void*)&c_SQLite3Stmt::ifa_bindvalue, 3, 0, 0x0000000000000000LL);
Variant c_SQLite3Stmt::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SQLite3Stmt::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_SQLite3Stmt::i_close(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("close", 0, 1);
  return (self->t_close());
}
Variant c_SQLite3Stmt::i_paramcount(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
  return (self->t_paramcount());
}
Variant c_SQLite3Stmt::i_bindparam(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_bindparam(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_bindparam(arg0, arg1, arg2));
  }
}
Variant c_SQLite3Stmt::i_execute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("execute", 0, 1);
  return (self->t_execute());
}
Variant c_SQLite3Stmt::i_reset(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("reset", 0, 1);
  return (self->t_reset());
}
Variant c_SQLite3Stmt::i_clear(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("clear", 0, 1);
  return (self->t_clear());
}
Variant c_SQLite3Stmt::i_bindvalue(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_bindvalue(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_bindvalue(arg0, arg1, arg2));
  }
}
Variant c_SQLite3Stmt::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SQLite3Stmt::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
  return (self->t___construct(a0, a1), null);
}
Variant c_SQLite3Stmt::ifa_close(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("close", 0, 1);
  return (self->t_close());
}
Variant c_SQLite3Stmt::ifa_paramcount(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
  return (self->t_paramcount());
}
Variant c_SQLite3Stmt::ifa_bindparam(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
  if (count <= 2) return (self->t_bindparam(a0, ref(a1)));
  return (self->t_bindparam(a0, ref(a1), a2));
}
Variant c_SQLite3Stmt::ifa_execute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("execute", 0, 1);
  return (self->t_execute());
}
Variant c_SQLite3Stmt::ifa_reset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("reset", 0, 1);
  return (self->t_reset());
}
Variant c_SQLite3Stmt::ifa_clear(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("clear", 0, 1);
  return (self->t_clear());
}
Variant c_SQLite3Stmt::ifa_bindvalue(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
  if (count <= 2) return (self->t_bindvalue(a0, a1));
  return (self->t_bindvalue(a0, a1, a2));
}
bool c_SQLite3Stmt::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss22a924e0, "reset")) {
        mcp.ci = &c_SQLite3Stmt::ci_reset;
        return true;
      }
      break;
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        mcp.ci = &c_SQLite3Stmt::ci_close;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss3628e403, "bindvalue")) {
        mcp.ci = &c_SQLite3Stmt::ci_bindvalue;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x31DA235C5A226667LL, NAMSTR(s_sys_ss5a226667, "clear")) {
        mcp.ci = &c_SQLite3Stmt::ci_clear;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss14a88eb2, "execute")) {
        mcp.ci = &c_SQLite3Stmt::ci_execute;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SQLite3Stmt::ci___destruct;
        return true;
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1ba41696, "bindparam")) {
        mcp.ci = &c_SQLite3Stmt::ci_bindparam;
        return true;
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x72FA987001E93357LL, NAMSTR(s_sys_ss01e93357, "paramcount")) {
        mcp.ci = &c_SQLite3Stmt::ci_paramcount;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SQLite3Stmt::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SQLite3Stmt::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss22a924e0, "reset")) {
        mcp.ci = &c_SQLite3Stmt::ci_reset;
        mcp.obj = this;
        return true;
      }
      break;
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        mcp.ci = &c_SQLite3Stmt::ci_close;
        mcp.obj = this;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss3628e403, "bindvalue")) {
        mcp.ci = &c_SQLite3Stmt::ci_bindvalue;
        mcp.obj = this;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x31DA235C5A226667LL, NAMSTR(s_sys_ss5a226667, "clear")) {
        mcp.ci = &c_SQLite3Stmt::ci_clear;
        mcp.obj = this;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss14a88eb2, "execute")) {
        mcp.ci = &c_SQLite3Stmt::ci_execute;
        mcp.obj = this;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SQLite3Stmt::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1ba41696, "bindparam")) {
        mcp.ci = &c_SQLite3Stmt::ci_bindparam;
        mcp.obj = this;
        return true;
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x72FA987001E93357LL, NAMSTR(s_sys_ss01e93357, "paramcount")) {
        mcp.ci = &c_SQLite3Stmt::ci_paramcount;
        mcp.obj = this;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SQLite3Stmt::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_SQLite3Stmt *c_SQLite3Stmt::create(Object a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_SQLite3Stmt::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    }
  }
  return this;
}
void c_SQLite3Stmt::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  }
}
void c_SQLite3Stmt::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SQLite3Stmt::ci___construct;
  mcp.obj = this;
}
void c_SQLite3Stmt::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0, a1), null);
}
struct ObjectStaticCallbacks cw_SQLite3Stmt = {
  c_SQLite3Stmt::os_getInit,
  c_SQLite3Stmt::os_get,
  c_SQLite3Stmt::os_lval,
  c_SQLite3Stmt::os_invoke,
  c_SQLite3Stmt::os_constant,
  c_SQLite3Stmt::os_get_call_info
};
Object co_DOMNodeList(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMNodeList)())->dynCreate(params, init));
}
Object coo_DOMNodeList() {
  Object r(NEW(c_DOMNodeList)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNodeList
Variant c_DOMNodeList::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNodeList
Variant c_DOMNodeList::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNodeList
Variant &c_DOMNodeList::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNodeList
void c_DOMNodeList::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNodeList
void c_DOMNodeList::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMNodeList
Variant * c_DOMNodeList::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNodeList
Variant * c_DOMNodeList::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNodeList
Variant * c_DOMNodeList::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNodeList
Variant c_DOMNodeList::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNodeList
IMPLEMENT_CLASS(DOMNodeList)
void c_DOMNodeList::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMNodeList::cloneImpl() {
  c_DOMNodeList *obj = NEW(c_DOMNodeList)();
  cloneSet(obj);
  return obj;
}
void c_DOMNodeList::cloneSet(c_DOMNodeList *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DOMNodeList::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getIterator")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss7cf6fd3a, "item")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_item(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMNodeList::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMNodeList::ci_item((void*)&c_DOMNodeList::i_item, (void*)&c_DOMNodeList::ifa_item, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMNodeList::ci___destruct((void*)&c_DOMNodeList::i___destruct, (void*)&c_DOMNodeList::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNodeList::ci___set((void*)&c_DOMNodeList::i___set, (void*)&c_DOMNodeList::ifa___set, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMNodeList::ci___construct((void*)&c_DOMNodeList::i___construct, (void*)&c_DOMNodeList::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNodeList::ci_getiterator((void*)&c_DOMNodeList::i_getiterator, (void*)&c_DOMNodeList::ifa_getiterator, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNodeList::ci___get((void*)&c_DOMNodeList::i___get, (void*)&c_DOMNodeList::ifa___get, 1, 0, 0x0000000000000000LL);
Variant c_DOMNodeList::i_item(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_item(arg0));
  }
}
Variant c_DOMNodeList::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNodeList::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMNodeList::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNodeList::i_getiterator(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
  return (self->t_getiterator());
}
Variant c_DOMNodeList::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMNodeList::ifa_item(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
  return (self->t_item(a0));
}
Variant c_DOMNodeList::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNodeList::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMNodeList::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNodeList::ifa_getiterator(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
  return (self->t_getiterator());
}
Variant c_DOMNodeList::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
bool c_DOMNodeList::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMNodeList::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getIterator")) {
        mcp.ci = &c_DOMNodeList::ci_getiterator;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMNodeList::ci___set;
        return true;
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss7cf6fd3a, "item")) {
        mcp.ci = &c_DOMNodeList::ci_item;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMNodeList::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMNodeList::ci___get;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DOMNodeList::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMNodeList::ci___destruct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getIterator")) {
        mcp.ci = &c_DOMNodeList::ci_getiterator;
        mcp.obj = this;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMNodeList::ci___set;
        mcp.obj = this;
        return true;
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss7cf6fd3a, "item")) {
        mcp.ci = &c_DOMNodeList::ci_item;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMNodeList::ci___construct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMNodeList::ci___get;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_DOMNodeList *c_DOMNodeList::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMNodeList::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMNodeList::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMNodeList::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMNodeList::ci___construct;
  mcp.obj = this;
}
void c_DOMNodeList::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMNodeList = {
  c_DOMNodeList::os_getInit,
  c_DOMNodeList::os_get,
  c_DOMNodeList::os_lval,
  c_DOMNodeList::os_invoke,
  c_DOMNodeList::os_constant,
  c_DOMNodeList::os_get_call_info
};
Object co_Normalizer(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_Normalizer)())->dynCreate(params, init));
}
Object coo_Normalizer() {
  Object r(NEW(c_Normalizer)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Normalizer
Variant c_Normalizer::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_Normalizer
Variant c_Normalizer::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Normalizer
Variant &c_Normalizer::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_Normalizer
void c_Normalizer::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_Normalizer
void c_Normalizer::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_Normalizer
Variant * c_Normalizer::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Normalizer
Variant * c_Normalizer::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Normalizer
Variant * c_Normalizer::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_Normalizer
Variant c_Normalizer::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 1:
      HASH_RETURN(0x2C9DA0E379A28381LL, q_Normalizer_FORM_KD, "FORM_KD");
      HASH_RETURN(0x1C369D0E14B76C41LL, q_Normalizer_FORM_KC, "FORM_KC");
      HASH_RETURN(0x3E3AA0A97BD09921LL, q_Normalizer_NFKC, "NFKC");
      break;
    case 2:
      HASH_RETURN(0x07512AA38ADD1AE2LL, q_Normalizer_FORM_D, "FORM_D");
      break;
    case 6:
      HASH_RETURN(0x51422F059BEFCD86LL, q_Normalizer_NFC, "NFC");
      break;
    case 15:
      HASH_RETURN(0x58B301790FA834EFLL, q_Normalizer_NFD, "NFD");
      HASH_RETURN(0x3CF19F2D23C185CFLL, q_Normalizer_NFKD, "NFKD");
      break;
    case 19:
      HASH_RETURN(0x2EFDCA1922BFB273LL, q_Normalizer_NONE, "NONE");
      break;
    case 31:
      HASH_RETURN(0x3BE3511FDA9A9E7FLL, q_Normalizer_FORM_C, "FORM_C");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_Normalizer
IMPLEMENT_CLASS(Normalizer)
void c_Normalizer::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_Normalizer::cloneImpl() {
  c_Normalizer *obj = NEW(c_Normalizer)();
  cloneSet(obj);
  return obj;
}
void c_Normalizer::cloneSet(c_Normalizer *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_Normalizer::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 2:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_normalize(o_getClassName(), a0));
        else return (ti_normalize(o_getClassName(), a0, a1));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x58CF37E15F66ED1DLL, NAMSTR(s_sys_ss5f66ed1d, "isnormalized")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_isnormalized(o_getClassName(), a0));
        else return (ti_isnormalized(o_getClassName(), a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_Normalizer::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 1:
      HASH_GUARD_LITSTR(0x58CF37E15F66ED1DLL, NAMSTR(s_sys_ss5f66ed1d, "isnormalized")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_isnormalized(c, a0));
        else return (ti_isnormalized(c, a0, a1));
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_normalize(c, a0));
        else return (ti_normalize(c, a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_Normalizer::ci___destruct((void*)&c_Normalizer::i___destruct, (void*)&c_Normalizer::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_Normalizer::ci___construct((void*)&c_Normalizer::i___construct, (void*)&c_Normalizer::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_Normalizer::ci_normalize((void*)&c_Normalizer::i_normalize, (void*)&c_Normalizer::ifa_normalize, 2, 0, 0x0000000000000000LL);
CallInfo c_Normalizer::ci_isnormalized((void*)&c_Normalizer::i_isnormalized, (void*)&c_Normalizer::ifa_isnormalized, 2, 0, 0x0000000000000000LL);
Variant c_Normalizer::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Normalizer *self = NULL;
  p_Normalizer pobj;
  if (mcp.obj) {
    self = static_cast<c_Normalizer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_Normalizer::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Normalizer *self = NULL;
  p_Normalizer pobj;
  if (mcp.obj) {
    self = static_cast<c_Normalizer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_Normalizer::i_normalize(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  const char *c;
  if (mcp.rootObj.is(KindOfObject)) {
    c = mcp.rootObj.getObjectData()->o_getClassName();
  } else {
    c = mcp.rootObj.getCStr();
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (c_Normalizer::ti_normalize(c, arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (c_Normalizer::ti_normalize(c, arg0, arg1));
  }
}
Variant c_Normalizer::i_isnormalized(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  const char *c;
  if (mcp.rootObj.is(KindOfObject)) {
    c = mcp.rootObj.getObjectData()->o_getClassName();
  } else {
    c = mcp.rootObj.getCStr();
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (c_Normalizer::ti_isnormalized(c, arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (c_Normalizer::ti_isnormalized(c, arg0, arg1));
  }
}
Variant c_Normalizer::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Normalizer *self = NULL;
  p_Normalizer pobj;
  if (mcp.obj) {
    self = static_cast<c_Normalizer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_Normalizer::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Normalizer *self = NULL;
  p_Normalizer pobj;
  if (mcp.obj) {
    self = static_cast<c_Normalizer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_Normalizer::ifa_normalize(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  const char *c;
  if (mcp.rootObj.is(KindOfObject)) {
    c = mcp.rootObj.getObjectData()->o_getClassName();
  } else {
    c = mcp.rootObj.getCStr();
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
  if (count <= 1) return (c_Normalizer::ti_normalize(c, a0));
  return (c_Normalizer::ti_normalize(c, a0, a1));
}
Variant c_Normalizer::ifa_isnormalized(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  const char *c;
  if (mcp.rootObj.is(KindOfObject)) {
    c = mcp.rootObj.getObjectData()->o_getClassName();
  } else {
    c = mcp.rootObj.getCStr();
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
  if (count <= 1) return (c_Normalizer::ti_isnormalized(c, a0));
  return (c_Normalizer::ti_isnormalized(c, a0, a1));
}
bool c_Normalizer::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 2:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        mcp.ci = &c_Normalizer::ci_normalize;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_Normalizer::ci___destruct;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x58CF37E15F66ED1DLL, NAMSTR(s_sys_ss5f66ed1d, "isnormalized")) {
        mcp.ci = &c_Normalizer::ci_isnormalized;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_Normalizer::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_Normalizer::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 2:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        mcp.ci = &c_Normalizer::ci_normalize;
        mcp.obj = this;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_Normalizer::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x58CF37E15F66ED1DLL, NAMSTR(s_sys_ss5f66ed1d, "isnormalized")) {
        mcp.ci = &c_Normalizer::ci_isnormalized;
        mcp.obj = this;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_Normalizer::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_Normalizer *c_Normalizer::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_Normalizer::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_Normalizer::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_Normalizer::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_Normalizer::ci___construct;
  mcp.obj = this;
}
void c_Normalizer::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_Normalizer = {
  c_Normalizer::os_getInit,
  c_Normalizer::os_get,
  c_Normalizer::os_lval,
  c_Normalizer::os_invoke,
  c_Normalizer::os_constant,
  c_Normalizer::os_get_call_info
};
Object co_DOMCharacterData(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMCharacterData)())->dynCreate(params, init));
}
Object coo_DOMCharacterData() {
  Object r(NEW(c_DOMCharacterData)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMCharacterData
Variant c_DOMCharacterData::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMCharacterData
Variant c_DOMCharacterData::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMCharacterData
Variant &c_DOMCharacterData::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMCharacterData
void c_DOMCharacterData::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMCharacterData
void c_DOMCharacterData::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMCharacterData
Variant * c_DOMCharacterData::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMCharacterData
Variant * c_DOMCharacterData::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMCharacterData
Variant * c_DOMCharacterData::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMCharacterData
Variant c_DOMCharacterData::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMCharacterData
IMPLEMENT_CLASS(DOMCharacterData)
void c_DOMCharacterData::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMCharacterData::cloneImpl() {
  c_DOMCharacterData *obj = NEW(c_DOMCharacterData)();
  cloneSet(obj);
  return obj;
}
void c_DOMCharacterData::cloneSet(c_DOMCharacterData *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMCharacterData::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 13:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appendData")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringData")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replaceData")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deleteData")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertData")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMCharacterData::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMCharacterData::ci___destruct((void*)&c_DOMCharacterData::i___destruct, (void*)&c_DOMCharacterData::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMCharacterData::ci_substringdata((void*)&c_DOMCharacterData::i_substringdata, (void*)&c_DOMCharacterData::ifa_substringdata, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMCharacterData::ci___set((void*)&c_DOMCharacterData::i___set, (void*)&c_DOMCharacterData::ifa___set, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMCharacterData::ci_insertdata((void*)&c_DOMCharacterData::i_insertdata, (void*)&c_DOMCharacterData::ifa_insertdata, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMCharacterData::ci___construct((void*)&c_DOMCharacterData::i___construct, (void*)&c_DOMCharacterData::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMCharacterData::ci_appenddata((void*)&c_DOMCharacterData::i_appenddata, (void*)&c_DOMCharacterData::ifa_appenddata, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMCharacterData::ci___get((void*)&c_DOMCharacterData::i___get, (void*)&c_DOMCharacterData::ifa___get, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMCharacterData::ci_replacedata((void*)&c_DOMCharacterData::i_replacedata, (void*)&c_DOMCharacterData::ifa_replacedata, 3, 0, 0x0000000000000000LL);
CallInfo c_DOMCharacterData::ci_deletedata((void*)&c_DOMCharacterData::i_deletedata, (void*)&c_DOMCharacterData::ifa_deletedata, 2, 0, 0x0000000000000000LL);
Variant c_DOMCharacterData::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMCharacterData::i_substringdata(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_substringdata(arg0, arg1));
  }
}
Variant c_DOMCharacterData::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMCharacterData::i_insertdata(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_insertdata(arg0, arg1));
  }
}
Variant c_DOMCharacterData::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMCharacterData::i_appenddata(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_appenddata(arg0));
  }
}
Variant c_DOMCharacterData::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMCharacterData::i_replacedata(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_replacedata(arg0, arg1, arg2));
  }
}
Variant c_DOMCharacterData::i_deletedata(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_deletedata(arg0, arg1));
  }
}
Variant c_DOMCharacterData::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMCharacterData::ifa_substringdata(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
  return (self->t_substringdata(a0, a1));
}
Variant c_DOMCharacterData::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMCharacterData::ifa_insertdata(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
  return (self->t_insertdata(a0, a1));
}
Variant c_DOMCharacterData::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMCharacterData::ifa_appenddata(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
  return (self->t_appenddata(a0));
}
Variant c_DOMCharacterData::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
Variant c_DOMCharacterData::ifa_replacedata(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
  return (self->t_replacedata(a0, a1, a2));
}
Variant c_DOMCharacterData::ifa_deletedata(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
  return (self->t_deletedata(a0, a1));
}
bool c_DOMCharacterData::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 13:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appendData")) {
        mcp.ci = &c_DOMCharacterData::ci_appenddata;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMCharacterData::ci___get;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringData")) {
        mcp.ci = &c_DOMCharacterData::ci_substringdata;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMCharacterData::ci___destruct;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replaceData")) {
        mcp.ci = &c_DOMCharacterData::ci_replacedata;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMCharacterData::ci___set;
        return true;
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deleteData")) {
        mcp.ci = &c_DOMCharacterData::ci_deletedata;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertData")) {
        mcp.ci = &c_DOMCharacterData::ci_insertdata;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMCharacterData::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMCharacterData::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 13:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appendData")) {
        mcp.ci = &c_DOMCharacterData::ci_appenddata;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMCharacterData::ci___get;
        mcp.obj = this;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringData")) {
        mcp.ci = &c_DOMCharacterData::ci_substringdata;
        mcp.obj = this;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMCharacterData::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replaceData")) {
        mcp.ci = &c_DOMCharacterData::ci_replacedata;
        mcp.obj = this;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMCharacterData::ci___set;
        mcp.obj = this;
        return true;
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deleteData")) {
        mcp.ci = &c_DOMCharacterData::ci_deletedata;
        mcp.obj = this;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertData")) {
        mcp.ci = &c_DOMCharacterData::ci_insertdata;
        mcp.obj = this;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMCharacterData::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_get_call_info(mcp, hash);
}
c_DOMCharacterData *c_DOMCharacterData::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMCharacterData::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMCharacterData::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMCharacterData::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMCharacterData::ci___construct;
  mcp.obj = this;
}
void c_DOMCharacterData::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMCharacterData = {
  c_DOMCharacterData::os_getInit,
  c_DOMCharacterData::os_get,
  c_DOMCharacterData::os_lval,
  c_DOMCharacterData::os_invoke,
  c_DOMCharacterData::os_constant,
  c_DOMCharacterData::os_get_call_info
};
Object co_DOMEntityReference(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMEntityReference)())->dynCreate(params, init));
}
Object coo_DOMEntityReference() {
  Object r(NEW(c_DOMEntityReference)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMEntityReference
Variant c_DOMEntityReference::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMEntityReference
Variant c_DOMEntityReference::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMEntityReference
Variant &c_DOMEntityReference::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMEntityReference
void c_DOMEntityReference::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMEntityReference
void c_DOMEntityReference::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMEntityReference
Variant * c_DOMEntityReference::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMEntityReference
Variant * c_DOMEntityReference::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMEntityReference
Variant * c_DOMEntityReference::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMEntityReference
Variant c_DOMEntityReference::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMEntityReference
IMPLEMENT_CLASS(DOMEntityReference)
void c_DOMEntityReference::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMEntityReference::cloneImpl() {
  c_DOMEntityReference *obj = NEW(c_DOMEntityReference)();
  cloneSet(obj);
  return obj;
}
void c_DOMEntityReference::cloneSet(c_DOMEntityReference *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMEntityReference::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMEntityReference::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMEntityReference::ci___destruct((void*)&c_DOMEntityReference::i___destruct, (void*)&c_DOMEntityReference::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMEntityReference::ci___construct((void*)&c_DOMEntityReference::i___construct, (void*)&c_DOMEntityReference::ifa___construct, 1, 0, 0x0000000000000000LL);
Variant c_DOMEntityReference::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMEntityReference *self = NULL;
  p_DOMEntityReference pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntityReference*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMEntityReference::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMEntityReference *self = NULL;
  p_DOMEntityReference pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntityReference*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___construct(arg0), null);
  }
}
Variant c_DOMEntityReference::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMEntityReference *self = NULL;
  p_DOMEntityReference pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntityReference*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMEntityReference::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMEntityReference *self = NULL;
  p_DOMEntityReference pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntityReference*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  return (self->t___construct(a0), null);
}
bool c_DOMEntityReference::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMEntityReference::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMEntityReference::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMEntityReference::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMEntityReference::ci___destruct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMEntityReference::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_get_call_info(mcp, hash);
}
c_DOMEntityReference *c_DOMEntityReference::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_DOMEntityReference::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_DOMEntityReference::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_DOMEntityReference::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMEntityReference::ci___construct;
  mcp.obj = this;
}
void c_DOMEntityReference::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
struct ObjectStaticCallbacks cw_DOMEntityReference = {
  c_DOMEntityReference::os_getInit,
  c_DOMEntityReference::os_get,
  c_DOMEntityReference::os_lval,
  c_DOMEntityReference::os_invoke,
  c_DOMEntityReference::os_constant,
  c_DOMEntityReference::os_get_call_info
};
Object co_SimpleXMLElementIterator(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SimpleXMLElementIterator)())->dynCreate(params, init));
}
Object coo_SimpleXMLElementIterator() {
  Object r(NEW(c_SimpleXMLElementIterator)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SimpleXMLElementIterator
Variant c_SimpleXMLElementIterator::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SimpleXMLElementIterator
Variant c_SimpleXMLElementIterator::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SimpleXMLElementIterator
Variant &c_SimpleXMLElementIterator::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SimpleXMLElementIterator
void c_SimpleXMLElementIterator::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SimpleXMLElementIterator
void c_SimpleXMLElementIterator::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SimpleXMLElementIterator
Variant * c_SimpleXMLElementIterator::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SimpleXMLElementIterator
Variant * c_SimpleXMLElementIterator::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SimpleXMLElementIterator
Variant * c_SimpleXMLElementIterator::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SimpleXMLElementIterator
Variant c_SimpleXMLElementIterator::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SimpleXMLElementIterator
IMPLEMENT_CLASS(SimpleXMLElementIterator)
void c_SimpleXMLElementIterator::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SimpleXMLElementIterator::cloneImpl() {
  c_SimpleXMLElementIterator *obj = NEW(c_SimpleXMLElementIterator)();
  cloneSet(obj);
  return obj;
}
void c_SimpleXMLElementIterator::cloneSet(c_SimpleXMLElementIterator *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SimpleXMLElementIterator::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SimpleXMLElementIterator::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SimpleXMLElementIterator::ci_next((void*)&c_SimpleXMLElementIterator::i_next, (void*)&c_SimpleXMLElementIterator::ifa_next, 0, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElementIterator::ci_key((void*)&c_SimpleXMLElementIterator::i_key, (void*)&c_SimpleXMLElementIterator::ifa_key, 0, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElementIterator::ci_valid((void*)&c_SimpleXMLElementIterator::i_valid, (void*)&c_SimpleXMLElementIterator::ifa_valid, 0, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElementIterator::ci___destruct((void*)&c_SimpleXMLElementIterator::i___destruct, (void*)&c_SimpleXMLElementIterator::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElementIterator::ci___construct((void*)&c_SimpleXMLElementIterator::i___construct, (void*)&c_SimpleXMLElementIterator::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElementIterator::ci_current((void*)&c_SimpleXMLElementIterator::i_current, (void*)&c_SimpleXMLElementIterator::ifa_current, 0, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElementIterator::ci_rewind((void*)&c_SimpleXMLElementIterator::i_rewind, (void*)&c_SimpleXMLElementIterator::ifa_rewind, 0, 0, 0x0000000000000000LL);
Variant c_SimpleXMLElementIterator::i_next(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("next", 0, 1);
  return (self->t_next());
}
Variant c_SimpleXMLElementIterator::i_key(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("key", 0, 1);
  return (self->t_key());
}
Variant c_SimpleXMLElementIterator::i_valid(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("valid", 0, 1);
  return (self->t_valid());
}
Variant c_SimpleXMLElementIterator::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SimpleXMLElementIterator::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_SimpleXMLElementIterator::i_current(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("current", 0, 1);
  return (self->t_current());
}
Variant c_SimpleXMLElementIterator::i_rewind(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
  return (self->t_rewind());
}
Variant c_SimpleXMLElementIterator::ifa_next(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("next", 0, 1);
  return (self->t_next());
}
Variant c_SimpleXMLElementIterator::ifa_key(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("key", 0, 1);
  return (self->t_key());
}
Variant c_SimpleXMLElementIterator::ifa_valid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("valid", 0, 1);
  return (self->t_valid());
}
Variant c_SimpleXMLElementIterator::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SimpleXMLElementIterator::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_SimpleXMLElementIterator::ifa_current(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("current", 0, 1);
  return (self->t_current());
}
Variant c_SimpleXMLElementIterator::ifa_rewind(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
  return (self->t_rewind());
}
bool c_SimpleXMLElementIterator::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci_key;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci___destruct;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci_valid;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci_next;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci_rewind;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci_current;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SimpleXMLElementIterator::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci_key;
        mcp.obj = this;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci_valid;
        mcp.obj = this;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci_next;
        mcp.obj = this;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci_rewind;
        mcp.obj = this;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci_current;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_SimpleXMLElementIterator *c_SimpleXMLElementIterator::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_SimpleXMLElementIterator::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_SimpleXMLElementIterator::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_SimpleXMLElementIterator::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SimpleXMLElementIterator::ci___construct;
  mcp.obj = this;
}
void c_SimpleXMLElementIterator::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_SimpleXMLElementIterator = {
  c_SimpleXMLElementIterator::os_getInit,
  c_SimpleXMLElementIterator::os_get,
  c_SimpleXMLElementIterator::os_lval,
  c_SimpleXMLElementIterator::os_invoke,
  c_SimpleXMLElementIterator::os_constant,
  c_SimpleXMLElementIterator::os_get_call_info
};
Object co_DateTimeZone(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DateTimeZone)())->dynCreate(params, init));
}
Object coo_DateTimeZone() {
  Object r(NEW(c_DateTimeZone)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DateTimeZone
Variant c_DateTimeZone::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DateTimeZone
Variant c_DateTimeZone::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DateTimeZone
Variant &c_DateTimeZone::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DateTimeZone
void c_DateTimeZone::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DateTimeZone
void c_DateTimeZone::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DateTimeZone
Variant * c_DateTimeZone::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DateTimeZone
Variant * c_DateTimeZone::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DateTimeZone
Variant * c_DateTimeZone::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DateTimeZone
Variant c_DateTimeZone::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 2:
      HASH_RETURN(0x5213CDB166554802LL, q_DateTimeZone_AFRICA, "AFRICA");
      break;
    case 10:
      HASH_RETURN(0x1F67AB7044E3CA2ALL, q_DateTimeZone_EUROPE, "EUROPE");
      break;
    case 12:
      HASH_RETURN(0x76F99914EEA96ECCLL, q_DateTimeZone_ARCTIC, "ARCTIC");
      break;
    case 13:
      HASH_RETURN(0x338F44565E0C038DLL, q_DateTimeZone_AMERICA, "AMERICA");
      break;
    case 15:
      HASH_RETURN(0x22CAA6990573E5EFLL, q_DateTimeZone_PACIFIC, "PACIFIC");
      break;
    case 19:
      HASH_RETURN(0x7879534F49C301F3LL, q_DateTimeZone_PER_COUNTRY, "PER_COUNTRY");
      break;
    case 20:
      HASH_RETURN(0x6FB9D84AA364CA14LL, q_DateTimeZone_UTC, "UTC");
      break;
    case 23:
      HASH_RETURN(0x5A01AACAA61E0FF7LL, q_DateTimeZone_ASIA, "ASIA");
      HASH_RETURN(0x3E74CAEDAD25E137LL, q_DateTimeZone_INDIAN, "INDIAN");
      break;
    case 24:
      HASH_RETURN(0x0C4F30470A9EEBF8LL, q_DateTimeZone_ALL, "ALL");
      break;
    case 25:
      HASH_RETURN(0x2BEDCED53E63BC79LL, q_DateTimeZone_ATLANTIC, "ATLANTIC");
      break;
    case 30:
      HASH_RETURN(0x3C168ED86522549ELL, q_DateTimeZone_AUSTRALIA, "AUSTRALIA");
      HASH_RETURN(0x690180C3BA732B5ELL, q_DateTimeZone_ALL_WITH_BC, "ALL_WITH_BC");
      break;
    case 31:
      HASH_RETURN(0x6B29DE65F46EAFDFLL, q_DateTimeZone_ANTARCTICA, "ANTARCTICA");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DateTimeZone
IMPLEMENT_CLASS(DateTimeZone)
void c_DateTimeZone::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DateTimeZone::cloneImpl() {
  c_DateTimeZone *obj = NEW(c_DateTimeZone)();
  cloneSet(obj);
  return obj;
}
void c_DateTimeZone::cloneSet(c_DateTimeZone *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DateTimeZone::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x6D7CD16BBA93D063LL, NAMSTR(s_sys_ss456c2f9d, "listIdentifiers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listidentifiers(o_getClassName()));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x63D3CF3884CE93F4LL, NAMSTR(s_sys_ss7b316c0c, "getTransitions")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettransitions());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x2D0CCAB16C3ED068LL, NAMSTR(s_sys_ss6c3ed068, "listAbbreviations")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss0b55bd0b, "getOffset")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getoffset(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DateTimeZone::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 0:
      HASH_GUARD_LITSTR(0x2D0CCAB16C3ED068LL, NAMSTR(s_sys_ss6c3ed068, "listAbbreviations")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listabbreviations(c));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x6D7CD16BBA93D063LL, NAMSTR(s_sys_ss456c2f9d, "listIdentifiers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listidentifiers(c));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DateTimeZone::ci_gettransitions((void*)&c_DateTimeZone::i_gettransitions, (void*)&c_DateTimeZone::ifa_gettransitions, 0, 0, 0x0000000000000000LL);
CallInfo c_DateTimeZone::ci_listidentifiers((void*)&c_DateTimeZone::i_listidentifiers, (void*)&c_DateTimeZone::ifa_listidentifiers, 0, 0, 0x0000000000000000LL);
CallInfo c_DateTimeZone::ci___destruct((void*)&c_DateTimeZone::i___destruct, (void*)&c_DateTimeZone::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DateTimeZone::ci_getoffset((void*)&c_DateTimeZone::i_getoffset, (void*)&c_DateTimeZone::ifa_getoffset, 1, 0, 0x0000000000000000LL);
CallInfo c_DateTimeZone::ci___construct((void*)&c_DateTimeZone::i___construct, (void*)&c_DateTimeZone::ifa___construct, 1, 0, 0x0000000000000000LL);
CallInfo c_DateTimeZone::ci_listabbreviations((void*)&c_DateTimeZone::i_listabbreviations, (void*)&c_DateTimeZone::ifa_listabbreviations, 0, 0, 0x0000000000000000LL);
CallInfo c_DateTimeZone::ci_getname((void*)&c_DateTimeZone::i_getname, (void*)&c_DateTimeZone::ifa_getname, 0, 0, 0x0000000000000000LL);
Variant c_DateTimeZone::i_gettransitions(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
  return (self->t_gettransitions());
}
Variant c_DateTimeZone::i_listidentifiers(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  const char *c;
  if (mcp.rootObj.is(KindOfObject)) {
    c = mcp.rootObj.getObjectData()->o_getClassName();
  } else {
    c = mcp.rootObj.getCStr();
  }
  if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
  return (c_DateTimeZone::ti_listidentifiers(c));
}
Variant c_DateTimeZone::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DateTimeZone::i_getoffset(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getoffset(arg0));
  }
}
Variant c_DateTimeZone::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___construct(arg0), null);
  }
}
Variant c_DateTimeZone::i_listabbreviations(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  const char *c;
  if (mcp.rootObj.is(KindOfObject)) {
    c = mcp.rootObj.getObjectData()->o_getClassName();
  } else {
    c = mcp.rootObj.getCStr();
  }
  if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
  return (c_DateTimeZone::ti_listabbreviations(c));
}
Variant c_DateTimeZone::i_getname(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getname", 0, 1);
  return (self->t_getname());
}
Variant c_DateTimeZone::ifa_gettransitions(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
  return (self->t_gettransitions());
}
Variant c_DateTimeZone::ifa_listidentifiers(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  const char *c;
  if (mcp.rootObj.is(KindOfObject)) {
    c = mcp.rootObj.getObjectData()->o_getClassName();
  } else {
    c = mcp.rootObj.getCStr();
  }
  if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
  return (c_DateTimeZone::ti_listidentifiers(c));
}
Variant c_DateTimeZone::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DateTimeZone::ifa_getoffset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
  return (self->t_getoffset(a0));
}
Variant c_DateTimeZone::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  return (self->t___construct(a0), null);
}
Variant c_DateTimeZone::ifa_listabbreviations(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  const char *c;
  if (mcp.rootObj.is(KindOfObject)) {
    c = mcp.rootObj.getObjectData()->o_getClassName();
  } else {
    c = mcp.rootObj.getCStr();
  }
  if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
  return (c_DateTimeZone::ti_listabbreviations(c));
}
Variant c_DateTimeZone::ifa_getname(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getname", 0, 1);
  return (self->t_getname());
}
bool c_DateTimeZone::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x6D7CD16BBA93D063LL, NAMSTR(s_sys_ss456c2f9d, "listIdentifiers")) {
        mcp.ci = &c_DateTimeZone::ci_listidentifiers;
        return true;
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DateTimeZone::ci___destruct;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x63D3CF3884CE93F4LL, NAMSTR(s_sys_ss7b316c0c, "getTransitions")) {
        mcp.ci = &c_DateTimeZone::ci_gettransitions;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        mcp.ci = &c_DateTimeZone::ci_getname;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x2D0CCAB16C3ED068LL, NAMSTR(s_sys_ss6c3ed068, "listAbbreviations")) {
        mcp.ci = &c_DateTimeZone::ci_listabbreviations;
        return true;
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss0b55bd0b, "getOffset")) {
        mcp.ci = &c_DateTimeZone::ci_getoffset;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DateTimeZone::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DateTimeZone::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x6D7CD16BBA93D063LL, NAMSTR(s_sys_ss456c2f9d, "listIdentifiers")) {
        mcp.ci = &c_DateTimeZone::ci_listidentifiers;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DateTimeZone::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x63D3CF3884CE93F4LL, NAMSTR(s_sys_ss7b316c0c, "getTransitions")) {
        mcp.ci = &c_DateTimeZone::ci_gettransitions;
        mcp.obj = this;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        mcp.ci = &c_DateTimeZone::ci_getname;
        mcp.obj = this;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x2D0CCAB16C3ED068LL, NAMSTR(s_sys_ss6c3ed068, "listAbbreviations")) {
        mcp.ci = &c_DateTimeZone::ci_listabbreviations;
        mcp.obj = this;
        return true;
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss0b55bd0b, "getOffset")) {
        mcp.ci = &c_DateTimeZone::ci_getoffset;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DateTimeZone::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_DateTimeZone *c_DateTimeZone::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_DateTimeZone::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_DateTimeZone::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_DateTimeZone::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DateTimeZone::ci___construct;
  mcp.obj = this;
}
void c_DateTimeZone::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
struct ObjectStaticCallbacks cw_DateTimeZone = {
  c_DateTimeZone::os_getInit,
  c_DateTimeZone::os_get,
  c_DateTimeZone::os_lval,
  c_DateTimeZone::os_invoke,
  c_DateTimeZone::os_constant,
  c_DateTimeZone::os_get_call_info
};
Object co_DOMNodeIterator(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMNodeIterator)())->dynCreate(params, init));
}
Object coo_DOMNodeIterator() {
  Object r(NEW(c_DOMNodeIterator)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNodeIterator
Variant c_DOMNodeIterator::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNodeIterator
Variant c_DOMNodeIterator::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNodeIterator
Variant &c_DOMNodeIterator::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNodeIterator
void c_DOMNodeIterator::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNodeIterator
void c_DOMNodeIterator::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMNodeIterator
Variant * c_DOMNodeIterator::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNodeIterator
Variant * c_DOMNodeIterator::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNodeIterator
Variant * c_DOMNodeIterator::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNodeIterator
Variant c_DOMNodeIterator::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNodeIterator
IMPLEMENT_CLASS(DOMNodeIterator)
void c_DOMNodeIterator::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMNodeIterator::cloneImpl() {
  c_DOMNodeIterator *obj = NEW(c_DOMNodeIterator)();
  cloneSet(obj);
  return obj;
}
void c_DOMNodeIterator::cloneSet(c_DOMNodeIterator *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DOMNodeIterator::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMNodeIterator::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMNodeIterator::ci_next((void*)&c_DOMNodeIterator::i_next, (void*)&c_DOMNodeIterator::ifa_next, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNodeIterator::ci_key((void*)&c_DOMNodeIterator::i_key, (void*)&c_DOMNodeIterator::ifa_key, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNodeIterator::ci_valid((void*)&c_DOMNodeIterator::i_valid, (void*)&c_DOMNodeIterator::ifa_valid, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNodeIterator::ci___destruct((void*)&c_DOMNodeIterator::i___destruct, (void*)&c_DOMNodeIterator::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNodeIterator::ci___construct((void*)&c_DOMNodeIterator::i___construct, (void*)&c_DOMNodeIterator::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNodeIterator::ci_current((void*)&c_DOMNodeIterator::i_current, (void*)&c_DOMNodeIterator::ifa_current, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNodeIterator::ci_rewind((void*)&c_DOMNodeIterator::i_rewind, (void*)&c_DOMNodeIterator::ifa_rewind, 0, 0, 0x0000000000000000LL);
Variant c_DOMNodeIterator::i_next(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("next", 0, 1);
  return (self->t_next());
}
Variant c_DOMNodeIterator::i_key(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("key", 0, 1);
  return (self->t_key());
}
Variant c_DOMNodeIterator::i_valid(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("valid", 0, 1);
  return (self->t_valid());
}
Variant c_DOMNodeIterator::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNodeIterator::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNodeIterator::i_current(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("current", 0, 1);
  return (self->t_current());
}
Variant c_DOMNodeIterator::i_rewind(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
  return (self->t_rewind());
}
Variant c_DOMNodeIterator::ifa_next(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("next", 0, 1);
  return (self->t_next());
}
Variant c_DOMNodeIterator::ifa_key(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("key", 0, 1);
  return (self->t_key());
}
Variant c_DOMNodeIterator::ifa_valid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("valid", 0, 1);
  return (self->t_valid());
}
Variant c_DOMNodeIterator::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNodeIterator::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNodeIterator::ifa_current(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("current", 0, 1);
  return (self->t_current());
}
Variant c_DOMNodeIterator::ifa_rewind(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
  return (self->t_rewind());
}
bool c_DOMNodeIterator::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        mcp.ci = &c_DOMNodeIterator::ci_key;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMNodeIterator::ci___destruct;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        mcp.ci = &c_DOMNodeIterator::ci_valid;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        mcp.ci = &c_DOMNodeIterator::ci_next;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        mcp.ci = &c_DOMNodeIterator::ci_rewind;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        mcp.ci = &c_DOMNodeIterator::ci_current;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMNodeIterator::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DOMNodeIterator::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        mcp.ci = &c_DOMNodeIterator::ci_key;
        mcp.obj = this;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMNodeIterator::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        mcp.ci = &c_DOMNodeIterator::ci_valid;
        mcp.obj = this;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        mcp.ci = &c_DOMNodeIterator::ci_next;
        mcp.obj = this;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        mcp.ci = &c_DOMNodeIterator::ci_rewind;
        mcp.obj = this;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        mcp.ci = &c_DOMNodeIterator::ci_current;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMNodeIterator::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_DOMNodeIterator *c_DOMNodeIterator::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMNodeIterator::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMNodeIterator::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMNodeIterator::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMNodeIterator::ci___construct;
  mcp.obj = this;
}
void c_DOMNodeIterator::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMNodeIterator = {
  c_DOMNodeIterator::os_getInit,
  c_DOMNodeIterator::os_get,
  c_DOMNodeIterator::os_lval,
  c_DOMNodeIterator::os_invoke,
  c_DOMNodeIterator::os_constant,
  c_DOMNodeIterator::os_get_call_info
};
Object co_DOMImplementation(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMImplementation)())->dynCreate(params, init));
}
Object coo_DOMImplementation() {
  Object r(NEW(c_DOMImplementation)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMImplementation
Variant c_DOMImplementation::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMImplementation
Variant c_DOMImplementation::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMImplementation
Variant &c_DOMImplementation::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMImplementation
void c_DOMImplementation::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMImplementation
void c_DOMImplementation::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMImplementation
Variant * c_DOMImplementation::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMImplementation
Variant * c_DOMImplementation::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMImplementation
Variant * c_DOMImplementation::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMImplementation
Variant c_DOMImplementation::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMImplementation
IMPLEMENT_CLASS(DOMImplementation)
void c_DOMImplementation::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMImplementation::cloneImpl() {
  c_DOMImplementation *obj = NEW(c_DOMImplementation)();
  cloneSet(obj);
  return obj;
}
void c_DOMImplementation::cloneSet(c_DOMImplementation *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DOMImplementation::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x3CB56A796F3DBAC3LL, NAMSTR(s_sys_ss6f3dbac3, "createDocumentType")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_createdocumenttype());
        else if (count == 1) return (t_createdocumenttype(a0));
        else if (count == 2) return (t_createdocumenttype(a0, a1));
        else return (t_createdocumenttype(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x280878EAC306A6A3LL, NAMSTR(s_sys_ss3cf9595d, "hasFeature")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasfeature(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x30855E95B37D1B4ELL, NAMSTR(s_sys_ss4c82e4b2, "createDocument")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_createdocument());
        else if (count == 1) return (t_createdocument(a0));
        else if (count == 2) return (t_createdocument(a0, a1));
        else return (t_createdocument(a0, a1, a2));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMImplementation::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMImplementation::ci_createdocument((void*)&c_DOMImplementation::i_createdocument, (void*)&c_DOMImplementation::ifa_createdocument, 3, 0, 0x0000000000000000LL);
CallInfo c_DOMImplementation::ci_createdocumenttype((void*)&c_DOMImplementation::i_createdocumenttype, (void*)&c_DOMImplementation::ifa_createdocumenttype, 3, 0, 0x0000000000000000LL);
CallInfo c_DOMImplementation::ci___destruct((void*)&c_DOMImplementation::i___destruct, (void*)&c_DOMImplementation::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMImplementation::ci___construct((void*)&c_DOMImplementation::i___construct, (void*)&c_DOMImplementation::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMImplementation::ci_hasfeature((void*)&c_DOMImplementation::i_hasfeature, (void*)&c_DOMImplementation::ifa_hasfeature, 2, 0, 0x0000000000000000LL);
Variant c_DOMImplementation::i_createdocument(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_createdocument());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_createdocument(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_createdocument(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_createdocument(arg0, arg1, arg2));
  }
}
Variant c_DOMImplementation::i_createdocumenttype(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_createdocumenttype());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_createdocumenttype(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_createdocumenttype(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_createdocumenttype(arg0, arg1, arg2));
  }
}
Variant c_DOMImplementation::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMImplementation::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMImplementation::i_hasfeature(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_hasfeature(arg0, arg1));
  }
}
Variant c_DOMImplementation::ifa_createdocument(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
  if (count <= 0) return (self->t_createdocument());
  if (count == 1) return (self->t_createdocument(a0));
  if (count == 2) return (self->t_createdocument(a0, a1));
  return (self->t_createdocument(a0, a1, a2));
}
Variant c_DOMImplementation::ifa_createdocumenttype(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
  if (count <= 0) return (self->t_createdocumenttype());
  if (count == 1) return (self->t_createdocumenttype(a0));
  if (count == 2) return (self->t_createdocumenttype(a0, a1));
  return (self->t_createdocumenttype(a0, a1, a2));
}
Variant c_DOMImplementation::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMImplementation::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMImplementation::ifa_hasfeature(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
  return (self->t_hasfeature(a0, a1));
}
bool c_DOMImplementation::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x3CB56A796F3DBAC3LL, NAMSTR(s_sys_ss6f3dbac3, "createDocumentType")) {
        mcp.ci = &c_DOMImplementation::ci_createdocumenttype;
        return true;
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMImplementation::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x280878EAC306A6A3LL, NAMSTR(s_sys_ss3cf9595d, "hasFeature")) {
        mcp.ci = &c_DOMImplementation::ci_hasfeature;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x30855E95B37D1B4ELL, NAMSTR(s_sys_ss4c82e4b2, "createDocument")) {
        mcp.ci = &c_DOMImplementation::ci_createdocument;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMImplementation::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DOMImplementation::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x3CB56A796F3DBAC3LL, NAMSTR(s_sys_ss6f3dbac3, "createDocumentType")) {
        mcp.ci = &c_DOMImplementation::ci_createdocumenttype;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMImplementation::ci___destruct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x280878EAC306A6A3LL, NAMSTR(s_sys_ss3cf9595d, "hasFeature")) {
        mcp.ci = &c_DOMImplementation::ci_hasfeature;
        mcp.obj = this;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x30855E95B37D1B4ELL, NAMSTR(s_sys_ss4c82e4b2, "createDocument")) {
        mcp.ci = &c_DOMImplementation::ci_createdocument;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMImplementation::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_DOMImplementation *c_DOMImplementation::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMImplementation::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMImplementation::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMImplementation::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMImplementation::ci___construct;
  mcp.obj = this;
}
void c_DOMImplementation::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMImplementation = {
  c_DOMImplementation::os_getInit,
  c_DOMImplementation::os_get,
  c_DOMImplementation::os_lval,
  c_DOMImplementation::os_invoke,
  c_DOMImplementation::os_constant,
  c_DOMImplementation::os_get_call_info
};
Object co_SoapHeader(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SoapHeader)())->dynCreate(params, init));
}
Object coo_SoapHeader() {
  Object r(NEW(c_SoapHeader)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapHeader
Variant c_SoapHeader::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapHeader
Variant c_SoapHeader::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapHeader
Variant &c_SoapHeader::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapHeader
void c_SoapHeader::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapHeader
void c_SoapHeader::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SoapHeader
Variant * c_SoapHeader::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapHeader
Variant * c_SoapHeader::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapHeader
Variant * c_SoapHeader::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapHeader
Variant c_SoapHeader::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapHeader
IMPLEMENT_CLASS(SoapHeader)
void c_SoapHeader::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SoapHeader::cloneImpl() {
  c_SoapHeader *obj = NEW(c_SoapHeader)();
  cloneSet(obj);
  return obj;
}
void c_SoapHeader::cloneSet(c_SoapHeader *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SoapHeader::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SoapHeader::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SoapHeader::ci___destruct((void*)&c_SoapHeader::i___destruct, (void*)&c_SoapHeader::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_SoapHeader::ci___construct((void*)&c_SoapHeader::i___construct, (void*)&c_SoapHeader::ifa___construct, 5, 0, 0x0000000000000000LL);
Variant c_SoapHeader::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapHeader *self = NULL;
  p_SoapHeader pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapHeader*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapHeader::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapHeader *self = NULL;
  p_SoapHeader pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapHeader*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t___construct(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t___construct(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t___construct(arg0, arg1, arg2, arg3), null);
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant c_SoapHeader::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapHeader *self = NULL;
  p_SoapHeader pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapHeader*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapHeader::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapHeader *self = NULL;
  p_SoapHeader pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapHeader*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
  if (count <= 2) return (self->t___construct(a0, a1), null);
  if (count == 3) return (self->t___construct(a0, a1, a2), null);
  if (count == 4) return (self->t___construct(a0, a1, a2, a3), null);
  return (self->t___construct(a0, a1, a2, a3, a4), null);
}
bool c_SoapHeader::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SoapHeader::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SoapHeader::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SoapHeader::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SoapHeader::ci___destruct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SoapHeader::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_SoapHeader *c_SoapHeader::create(String a0, String a1, Variant a2, bool a3, Variant a4) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4);
  return this;
}
ObjectData *c_SoapHeader::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 2 || count > 5) throw_wrong_arguments("__construct", count, 2, 5, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      if (count <= 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1, arg2, arg3, arg4));
    } while (false);
  }
  return this;
}
void c_SoapHeader::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) throw_wrong_arguments("__construct", count, 2, 5, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2, arg3, arg4));
  } while (false);
}
void c_SoapHeader::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SoapHeader::ci___construct;
  mcp.obj = this;
}
void c_SoapHeader::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) throw_wrong_arguments("__construct", count, 2, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else (t___construct(a0, a1, a2, a3, a4), null);
}
struct ObjectStaticCallbacks cw_SoapHeader = {
  c_SoapHeader::os_getInit,
  c_SoapHeader::os_get,
  c_SoapHeader::os_lval,
  c_SoapHeader::os_invoke,
  c_SoapHeader::os_constant,
  c_SoapHeader::os_get_call_info
};
Object co_DOMNotation(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMNotation)())->dynCreate(params, init));
}
Object coo_DOMNotation() {
  Object r(NEW(c_DOMNotation)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNotation
Variant c_DOMNotation::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNotation
Variant c_DOMNotation::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNotation
Variant &c_DOMNotation::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNotation
void c_DOMNotation::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNotation
void c_DOMNotation::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMNotation
Variant * c_DOMNotation::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNotation
Variant * c_DOMNotation::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNotation
Variant * c_DOMNotation::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNotation
Variant c_DOMNotation::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNotation
IMPLEMENT_CLASS(DOMNotation)
void c_DOMNotation::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMNotation::cloneImpl() {
  c_DOMNotation *obj = NEW(c_DOMNotation)();
  cloneSet(obj);
  return obj;
}
void c_DOMNotation::cloneSet(c_DOMNotation *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMNotation::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMNotation::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMNotation::ci___destruct((void*)&c_DOMNotation::i___destruct, (void*)&c_DOMNotation::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNotation::ci___set((void*)&c_DOMNotation::i___set, (void*)&c_DOMNotation::ifa___set, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMNotation::ci___construct((void*)&c_DOMNotation::i___construct, (void*)&c_DOMNotation::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNotation::ci___get((void*)&c_DOMNotation::i___get, (void*)&c_DOMNotation::ifa___get, 1, 0, 0x0000000000000000LL);
Variant c_DOMNotation::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNotation *self = NULL;
  p_DOMNotation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNotation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNotation::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNotation *self = NULL;
  p_DOMNotation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNotation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMNotation::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNotation *self = NULL;
  p_DOMNotation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNotation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNotation::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNotation *self = NULL;
  p_DOMNotation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNotation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMNotation::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNotation *self = NULL;
  p_DOMNotation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNotation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNotation::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNotation *self = NULL;
  p_DOMNotation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNotation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMNotation::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNotation *self = NULL;
  p_DOMNotation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNotation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNotation::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNotation *self = NULL;
  p_DOMNotation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNotation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
bool c_DOMNotation::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMNotation::ci___destruct;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMNotation::ci___set;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMNotation::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMNotation::ci___get;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMNotation::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMNotation::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMNotation::ci___set;
        mcp.obj = this;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMNotation::ci___construct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMNotation::ci___get;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_get_call_info(mcp, hash);
}
c_DOMNotation *c_DOMNotation::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMNotation::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMNotation::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMNotation::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMNotation::ci___construct;
  mcp.obj = this;
}
void c_DOMNotation::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMNotation = {
  c_DOMNotation::os_getInit,
  c_DOMNotation::os_get,
  c_DOMNotation::os_lval,
  c_DOMNotation::os_invoke,
  c_DOMNotation::os_constant,
  c_DOMNotation::os_get_call_info
};
Object co_DebuggerProxy(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DebuggerProxy)())->dynCreate(params, init));
}
Object coo_DebuggerProxy() {
  Object r(NEW(c_DebuggerProxy)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DebuggerProxy
Variant c_DebuggerProxy::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DebuggerProxy
Variant c_DebuggerProxy::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DebuggerProxy
Variant &c_DebuggerProxy::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DebuggerProxy
void c_DebuggerProxy::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DebuggerProxy
void c_DebuggerProxy::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DebuggerProxy
Variant * c_DebuggerProxy::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DebuggerProxy
Variant * c_DebuggerProxy::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DebuggerProxy
Variant * c_DebuggerProxy::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DebuggerProxy
Variant c_DebuggerProxy::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DebuggerProxy
IMPLEMENT_CLASS(DebuggerProxy)
void c_DebuggerProxy::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DebuggerProxy::cloneImpl() {
  c_DebuggerProxy *obj = NEW(c_DebuggerProxy)();
  cloneSet(obj);
  return obj;
}
void c_DebuggerProxy::cloneSet(c_DebuggerProxy *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DebuggerProxy::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 0:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss7fd1c778, "send")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_send(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x7B58587A529D270CLL, NAMSTR(s_sys_ss529d270c, "isLocal")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_islocal());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DebuggerProxy::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DebuggerProxy::ci_islocal((void*)&c_DebuggerProxy::i_islocal, (void*)&c_DebuggerProxy::ifa_islocal, 0, 0, 0x0000000000000000LL);
CallInfo c_DebuggerProxy::ci___destruct((void*)&c_DebuggerProxy::i___destruct, (void*)&c_DebuggerProxy::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DebuggerProxy::ci___construct((void*)&c_DebuggerProxy::i___construct, (void*)&c_DebuggerProxy::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_DebuggerProxy::ci_send((void*)&c_DebuggerProxy::i_send, (void*)&c_DebuggerProxy::ifa_send, 1, 0, 0x0000000000000000LL);
Variant c_DebuggerProxy::i_islocal(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerProxy *self = NULL;
  p_DebuggerProxy pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerProxy*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
  return (self->t_islocal());
}
Variant c_DebuggerProxy::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerProxy *self = NULL;
  p_DebuggerProxy pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerProxy*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DebuggerProxy::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerProxy *self = NULL;
  p_DebuggerProxy pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerProxy*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DebuggerProxy::i_send(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerProxy *self = NULL;
  p_DebuggerProxy pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerProxy*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_send(arg0));
  }
}
Variant c_DebuggerProxy::ifa_islocal(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerProxy *self = NULL;
  p_DebuggerProxy pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerProxy*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
  return (self->t_islocal());
}
Variant c_DebuggerProxy::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerProxy *self = NULL;
  p_DebuggerProxy pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerProxy*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DebuggerProxy::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerProxy *self = NULL;
  p_DebuggerProxy pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerProxy*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DebuggerProxy::ifa_send(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerProxy *self = NULL;
  p_DebuggerProxy pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerProxy*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
  return (self->t_send(a0));
}
bool c_DebuggerProxy::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 0:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss7fd1c778, "send")) {
        mcp.ci = &c_DebuggerProxy::ci_send;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DebuggerProxy::ci___destruct;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x7B58587A529D270CLL, NAMSTR(s_sys_ss529d270c, "isLocal")) {
        mcp.ci = &c_DebuggerProxy::ci_islocal;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DebuggerProxy::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DebuggerProxy::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 0:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss7fd1c778, "send")) {
        mcp.ci = &c_DebuggerProxy::ci_send;
        mcp.obj = this;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DebuggerProxy::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x7B58587A529D270CLL, NAMSTR(s_sys_ss529d270c, "isLocal")) {
        mcp.ci = &c_DebuggerProxy::ci_islocal;
        mcp.obj = this;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DebuggerProxy::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_DebuggerProxy *c_DebuggerProxy::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DebuggerProxy::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DebuggerProxy::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DebuggerProxy::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DebuggerProxy::ci___construct;
  mcp.obj = this;
}
void c_DebuggerProxy::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DebuggerProxy = {
  c_DebuggerProxy::os_getInit,
  c_DebuggerProxy::os_get,
  c_DebuggerProxy::os_lval,
  c_DebuggerProxy::os_invoke,
  c_DebuggerProxy::os_constant,
  c_DebuggerProxy::os_get_call_info
};
Object co_DOMComment(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMComment)())->dynCreate(params, init));
}
Object coo_DOMComment() {
  Object r(NEW(c_DOMComment)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMComment
Variant c_DOMComment::os_getInit(CStrRef s) {
  return c_DOMCharacterData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMComment
Variant c_DOMComment::os_get(CStrRef s) {
  return c_DOMCharacterData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMComment
Variant &c_DOMComment::os_lval(CStrRef s) {
  return c_DOMCharacterData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMComment
void c_DOMComment::o_getArray(Array &props) const {
  c_DOMCharacterData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMComment
void c_DOMComment::o_setArray(CArrRef props) {
  c_DOMCharacterData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMComment
Variant * c_DOMComment::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMComment
Variant * c_DOMComment::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMCharacterData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMComment
Variant * c_DOMComment::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMComment
Variant c_DOMComment::os_constant(const char *s) {
  return c_DOMCharacterData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMComment
IMPLEMENT_CLASS(DOMComment)
void c_DOMComment::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMComment::cloneImpl() {
  c_DOMComment *obj = NEW(c_DOMComment)();
  cloneSet(obj);
  return obj;
}
void c_DOMComment::cloneSet(c_DOMComment *clone) {
  c_DOMCharacterData::cloneSet(clone);
}
Variant c_DOMComment::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_DOMCharacterData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMComment::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMCharacterData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMComment::ci___destruct((void*)&c_DOMComment::i___destruct, (void*)&c_DOMComment::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMComment::ci___construct((void*)&c_DOMComment::i___construct, (void*)&c_DOMComment::ifa___construct, 1, 0, 0x0000000000000000LL);
Variant c_DOMComment::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMComment *self = NULL;
  p_DOMComment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMComment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMComment::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMComment *self = NULL;
  p_DOMComment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMComment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t___construct(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___construct(arg0), null);
  }
}
Variant c_DOMComment::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMComment *self = NULL;
  p_DOMComment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMComment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMComment::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMComment *self = NULL;
  p_DOMComment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMComment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
  if (count <= 0) return (self->t___construct(), null);
  return (self->t___construct(a0), null);
}
bool c_DOMComment::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMComment::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMComment::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMCharacterData::os_get_call_info(mcp, hash);
}
bool c_DOMComment::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMComment::ci___destruct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMComment::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMCharacterData::o_get_call_info(mcp, hash);
}
c_DOMComment *c_DOMComment::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_DOMComment::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 1) throw_toomany_arguments("__construct", 1, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    } while (false);
  }
  return this;
}
void c_DOMComment::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  } while (false);
}
void c_DOMComment::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMComment::ci___construct;
  mcp.obj = this;
}
void c_DOMComment::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else (t___construct(a0), null);
}
struct ObjectStaticCallbacks cw_DOMComment = {
  c_DOMComment::os_getInit,
  c_DOMComment::os_get,
  c_DOMComment::os_lval,
  c_DOMComment::os_invoke,
  c_DOMComment::os_constant,
  c_DOMComment::os_get_call_info
};
Object co_SQLite3(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SQLite3)())->dynCreate(params, init));
}
Object coo_SQLite3() {
  Object r(NEW(c_SQLite3)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SQLite3
Variant c_SQLite3::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SQLite3
Variant c_SQLite3::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SQLite3
Variant &c_SQLite3::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SQLite3
void c_SQLite3::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SQLite3
void c_SQLite3::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SQLite3
Variant * c_SQLite3::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SQLite3
Variant * c_SQLite3::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SQLite3
Variant * c_SQLite3::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SQLite3
Variant c_SQLite3::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SQLite3
IMPLEMENT_CLASS(SQLite3)
void c_SQLite3::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SQLite3::cloneImpl() {
  c_SQLite3 *obj = NEW(c_SQLite3)();
  cloneSet(obj);
  return obj;
}
void c_SQLite3::cloneSet(c_SQLite3 *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SQLite3::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x6081F282094466C2LL, NAMSTR(s_sys_ss094466c2, "lasterrormsg")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lasterrormsg());
      }
      HASH_GUARD_LITSTR(0x65BD6700742BF3C2LL, NAMSTR(s_sys_ss742bf3c2, "openblob")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_openblob(a0, a1, a2));
        else return (t_openblob(a0, a1, a2, a3));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x3AA4CCEC6BD68143LL, NAMSTR(s_sys_ss6bd68143, "createaggregate")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_createaggregate(a0, a1, a2));
        else return (t_createaggregate(a0, a1, a2, a3));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x21F68C010C124BC4LL, NAMSTR(s_sys_ss0c124bc4, "open")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_open(a0), null);
        else if (count == 2) return (t_open(a0, a1), null);
        else return (t_open(a0, a1, a2), null);
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x632B468FC2FCAB0ALL, NAMSTR(s_sys_ss3d0354f6, "lasterrorcode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lasterrorcode());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss4f78df74, "exec")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_exec(a0));
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x7CECF508291057CDLL, NAMSTR(s_sys_ss291057cd, "createfunction")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_createfunction(a0, a1));
        else return (t_createfunction(a0, a1, a2));
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x64D2BDB189B02819LL, NAMSTR(s_sys_ss764fd7e7, "changes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_changes());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x1B3CDE890A487664LL, NAMSTR(s_sys_ss0a487664, "loadextension")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadextension(a0));
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x5024F08DB0FDCBE6LL, NAMSTR(s_sys_ss4f02341a, "lastinsertrowid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lastinsertrowid());
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x5AE41239FF63D86ALL, NAMSTR(s_sys_ss009c2796, "version")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_version());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x156B1FAE4132ABEELL, NAMSTR(s_sys_ss4132abee, "querysingle")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_querysingle(a0));
        else return (t_querysingle(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss4ba591af, "prepare")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_prepare(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x607C4C73BB251635LL, NAMSTR(s_sys_ss44dae9cb, "escapestring")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_escapestring(a0));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_query(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SQLite3::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SQLite3::ci_exec((void*)&c_SQLite3::i_exec, (void*)&c_SQLite3::ifa_exec, 1, 0, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_version((void*)&c_SQLite3::i_version, (void*)&c_SQLite3::ifa_version, 0, 0, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_loadextension((void*)&c_SQLite3::i_loadextension, (void*)&c_SQLite3::ifa_loadextension, 1, 0, 0x0000000000000000LL);
CallInfo c_SQLite3::ci___destruct((void*)&c_SQLite3::i___destruct, (void*)&c_SQLite3::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_createfunction((void*)&c_SQLite3::i_createfunction, (void*)&c_SQLite3::ifa_createfunction, 3, 0, 0x0000000000000000LL);
CallInfo c_SQLite3::ci___construct((void*)&c_SQLite3::i___construct, (void*)&c_SQLite3::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_lastinsertrowid((void*)&c_SQLite3::i_lastinsertrowid, (void*)&c_SQLite3::ifa_lastinsertrowid, 0, 0, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_query((void*)&c_SQLite3::i_query, (void*)&c_SQLite3::ifa_query, 1, 0, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_close((void*)&c_SQLite3::i_close, (void*)&c_SQLite3::ifa_close, 0, 0, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_escapestring((void*)&c_SQLite3::i_escapestring, (void*)&c_SQLite3::ifa_escapestring, 1, 0, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_lasterrormsg((void*)&c_SQLite3::i_lasterrormsg, (void*)&c_SQLite3::ifa_lasterrormsg, 0, 0, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_createaggregate((void*)&c_SQLite3::i_createaggregate, (void*)&c_SQLite3::ifa_createaggregate, 4, 0, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_open((void*)&c_SQLite3::i_open, (void*)&c_SQLite3::ifa_open, 3, 0, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_changes((void*)&c_SQLite3::i_changes, (void*)&c_SQLite3::ifa_changes, 0, 0, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_openblob((void*)&c_SQLite3::i_openblob, (void*)&c_SQLite3::ifa_openblob, 4, 0, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_lasterrorcode((void*)&c_SQLite3::i_lasterrorcode, (void*)&c_SQLite3::ifa_lasterrorcode, 0, 0, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_prepare((void*)&c_SQLite3::i_prepare, (void*)&c_SQLite3::ifa_prepare, 1, 0, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_querysingle((void*)&c_SQLite3::i_querysingle, (void*)&c_SQLite3::ifa_querysingle, 2, 0, 0x0000000000000000LL);
Variant c_SQLite3::i_exec(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_exec(arg0));
  }
}
Variant c_SQLite3::i_version(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("version", 0, 1);
  return (self->t_version());
}
Variant c_SQLite3::i_loadextension(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_loadextension(arg0));
  }
}
Variant c_SQLite3::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SQLite3::i_createfunction(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_createfunction(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_createfunction(arg0, arg1, arg2));
  }
}
Variant c_SQLite3::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_SQLite3::i_lastinsertrowid(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
  return (self->t_lastinsertrowid());
}
Variant c_SQLite3::i_query(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_query(arg0));
  }
}
Variant c_SQLite3::i_close(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("close", 0, 1);
  return (self->t_close());
}
Variant c_SQLite3::i_escapestring(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_escapestring(arg0));
  }
}
Variant c_SQLite3::i_lasterrormsg(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
  return (self->t_lasterrormsg());
}
Variant c_SQLite3::i_createaggregate(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (self->t_createaggregate(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_createaggregate(arg0, arg1, arg2, arg3));
  }
}
Variant c_SQLite3::i_open(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_open(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_open(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_open(arg0, arg1, arg2), null);
  }
}
Variant c_SQLite3::i_changes(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("changes", 0, 1);
  return (self->t_changes());
}
Variant c_SQLite3::i_openblob(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (self->t_openblob(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_openblob(arg0, arg1, arg2, arg3));
  }
}
Variant c_SQLite3::i_lasterrorcode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
  return (self->t_lasterrorcode());
}
Variant c_SQLite3::i_prepare(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_prepare(arg0));
  }
}
Variant c_SQLite3::i_querysingle(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_querysingle(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_querysingle(arg0, arg1));
  }
}
Variant c_SQLite3::ifa_exec(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
  return (self->t_exec(a0));
}
Variant c_SQLite3::ifa_version(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("version", 0, 1);
  return (self->t_version());
}
Variant c_SQLite3::ifa_loadextension(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
  return (self->t_loadextension(a0));
}
Variant c_SQLite3::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SQLite3::ifa_createfunction(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
  if (count <= 2) return (self->t_createfunction(a0, a1));
  return (self->t_createfunction(a0, a1, a2));
}
Variant c_SQLite3::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_SQLite3::ifa_lastinsertrowid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
  return (self->t_lastinsertrowid());
}
Variant c_SQLite3::ifa_query(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
  return (self->t_query(a0));
}
Variant c_SQLite3::ifa_close(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("close", 0, 1);
  return (self->t_close());
}
Variant c_SQLite3::ifa_escapestring(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
  return (self->t_escapestring(a0));
}
Variant c_SQLite3::ifa_lasterrormsg(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
  return (self->t_lasterrormsg());
}
Variant c_SQLite3::ifa_createaggregate(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
  if (count <= 3) return (self->t_createaggregate(a0, a1, a2));
  return (self->t_createaggregate(a0, a1, a2, a3));
}
Variant c_SQLite3::ifa_open(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
  if (count <= 1) return (self->t_open(a0), null);
  if (count == 2) return (self->t_open(a0, a1), null);
  return (self->t_open(a0, a1, a2), null);
}
Variant c_SQLite3::ifa_changes(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("changes", 0, 1);
  return (self->t_changes());
}
Variant c_SQLite3::ifa_openblob(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
  if (count <= 3) return (self->t_openblob(a0, a1, a2));
  return (self->t_openblob(a0, a1, a2, a3));
}
Variant c_SQLite3::ifa_lasterrorcode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
  return (self->t_lasterrorcode());
}
Variant c_SQLite3::ifa_prepare(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
  return (self->t_prepare(a0));
}
Variant c_SQLite3::ifa_querysingle(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
  if (count <= 1) return (self->t_querysingle(a0));
  return (self->t_querysingle(a0, a1));
}
bool c_SQLite3::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        mcp.ci = &c_SQLite3::ci_close;
        return true;
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x6081F282094466C2LL, NAMSTR(s_sys_ss094466c2, "lasterrormsg")) {
        mcp.ci = &c_SQLite3::ci_lasterrormsg;
        return true;
      }
      HASH_GUARD_LITSTR(0x65BD6700742BF3C2LL, NAMSTR(s_sys_ss742bf3c2, "openblob")) {
        mcp.ci = &c_SQLite3::ci_openblob;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x3AA4CCEC6BD68143LL, NAMSTR(s_sys_ss6bd68143, "createaggregate")) {
        mcp.ci = &c_SQLite3::ci_createaggregate;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x21F68C010C124BC4LL, NAMSTR(s_sys_ss0c124bc4, "open")) {
        mcp.ci = &c_SQLite3::ci_open;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x632B468FC2FCAB0ALL, NAMSTR(s_sys_ss3d0354f6, "lasterrorcode")) {
        mcp.ci = &c_SQLite3::ci_lasterrorcode;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss4f78df74, "exec")) {
        mcp.ci = &c_SQLite3::ci_exec;
        return true;
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x7CECF508291057CDLL, NAMSTR(s_sys_ss291057cd, "createfunction")) {
        mcp.ci = &c_SQLite3::ci_createfunction;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x64D2BDB189B02819LL, NAMSTR(s_sys_ss764fd7e7, "changes")) {
        mcp.ci = &c_SQLite3::ci_changes;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SQLite3::ci___construct;
        return true;
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x1B3CDE890A487664LL, NAMSTR(s_sys_ss0a487664, "loadextension")) {
        mcp.ci = &c_SQLite3::ci_loadextension;
        return true;
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x5024F08DB0FDCBE6LL, NAMSTR(s_sys_ss4f02341a, "lastinsertrowid")) {
        mcp.ci = &c_SQLite3::ci_lastinsertrowid;
        return true;
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x5AE41239FF63D86ALL, NAMSTR(s_sys_ss009c2796, "version")) {
        mcp.ci = &c_SQLite3::ci_version;
        return true;
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x156B1FAE4132ABEELL, NAMSTR(s_sys_ss4132abee, "querysingle")) {
        mcp.ci = &c_SQLite3::ci_querysingle;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss4ba591af, "prepare")) {
        mcp.ci = &c_SQLite3::ci_prepare;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SQLite3::ci___destruct;
        return true;
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x607C4C73BB251635LL, NAMSTR(s_sys_ss44dae9cb, "escapestring")) {
        mcp.ci = &c_SQLite3::ci_escapestring;
        return true;
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        mcp.ci = &c_SQLite3::ci_query;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SQLite3::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        mcp.ci = &c_SQLite3::ci_close;
        mcp.obj = this;
        return true;
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x6081F282094466C2LL, NAMSTR(s_sys_ss094466c2, "lasterrormsg")) {
        mcp.ci = &c_SQLite3::ci_lasterrormsg;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x65BD6700742BF3C2LL, NAMSTR(s_sys_ss742bf3c2, "openblob")) {
        mcp.ci = &c_SQLite3::ci_openblob;
        mcp.obj = this;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x3AA4CCEC6BD68143LL, NAMSTR(s_sys_ss6bd68143, "createaggregate")) {
        mcp.ci = &c_SQLite3::ci_createaggregate;
        mcp.obj = this;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x21F68C010C124BC4LL, NAMSTR(s_sys_ss0c124bc4, "open")) {
        mcp.ci = &c_SQLite3::ci_open;
        mcp.obj = this;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x632B468FC2FCAB0ALL, NAMSTR(s_sys_ss3d0354f6, "lasterrorcode")) {
        mcp.ci = &c_SQLite3::ci_lasterrorcode;
        mcp.obj = this;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss4f78df74, "exec")) {
        mcp.ci = &c_SQLite3::ci_exec;
        mcp.obj = this;
        return true;
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x7CECF508291057CDLL, NAMSTR(s_sys_ss291057cd, "createfunction")) {
        mcp.ci = &c_SQLite3::ci_createfunction;
        mcp.obj = this;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x64D2BDB189B02819LL, NAMSTR(s_sys_ss764fd7e7, "changes")) {
        mcp.ci = &c_SQLite3::ci_changes;
        mcp.obj = this;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SQLite3::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x1B3CDE890A487664LL, NAMSTR(s_sys_ss0a487664, "loadextension")) {
        mcp.ci = &c_SQLite3::ci_loadextension;
        mcp.obj = this;
        return true;
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x5024F08DB0FDCBE6LL, NAMSTR(s_sys_ss4f02341a, "lastinsertrowid")) {
        mcp.ci = &c_SQLite3::ci_lastinsertrowid;
        mcp.obj = this;
        return true;
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x5AE41239FF63D86ALL, NAMSTR(s_sys_ss009c2796, "version")) {
        mcp.ci = &c_SQLite3::ci_version;
        mcp.obj = this;
        return true;
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x156B1FAE4132ABEELL, NAMSTR(s_sys_ss4132abee, "querysingle")) {
        mcp.ci = &c_SQLite3::ci_querysingle;
        mcp.obj = this;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss4ba591af, "prepare")) {
        mcp.ci = &c_SQLite3::ci_prepare;
        mcp.obj = this;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SQLite3::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x607C4C73BB251635LL, NAMSTR(s_sys_ss44dae9cb, "escapestring")) {
        mcp.ci = &c_SQLite3::ci_escapestring;
        mcp.obj = this;
        return true;
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        mcp.ci = &c_SQLite3::ci_query;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_SQLite3 *c_SQLite3::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_SQLite3::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_SQLite3::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_SQLite3::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SQLite3::ci___construct;
  mcp.obj = this;
}
void c_SQLite3::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_SQLite3 = {
  c_SQLite3::os_getInit,
  c_SQLite3::os_get,
  c_SQLite3::os_lval,
  c_SQLite3::os_invoke,
  c_SQLite3::os_constant,
  c_SQLite3::os_get_call_info
};
Object co_DOMAttr(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMAttr)())->dynCreate(params, init));
}
Object coo_DOMAttr() {
  Object r(NEW(c_DOMAttr)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMAttr
Variant c_DOMAttr::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMAttr
Variant c_DOMAttr::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMAttr
Variant &c_DOMAttr::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMAttr
void c_DOMAttr::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMAttr
void c_DOMAttr::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMAttr
Variant * c_DOMAttr::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMAttr
Variant * c_DOMAttr::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMAttr
Variant * c_DOMAttr::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMAttr
Variant c_DOMAttr::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMAttr
IMPLEMENT_CLASS(DOMAttr)
void c_DOMAttr::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMAttr::cloneImpl() {
  c_DOMAttr *obj = NEW(c_DOMAttr)();
  cloneSet(obj);
  return obj;
}
void c_DOMAttr::cloneSet(c_DOMAttr *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMAttr::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x30A9329415D17F24LL, NAMSTR(s_sys_ss15d17f24, "isId")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isid());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMAttr::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMAttr::ci_isid((void*)&c_DOMAttr::i_isid, (void*)&c_DOMAttr::ifa_isid, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMAttr::ci___destruct((void*)&c_DOMAttr::i___destruct, (void*)&c_DOMAttr::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMAttr::ci___set((void*)&c_DOMAttr::i___set, (void*)&c_DOMAttr::ifa___set, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMAttr::ci___construct((void*)&c_DOMAttr::i___construct, (void*)&c_DOMAttr::ifa___construct, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMAttr::ci___get((void*)&c_DOMAttr::i___get, (void*)&c_DOMAttr::ifa___get, 1, 0, 0x0000000000000000LL);
Variant c_DOMAttr::i_isid(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("isid", 0, 1);
  return (self->t_isid());
}
Variant c_DOMAttr::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMAttr::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMAttr::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_DOMAttr::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMAttr::ifa_isid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("isid", 0, 1);
  return (self->t_isid());
}
Variant c_DOMAttr::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMAttr::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMAttr::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
  if (count <= 1) return (self->t___construct(a0), null);
  return (self->t___construct(a0, a1), null);
}
Variant c_DOMAttr::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
bool c_DOMAttr::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMAttr::ci___destruct;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x30A9329415D17F24LL, NAMSTR(s_sys_ss15d17f24, "isId")) {
        mcp.ci = &c_DOMAttr::ci_isid;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMAttr::ci___set;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMAttr::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMAttr::ci___get;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMAttr::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMAttr::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x30A9329415D17F24LL, NAMSTR(s_sys_ss15d17f24, "isId")) {
        mcp.ci = &c_DOMAttr::ci_isid;
        mcp.obj = this;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMAttr::ci___set;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMAttr::ci___construct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMAttr::ci___get;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_get_call_info(mcp, hash);
}
c_DOMAttr *c_DOMAttr::create(String a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_DOMAttr::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_DOMAttr::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_DOMAttr::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMAttr::ci___construct;
  mcp.obj = this;
}
void c_DOMAttr::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
struct ObjectStaticCallbacks cw_DOMAttr = {
  c_DOMAttr::os_getInit,
  c_DOMAttr::os_get,
  c_DOMAttr::os_lval,
  c_DOMAttr::os_invoke,
  c_DOMAttr::os_constant,
  c_DOMAttr::os_get_call_info
};
Object co_SoapVar(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SoapVar)())->dynCreate(params, init));
}
Object coo_SoapVar() {
  Object r(NEW(c_SoapVar)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapVar
Variant c_SoapVar::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapVar
Variant c_SoapVar::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapVar
Variant &c_SoapVar::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapVar
void c_SoapVar::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapVar
void c_SoapVar::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SoapVar
Variant * c_SoapVar::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapVar
Variant * c_SoapVar::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapVar
Variant * c_SoapVar::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapVar
Variant c_SoapVar::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapVar
IMPLEMENT_CLASS(SoapVar)
void c_SoapVar::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SoapVar::cloneImpl() {
  c_SoapVar *obj = NEW(c_SoapVar)();
  cloneSet(obj);
  return obj;
}
void c_SoapVar::cloneSet(c_SoapVar *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SoapVar::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        else return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SoapVar::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SoapVar::ci___destruct((void*)&c_SoapVar::i___destruct, (void*)&c_SoapVar::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_SoapVar::ci___construct((void*)&c_SoapVar::i___construct, (void*)&c_SoapVar::ifa___construct, 6, 0, 0x0000000000000000LL);
Variant c_SoapVar::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapVar *self = NULL;
  p_SoapVar pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapVar*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapVar::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapVar *self = NULL;
  p_SoapVar pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapVar*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t___construct(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t___construct(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t___construct(arg0, arg1, arg2, arg3), null);
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (self->t___construct(arg0, arg1, arg2, arg3, arg4), null);
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1, arg2, arg3, arg4, arg5), null);
  }
}
Variant c_SoapVar::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapVar *self = NULL;
  p_SoapVar pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapVar*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapVar::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapVar *self = NULL;
  p_SoapVar pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapVar*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
  if (count <= 2) return (self->t___construct(a0, a1), null);
  if (count == 3) return (self->t___construct(a0, a1, a2), null);
  if (count == 4) return (self->t___construct(a0, a1, a2, a3), null);
  if (count == 5) return (self->t___construct(a0, a1, a2, a3, a4), null);
  return (self->t___construct(a0, a1, a2, a3, a4, a5), null);
}
bool c_SoapVar::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SoapVar::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SoapVar::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SoapVar::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SoapVar::ci___destruct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SoapVar::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_SoapVar *c_SoapVar::create(Variant a0, Variant a1, String a2, String a3, String a4, String a5) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4, a5);
  return this;
}
ObjectData *c_SoapVar::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      if (count <= 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 5) {
        (t___construct(arg0, arg1, arg2, arg3, arg4));
        break;
      }
      CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
    } while (false);
  }
  return this;
}
void c_SoapVar::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) {
      (t___construct(arg0, arg1, arg2, arg3, arg4));
      break;
    }
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
  } while (false);
}
void c_SoapVar::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SoapVar::ci___construct;
  mcp.obj = this;
}
void c_SoapVar::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else if (count == 5) (t___construct(a0, a1, a2, a3, a4), null);
  else (t___construct(a0, a1, a2, a3, a4, a5), null);
}
struct ObjectStaticCallbacks cw_SoapVar = {
  c_SoapVar::os_getInit,
  c_SoapVar::os_get,
  c_SoapVar::os_lval,
  c_SoapVar::os_invoke,
  c_SoapVar::os_constant,
  c_SoapVar::os_get_call_info
};
Object co_DOMNamedNodeMap(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMNamedNodeMap)())->dynCreate(params, init));
}
Object coo_DOMNamedNodeMap() {
  Object r(NEW(c_DOMNamedNodeMap)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNamedNodeMap
Variant c_DOMNamedNodeMap::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNamedNodeMap
Variant c_DOMNamedNodeMap::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNamedNodeMap
Variant &c_DOMNamedNodeMap::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNamedNodeMap
void c_DOMNamedNodeMap::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNamedNodeMap
void c_DOMNamedNodeMap::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMNamedNodeMap
Variant * c_DOMNamedNodeMap::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNamedNodeMap
Variant * c_DOMNamedNodeMap::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNamedNodeMap
Variant * c_DOMNamedNodeMap::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNamedNodeMap
Variant c_DOMNamedNodeMap::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNamedNodeMap
IMPLEMENT_CLASS(DOMNamedNodeMap)
void c_DOMNamedNodeMap::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMNamedNodeMap::cloneImpl() {
  c_DOMNamedNodeMap *obj = NEW(c_DOMNamedNodeMap)();
  cloneSet(obj);
  return obj;
}
void c_DOMNamedNodeMap::cloneSet(c_DOMNamedNodeMap *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DOMNamedNodeMap::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getIterator")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss7cf6fd3a, "item")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_item(a0));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x5D3CEC627F9ADC3ALL, NAMSTR(s_sys_ss7f9adc3a, "getNamedItem")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnameditem(a0));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x53B4D840FF4F0F1BLL, NAMSTR(s_sys_ss00b0f0e5, "getNamedItemNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnameditemns(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMNamedNodeMap::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMNamedNodeMap::ci_item((void*)&c_DOMNamedNodeMap::i_item, (void*)&c_DOMNamedNodeMap::ifa_item, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMNamedNodeMap::ci_getnameditem((void*)&c_DOMNamedNodeMap::i_getnameditem, (void*)&c_DOMNamedNodeMap::ifa_getnameditem, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMNamedNodeMap::ci___destruct((void*)&c_DOMNamedNodeMap::i___destruct, (void*)&c_DOMNamedNodeMap::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNamedNodeMap::ci___set((void*)&c_DOMNamedNodeMap::i___set, (void*)&c_DOMNamedNodeMap::ifa___set, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMNamedNodeMap::ci___construct((void*)&c_DOMNamedNodeMap::i___construct, (void*)&c_DOMNamedNodeMap::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNamedNodeMap::ci_getiterator((void*)&c_DOMNamedNodeMap::i_getiterator, (void*)&c_DOMNamedNodeMap::ifa_getiterator, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNamedNodeMap::ci___get((void*)&c_DOMNamedNodeMap::i___get, (void*)&c_DOMNamedNodeMap::ifa___get, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMNamedNodeMap::ci_getnameditemns((void*)&c_DOMNamedNodeMap::i_getnameditemns, (void*)&c_DOMNamedNodeMap::ifa_getnameditemns, 2, 0, 0x0000000000000000LL);
Variant c_DOMNamedNodeMap::i_item(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_item(arg0));
  }
}
Variant c_DOMNamedNodeMap::i_getnameditem(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getnameditem(arg0));
  }
}
Variant c_DOMNamedNodeMap::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNamedNodeMap::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMNamedNodeMap::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNamedNodeMap::i_getiterator(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
  return (self->t_getiterator());
}
Variant c_DOMNamedNodeMap::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMNamedNodeMap::i_getnameditemns(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getnameditemns(arg0, arg1));
  }
}
Variant c_DOMNamedNodeMap::ifa_item(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
  return (self->t_item(a0));
}
Variant c_DOMNamedNodeMap::ifa_getnameditem(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
  return (self->t_getnameditem(a0));
}
Variant c_DOMNamedNodeMap::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNamedNodeMap::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMNamedNodeMap::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNamedNodeMap::ifa_getiterator(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
  return (self->t_getiterator());
}
Variant c_DOMNamedNodeMap::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
Variant c_DOMNamedNodeMap::ifa_getnameditemns(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
  return (self->t_getnameditemns(a0, a1));
}
bool c_DOMNamedNodeMap::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMNamedNodeMap::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getIterator")) {
        mcp.ci = &c_DOMNamedNodeMap::ci_getiterator;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMNamedNodeMap::ci___set;
        return true;
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss7cf6fd3a, "item")) {
        mcp.ci = &c_DOMNamedNodeMap::ci_item;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x5D3CEC627F9ADC3ALL, NAMSTR(s_sys_ss7f9adc3a, "getNamedItem")) {
        mcp.ci = &c_DOMNamedNodeMap::ci_getnameditem;
        return true;
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x53B4D840FF4F0F1BLL, NAMSTR(s_sys_ss00b0f0e5, "getNamedItemNS")) {
        mcp.ci = &c_DOMNamedNodeMap::ci_getnameditemns;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMNamedNodeMap::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMNamedNodeMap::ci___get;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DOMNamedNodeMap::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMNamedNodeMap::ci___destruct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getIterator")) {
        mcp.ci = &c_DOMNamedNodeMap::ci_getiterator;
        mcp.obj = this;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMNamedNodeMap::ci___set;
        mcp.obj = this;
        return true;
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss7cf6fd3a, "item")) {
        mcp.ci = &c_DOMNamedNodeMap::ci_item;
        mcp.obj = this;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x5D3CEC627F9ADC3ALL, NAMSTR(s_sys_ss7f9adc3a, "getNamedItem")) {
        mcp.ci = &c_DOMNamedNodeMap::ci_getnameditem;
        mcp.obj = this;
        return true;
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x53B4D840FF4F0F1BLL, NAMSTR(s_sys_ss00b0f0e5, "getNamedItemNS")) {
        mcp.ci = &c_DOMNamedNodeMap::ci_getnameditemns;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMNamedNodeMap::ci___construct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMNamedNodeMap::ci___get;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_DOMNamedNodeMap *c_DOMNamedNodeMap::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMNamedNodeMap::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMNamedNodeMap::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMNamedNodeMap::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMNamedNodeMap::ci___construct;
  mcp.obj = this;
}
void c_DOMNamedNodeMap::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMNamedNodeMap = {
  c_DOMNamedNodeMap::os_getInit,
  c_DOMNamedNodeMap::os_get,
  c_DOMNamedNodeMap::os_lval,
  c_DOMNamedNodeMap::os_invoke,
  c_DOMNamedNodeMap::os_constant,
  c_DOMNamedNodeMap::os_get_call_info
};
Object co_SQLite3Result(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SQLite3Result)())->dynCreate(params, init));
}
Object coo_SQLite3Result() {
  Object r(NEW(c_SQLite3Result)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SQLite3Result
Variant c_SQLite3Result::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SQLite3Result
Variant c_SQLite3Result::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SQLite3Result
Variant &c_SQLite3Result::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SQLite3Result
void c_SQLite3Result::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SQLite3Result
void c_SQLite3Result::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SQLite3Result
Variant * c_SQLite3Result::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SQLite3Result
Variant * c_SQLite3Result::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SQLite3Result
Variant * c_SQLite3Result::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SQLite3Result
Variant c_SQLite3Result::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SQLite3Result
IMPLEMENT_CLASS(SQLite3Result)
void c_SQLite3Result::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SQLite3Result::cloneImpl() {
  c_SQLite3Result *obj = NEW(c_SQLite3Result)();
  cloneSet(obj);
  return obj;
}
void c_SQLite3Result::cloneSet(c_SQLite3Result *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SQLite3Result::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss22a924e0, "reset")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_reset());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x4C7702FC22784996LL, NAMSTR(s_sys_ss22784996, "numcolumns")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_numcolumns());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x696EFC04EE7E47F8LL, NAMSTR(s_sys_ss1181b808, "columnname")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columnname(a0));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x59F73C4DEF1C3A6BLL, NAMSTR(s_sys_ss10e3c595, "fetcharray")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetcharray());
        else return (t_fetcharray(a0));
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x32A58B0CE493957CLL, NAMSTR(s_sys_ss1b6c6a84, "finalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_finalize());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x42EDB5CA009D8C6DLL, NAMSTR(s_sys_ss009d8c6d, "columntype")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columntype(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SQLite3Result::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SQLite3Result::ci_columnname((void*)&c_SQLite3Result::i_columnname, (void*)&c_SQLite3Result::ifa_columnname, 1, 0, 0x0000000000000000LL);
CallInfo c_SQLite3Result::ci_columntype((void*)&c_SQLite3Result::i_columntype, (void*)&c_SQLite3Result::ifa_columntype, 1, 0, 0x0000000000000000LL);
CallInfo c_SQLite3Result::ci___destruct((void*)&c_SQLite3Result::i___destruct, (void*)&c_SQLite3Result::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_SQLite3Result::ci___construct((void*)&c_SQLite3Result::i___construct, (void*)&c_SQLite3Result::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_SQLite3Result::ci_numcolumns((void*)&c_SQLite3Result::i_numcolumns, (void*)&c_SQLite3Result::ifa_numcolumns, 0, 0, 0x0000000000000000LL);
CallInfo c_SQLite3Result::ci_fetcharray((void*)&c_SQLite3Result::i_fetcharray, (void*)&c_SQLite3Result::ifa_fetcharray, 1, 0, 0x0000000000000000LL);
CallInfo c_SQLite3Result::ci_reset((void*)&c_SQLite3Result::i_reset, (void*)&c_SQLite3Result::ifa_reset, 0, 0, 0x0000000000000000LL);
CallInfo c_SQLite3Result::ci_finalize((void*)&c_SQLite3Result::i_finalize, (void*)&c_SQLite3Result::ifa_finalize, 0, 0, 0x0000000000000000LL);
Variant c_SQLite3Result::i_columnname(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_columnname(arg0));
  }
}
Variant c_SQLite3Result::i_columntype(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_columntype(arg0));
  }
}
Variant c_SQLite3Result::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SQLite3Result::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_SQLite3Result::i_numcolumns(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
  return (self->t_numcolumns());
}
Variant c_SQLite3Result::i_fetcharray(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_fetcharray());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_fetcharray(arg0));
  }
}
Variant c_SQLite3Result::i_reset(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("reset", 0, 1);
  return (self->t_reset());
}
Variant c_SQLite3Result::i_finalize(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
  return (self->t_finalize());
}
Variant c_SQLite3Result::ifa_columnname(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
  return (self->t_columnname(a0));
}
Variant c_SQLite3Result::ifa_columntype(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
  return (self->t_columntype(a0));
}
Variant c_SQLite3Result::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SQLite3Result::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_SQLite3Result::ifa_numcolumns(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
  return (self->t_numcolumns());
}
Variant c_SQLite3Result::ifa_fetcharray(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
  if (count <= 0) return (self->t_fetcharray());
  return (self->t_fetcharray(a0));
}
Variant c_SQLite3Result::ifa_reset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("reset", 0, 1);
  return (self->t_reset());
}
Variant c_SQLite3Result::ifa_finalize(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
  return (self->t_finalize());
}
bool c_SQLite3Result::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss22a924e0, "reset")) {
        mcp.ci = &c_SQLite3Result::ci_reset;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SQLite3Result::ci___destruct;
        return true;
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x4C7702FC22784996LL, NAMSTR(s_sys_ss22784996, "numcolumns")) {
        mcp.ci = &c_SQLite3Result::ci_numcolumns;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x696EFC04EE7E47F8LL, NAMSTR(s_sys_ss1181b808, "columnname")) {
        mcp.ci = &c_SQLite3Result::ci_columnname;
        return true;
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x59F73C4DEF1C3A6BLL, NAMSTR(s_sys_ss10e3c595, "fetcharray")) {
        mcp.ci = &c_SQLite3Result::ci_fetcharray;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x32A58B0CE493957CLL, NAMSTR(s_sys_ss1b6c6a84, "finalize")) {
        mcp.ci = &c_SQLite3Result::ci_finalize;
        return true;
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x42EDB5CA009D8C6DLL, NAMSTR(s_sys_ss009d8c6d, "columntype")) {
        mcp.ci = &c_SQLite3Result::ci_columntype;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SQLite3Result::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SQLite3Result::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss22a924e0, "reset")) {
        mcp.ci = &c_SQLite3Result::ci_reset;
        mcp.obj = this;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SQLite3Result::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x4C7702FC22784996LL, NAMSTR(s_sys_ss22784996, "numcolumns")) {
        mcp.ci = &c_SQLite3Result::ci_numcolumns;
        mcp.obj = this;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x696EFC04EE7E47F8LL, NAMSTR(s_sys_ss1181b808, "columnname")) {
        mcp.ci = &c_SQLite3Result::ci_columnname;
        mcp.obj = this;
        return true;
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x59F73C4DEF1C3A6BLL, NAMSTR(s_sys_ss10e3c595, "fetcharray")) {
        mcp.ci = &c_SQLite3Result::ci_fetcharray;
        mcp.obj = this;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x32A58B0CE493957CLL, NAMSTR(s_sys_ss1b6c6a84, "finalize")) {
        mcp.ci = &c_SQLite3Result::ci_finalize;
        mcp.obj = this;
        return true;
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x42EDB5CA009D8C6DLL, NAMSTR(s_sys_ss009d8c6d, "columntype")) {
        mcp.ci = &c_SQLite3Result::ci_columntype;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SQLite3Result::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_SQLite3Result *c_SQLite3Result::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_SQLite3Result::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_SQLite3Result::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_SQLite3Result::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SQLite3Result::ci___construct;
  mcp.obj = this;
}
void c_SQLite3Result::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_SQLite3Result = {
  c_SQLite3Result::os_getInit,
  c_SQLite3Result::os_get,
  c_SQLite3Result::os_lval,
  c_SQLite3Result::os_invoke,
  c_SQLite3Result::os_constant,
  c_SQLite3Result::os_get_call_info
};
Object co_SimpleXMLElement(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SimpleXMLElement)())->dynCreate(params, init));
}
Object coo_SimpleXMLElement() {
  Object r(NEW(c_SimpleXMLElement)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SimpleXMLElement
Variant c_SimpleXMLElement::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SimpleXMLElement
Variant c_SimpleXMLElement::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SimpleXMLElement
Variant &c_SimpleXMLElement::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SimpleXMLElement
void c_SimpleXMLElement::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SimpleXMLElement
void c_SimpleXMLElement::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SimpleXMLElement
Variant * c_SimpleXMLElement::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SimpleXMLElement
Variant * c_SimpleXMLElement::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SimpleXMLElement
Variant * c_SimpleXMLElement::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SimpleXMLElement
Variant c_SimpleXMLElement::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SimpleXMLElement
IMPLEMENT_CLASS(SimpleXMLElement)
void c_SimpleXMLElement::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SimpleXMLElement::cloneImpl() {
  c_SimpleXMLElement *obj = NEW(c_SimpleXMLElement)();
  cloneSet(obj);
  return obj;
}
void c_SimpleXMLElement::cloneSet(c_SimpleXMLElement *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SimpleXMLElement::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x3E6BCFB9742FC700LL, NAMSTR(s_sys_ss742fc700, "offsetExists")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetexists(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getIterator")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x5CEFA5A265104D10LL, NAMSTR(s_sys_ss65104d10, "count")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("count", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_count());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x2DDE12A9866FC794LL, NAMSTR(s_sys_ss7990386c, "addChild")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addchild(a0));
        else if (count == 2) return (t_addchild(a0, a1));
        else return (t_addchild(a0, a1, a2));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x52F7AA6C19BEEAD6LL, NAMSTR(s_sys_ss19beead6, "addAttribute")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addattribute(a0), null);
        else if (count == 2) return (t_addattribute(a0, a1), null);
        else return (t_addattribute(a0, a1, a2), null);
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x61D11ECEF4404498LL, NAMSTR(s_sys_ss0bbfbb68, "offsetGet")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetget(a0));
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x0817454F196A9A1BLL, NAMSTR(s_sys_ss196a9a1b, "xpath")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_xpath(a0));
      }
      HASH_GUARD_LITSTR(0x04FB7028C9A2079BLL, NAMSTR(s_sys_ss365df865, "__unset")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___unset(a0));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4B65E1A09A33F21DLL, NAMSTR(s_sys_ss65cc0de3, "attributes")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_attributes());
        else if (count == 1) return (t_attributes(a0));
        else return (t_attributes(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x6D9D75B7E3B40FA6LL, NAMSTR(s_sys_ss1c4bf05a, "getNamespaces")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getnamespaces());
        else return (t_getnamespaces(a0));
      }
      HASH_GUARD_LITSTR(0x5C09D9345FD864A6LL, NAMSTR(s_sys_ss5fd864a6, "asXML")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_asxml());
        else return (t_asxml(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x2B299E949E2E82ADLL, NAMSTR(s_sys_ss61d17d53, "children")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_children());
        else if (count == 1) return (t_children(a0));
        else return (t_children(a0, a1));
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x4FE08FDDAE2178EELL, NAMSTR(s_sys_ss51de8712, "__isset")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___isset(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x0D08AA5F0B2F34F1LL, NAMSTR(s_sys_ss0b2f34f1, "getDocNamespaces")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getdocnamespaces());
        else return (t_getdocnamespaces(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x0957F693A48AF738LL, NAMSTR(s_sys_ss5b7508c8, "offsetSet")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetset(a0, a1), null);
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x08329980E6369ABALL, NAMSTR(s_sys_ss19c96546, "offsetUnset")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetunset(a0), null);
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x3FE8F6937854F83DLL, NAMSTR(s_sys_ss7854f83d, "registerXPathNamespace")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registerxpathnamespace(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SimpleXMLElement::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SimpleXMLElement::ci_addattribute((void*)&c_SimpleXMLElement::i_addattribute, (void*)&c_SimpleXMLElement::ifa_addattribute, 3, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_count((void*)&c_SimpleXMLElement::i_count, (void*)&c_SimpleXMLElement::ifa_count, 0, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci___tostring((void*)&c_SimpleXMLElement::i___tostring, (void*)&c_SimpleXMLElement::ifa___tostring, 0, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_xpath((void*)&c_SimpleXMLElement::i_xpath, (void*)&c_SimpleXMLElement::ifa_xpath, 1, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci___destruct((void*)&c_SimpleXMLElement::i___destruct, (void*)&c_SimpleXMLElement::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci___set((void*)&c_SimpleXMLElement::i___set, (void*)&c_SimpleXMLElement::ifa___set, 2, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci___construct((void*)&c_SimpleXMLElement::i___construct, (void*)&c_SimpleXMLElement::ifa___construct, 5, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_offsetexists((void*)&c_SimpleXMLElement::i_offsetexists, (void*)&c_SimpleXMLElement::ifa_offsetexists, 1, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_getiterator((void*)&c_SimpleXMLElement::i_getiterator, (void*)&c_SimpleXMLElement::ifa_getiterator, 0, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_registerxpathnamespace((void*)&c_SimpleXMLElement::i_registerxpathnamespace, (void*)&c_SimpleXMLElement::ifa_registerxpathnamespace, 2, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_offsetget((void*)&c_SimpleXMLElement::i_offsetget, (void*)&c_SimpleXMLElement::ifa_offsetget, 1, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_getnamespaces((void*)&c_SimpleXMLElement::i_getnamespaces, (void*)&c_SimpleXMLElement::ifa_getnamespaces, 1, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci___unset((void*)&c_SimpleXMLElement::i___unset, (void*)&c_SimpleXMLElement::ifa___unset, 1, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_asxml((void*)&c_SimpleXMLElement::i_asxml, (void*)&c_SimpleXMLElement::ifa_asxml, 1, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_getdocnamespaces((void*)&c_SimpleXMLElement::i_getdocnamespaces, (void*)&c_SimpleXMLElement::ifa_getdocnamespaces, 1, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_offsetunset((void*)&c_SimpleXMLElement::i_offsetunset, (void*)&c_SimpleXMLElement::ifa_offsetunset, 1, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci___get((void*)&c_SimpleXMLElement::i___get, (void*)&c_SimpleXMLElement::ifa___get, 1, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_children((void*)&c_SimpleXMLElement::i_children, (void*)&c_SimpleXMLElement::ifa_children, 2, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_addchild((void*)&c_SimpleXMLElement::i_addchild, (void*)&c_SimpleXMLElement::ifa_addchild, 3, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci___isset((void*)&c_SimpleXMLElement::i___isset, (void*)&c_SimpleXMLElement::ifa___isset, 1, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_getname((void*)&c_SimpleXMLElement::i_getname, (void*)&c_SimpleXMLElement::ifa_getname, 0, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_attributes((void*)&c_SimpleXMLElement::i_attributes, (void*)&c_SimpleXMLElement::ifa_attributes, 2, 0, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_offsetset((void*)&c_SimpleXMLElement::i_offsetset, (void*)&c_SimpleXMLElement::ifa_offsetset, 2, 0, 0x0000000000000000LL);
Variant c_SimpleXMLElement::i_addattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_addattribute(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_addattribute(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_addattribute(arg0, arg1, arg2), null);
  }
}
Variant c_SimpleXMLElement::i_count(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("count", 0, 1);
  return (self->t_count());
}
Variant c_SimpleXMLElement::i___tostring(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
  return (self->t___tostring());
}
Variant c_SimpleXMLElement::i_xpath(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_xpath(arg0));
  }
}
Variant c_SimpleXMLElement::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SimpleXMLElement::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_SimpleXMLElement::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t___construct(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t___construct(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t___construct(arg0, arg1, arg2, arg3), null);
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant c_SimpleXMLElement::i_offsetexists(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_offsetexists(arg0));
  }
}
Variant c_SimpleXMLElement::i_getiterator(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
  return (self->t_getiterator());
}
Variant c_SimpleXMLElement::i_registerxpathnamespace(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_registerxpathnamespace(arg0, arg1));
  }
}
Variant c_SimpleXMLElement::i_offsetget(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_offsetget(arg0));
  }
}
Variant c_SimpleXMLElement::i_getnamespaces(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_getnamespaces());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getnamespaces(arg0));
  }
}
Variant c_SimpleXMLElement::i___unset(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___unset(arg0));
  }
}
Variant c_SimpleXMLElement::i_asxml(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_asxml());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_asxml(arg0));
  }
}
Variant c_SimpleXMLElement::i_getdocnamespaces(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_getdocnamespaces());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getdocnamespaces(arg0));
  }
}
Variant c_SimpleXMLElement::i_offsetunset(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_offsetunset(arg0), null);
  }
}
Variant c_SimpleXMLElement::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_SimpleXMLElement::i_children(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("children", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_children());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_children(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_children(arg0, arg1));
  }
}
Variant c_SimpleXMLElement::i_addchild(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_addchild(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_addchild(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_addchild(arg0, arg1, arg2));
  }
}
Variant c_SimpleXMLElement::i___isset(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___isset(arg0));
  }
}
Variant c_SimpleXMLElement::i_getname(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getname", 0, 1);
  return (self->t_getname());
}
Variant c_SimpleXMLElement::i_attributes(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_attributes());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_attributes(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_attributes(arg0, arg1));
  }
}
Variant c_SimpleXMLElement::i_offsetset(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_offsetset(arg0, arg1), null);
  }
}
Variant c_SimpleXMLElement::ifa_addattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
  if (count <= 1) return (self->t_addattribute(a0), null);
  if (count == 2) return (self->t_addattribute(a0, a1), null);
  return (self->t_addattribute(a0, a1, a2), null);
}
Variant c_SimpleXMLElement::ifa_count(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("count", 0, 1);
  return (self->t_count());
}
Variant c_SimpleXMLElement::ifa___tostring(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
  return (self->t___tostring());
}
Variant c_SimpleXMLElement::ifa_xpath(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
  return (self->t_xpath(a0));
}
Variant c_SimpleXMLElement::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SimpleXMLElement::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_SimpleXMLElement::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
  if (count <= 1) return (self->t___construct(a0), null);
  if (count == 2) return (self->t___construct(a0, a1), null);
  if (count == 3) return (self->t___construct(a0, a1, a2), null);
  if (count == 4) return (self->t___construct(a0, a1, a2, a3), null);
  return (self->t___construct(a0, a1, a2, a3, a4), null);
}
Variant c_SimpleXMLElement::ifa_offsetexists(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
  return (self->t_offsetexists(a0));
}
Variant c_SimpleXMLElement::ifa_getiterator(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
  return (self->t_getiterator());
}
Variant c_SimpleXMLElement::ifa_registerxpathnamespace(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
  return (self->t_registerxpathnamespace(a0, a1));
}
Variant c_SimpleXMLElement::ifa_offsetget(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
  return (self->t_offsetget(a0));
}
Variant c_SimpleXMLElement::ifa_getnamespaces(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
  if (count <= 0) return (self->t_getnamespaces());
  return (self->t_getnamespaces(a0));
}
Variant c_SimpleXMLElement::ifa___unset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
  return (self->t___unset(a0));
}
Variant c_SimpleXMLElement::ifa_asxml(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
  if (count <= 0) return (self->t_asxml());
  return (self->t_asxml(a0));
}
Variant c_SimpleXMLElement::ifa_getdocnamespaces(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
  if (count <= 0) return (self->t_getdocnamespaces());
  return (self->t_getdocnamespaces(a0));
}
Variant c_SimpleXMLElement::ifa_offsetunset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
  return (self->t_offsetunset(a0), null);
}
Variant c_SimpleXMLElement::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
Variant c_SimpleXMLElement::ifa_children(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("children", 2, 1);
  if (count <= 0) return (self->t_children());
  if (count == 1) return (self->t_children(a0));
  return (self->t_children(a0, a1));
}
Variant c_SimpleXMLElement::ifa_addchild(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
  if (count <= 1) return (self->t_addchild(a0));
  if (count == 2) return (self->t_addchild(a0, a1));
  return (self->t_addchild(a0, a1, a2));
}
Variant c_SimpleXMLElement::ifa___isset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
  return (self->t___isset(a0));
}
Variant c_SimpleXMLElement::ifa_getname(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getname", 0, 1);
  return (self->t_getname());
}
Variant c_SimpleXMLElement::ifa_attributes(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
  if (count <= 0) return (self->t_attributes());
  if (count == 1) return (self->t_attributes(a0));
  return (self->t_attributes(a0, a1));
}
Variant c_SimpleXMLElement::ifa_offsetset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
  return (self->t_offsetset(a0, a1), null);
}
bool c_SimpleXMLElement::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x3E6BCFB9742FC700LL, NAMSTR(s_sys_ss742fc700, "offsetExists")) {
        mcp.ci = &c_SimpleXMLElement::ci_offsetexists;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getIterator")) {
        mcp.ci = &c_SimpleXMLElement::ci_getiterator;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_SimpleXMLElement::ci___get;
        return true;
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x5CEFA5A265104D10LL, NAMSTR(s_sys_ss65104d10, "count")) {
        mcp.ci = &c_SimpleXMLElement::ci_count;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        mcp.ci = &c_SimpleXMLElement::ci___tostring;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x2DDE12A9866FC794LL, NAMSTR(s_sys_ss7990386c, "addChild")) {
        mcp.ci = &c_SimpleXMLElement::ci_addchild;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_SimpleXMLElement::ci___set;
        return true;
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x52F7AA6C19BEEAD6LL, NAMSTR(s_sys_ss19beead6, "addAttribute")) {
        mcp.ci = &c_SimpleXMLElement::ci_addattribute;
        return true;
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x61D11ECEF4404498LL, NAMSTR(s_sys_ss0bbfbb68, "offsetGet")) {
        mcp.ci = &c_SimpleXMLElement::ci_offsetget;
        return true;
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x0817454F196A9A1BLL, NAMSTR(s_sys_ss196a9a1b, "xpath")) {
        mcp.ci = &c_SimpleXMLElement::ci_xpath;
        return true;
      }
      HASH_GUARD_LITSTR(0x04FB7028C9A2079BLL, NAMSTR(s_sys_ss365df865, "__unset")) {
        mcp.ci = &c_SimpleXMLElement::ci___unset;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4B65E1A09A33F21DLL, NAMSTR(s_sys_ss65cc0de3, "attributes")) {
        mcp.ci = &c_SimpleXMLElement::ci_attributes;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SimpleXMLElement::ci___construct;
        return true;
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        mcp.ci = &c_SimpleXMLElement::ci_getname;
        return true;
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x6D9D75B7E3B40FA6LL, NAMSTR(s_sys_ss1c4bf05a, "getNamespaces")) {
        mcp.ci = &c_SimpleXMLElement::ci_getnamespaces;
        return true;
      }
      HASH_GUARD_LITSTR(0x5C09D9345FD864A6LL, NAMSTR(s_sys_ss5fd864a6, "asXML")) {
        mcp.ci = &c_SimpleXMLElement::ci_asxml;
        return true;
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x2B299E949E2E82ADLL, NAMSTR(s_sys_ss61d17d53, "children")) {
        mcp.ci = &c_SimpleXMLElement::ci_children;
        return true;
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x4FE08FDDAE2178EELL, NAMSTR(s_sys_ss51de8712, "__isset")) {
        mcp.ci = &c_SimpleXMLElement::ci___isset;
        return true;
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x0D08AA5F0B2F34F1LL, NAMSTR(s_sys_ss0b2f34f1, "getDocNamespaces")) {
        mcp.ci = &c_SimpleXMLElement::ci_getdocnamespaces;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SimpleXMLElement::ci___destruct;
        return true;
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x0957F693A48AF738LL, NAMSTR(s_sys_ss5b7508c8, "offsetSet")) {
        mcp.ci = &c_SimpleXMLElement::ci_offsetset;
        return true;
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x08329980E6369ABALL, NAMSTR(s_sys_ss19c96546, "offsetUnset")) {
        mcp.ci = &c_SimpleXMLElement::ci_offsetunset;
        return true;
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x3FE8F6937854F83DLL, NAMSTR(s_sys_ss7854f83d, "registerXPathNamespace")) {
        mcp.ci = &c_SimpleXMLElement::ci_registerxpathnamespace;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SimpleXMLElement::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x3E6BCFB9742FC700LL, NAMSTR(s_sys_ss742fc700, "offsetExists")) {
        mcp.ci = &c_SimpleXMLElement::ci_offsetexists;
        mcp.obj = this;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getIterator")) {
        mcp.ci = &c_SimpleXMLElement::ci_getiterator;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_SimpleXMLElement::ci___get;
        mcp.obj = this;
        return true;
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x5CEFA5A265104D10LL, NAMSTR(s_sys_ss65104d10, "count")) {
        mcp.ci = &c_SimpleXMLElement::ci_count;
        mcp.obj = this;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        mcp.ci = &c_SimpleXMLElement::ci___tostring;
        mcp.obj = this;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x2DDE12A9866FC794LL, NAMSTR(s_sys_ss7990386c, "addChild")) {
        mcp.ci = &c_SimpleXMLElement::ci_addchild;
        mcp.obj = this;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_SimpleXMLElement::ci___set;
        mcp.obj = this;
        return true;
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x52F7AA6C19BEEAD6LL, NAMSTR(s_sys_ss19beead6, "addAttribute")) {
        mcp.ci = &c_SimpleXMLElement::ci_addattribute;
        mcp.obj = this;
        return true;
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x61D11ECEF4404498LL, NAMSTR(s_sys_ss0bbfbb68, "offsetGet")) {
        mcp.ci = &c_SimpleXMLElement::ci_offsetget;
        mcp.obj = this;
        return true;
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x0817454F196A9A1BLL, NAMSTR(s_sys_ss196a9a1b, "xpath")) {
        mcp.ci = &c_SimpleXMLElement::ci_xpath;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x04FB7028C9A2079BLL, NAMSTR(s_sys_ss365df865, "__unset")) {
        mcp.ci = &c_SimpleXMLElement::ci___unset;
        mcp.obj = this;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4B65E1A09A33F21DLL, NAMSTR(s_sys_ss65cc0de3, "attributes")) {
        mcp.ci = &c_SimpleXMLElement::ci_attributes;
        mcp.obj = this;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SimpleXMLElement::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        mcp.ci = &c_SimpleXMLElement::ci_getname;
        mcp.obj = this;
        return true;
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x6D9D75B7E3B40FA6LL, NAMSTR(s_sys_ss1c4bf05a, "getNamespaces")) {
        mcp.ci = &c_SimpleXMLElement::ci_getnamespaces;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x5C09D9345FD864A6LL, NAMSTR(s_sys_ss5fd864a6, "asXML")) {
        mcp.ci = &c_SimpleXMLElement::ci_asxml;
        mcp.obj = this;
        return true;
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x2B299E949E2E82ADLL, NAMSTR(s_sys_ss61d17d53, "children")) {
        mcp.ci = &c_SimpleXMLElement::ci_children;
        mcp.obj = this;
        return true;
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x4FE08FDDAE2178EELL, NAMSTR(s_sys_ss51de8712, "__isset")) {
        mcp.ci = &c_SimpleXMLElement::ci___isset;
        mcp.obj = this;
        return true;
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x0D08AA5F0B2F34F1LL, NAMSTR(s_sys_ss0b2f34f1, "getDocNamespaces")) {
        mcp.ci = &c_SimpleXMLElement::ci_getdocnamespaces;
        mcp.obj = this;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SimpleXMLElement::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x0957F693A48AF738LL, NAMSTR(s_sys_ss5b7508c8, "offsetSet")) {
        mcp.ci = &c_SimpleXMLElement::ci_offsetset;
        mcp.obj = this;
        return true;
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x08329980E6369ABALL, NAMSTR(s_sys_ss19c96546, "offsetUnset")) {
        mcp.ci = &c_SimpleXMLElement::ci_offsetunset;
        mcp.obj = this;
        return true;
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x3FE8F6937854F83DLL, NAMSTR(s_sys_ss7854f83d, "registerXPathNamespace")) {
        mcp.ci = &c_SimpleXMLElement::ci_registerxpathnamespace;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_SimpleXMLElement *c_SimpleXMLElement::create(String a0, int64 a1, bool a2, String a3, bool a4) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4);
  return this;
}
ObjectData *c_SimpleXMLElement::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 5) throw_wrong_arguments("__construct", count, 1, 5, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1, arg2, arg3, arg4));
    } while (false);
  }
  return this;
}
void c_SimpleXMLElement::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) throw_wrong_arguments("__construct", count, 1, 5, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2, arg3, arg4));
  } while (false);
}
void c_SimpleXMLElement::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SimpleXMLElement::ci___construct;
  mcp.obj = this;
}
void c_SimpleXMLElement::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) throw_wrong_arguments("__construct", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else (t___construct(a0, a1, a2, a3, a4), null);
}
struct ObjectStaticCallbacks cw_SimpleXMLElement = {
  c_SimpleXMLElement::os_getInit,
  c_SimpleXMLElement::os_get,
  c_SimpleXMLElement::os_lval,
  c_SimpleXMLElement::os_invoke,
  c_SimpleXMLElement::os_constant,
  c_SimpleXMLElement::os_get_call_info
};
Object co_Memcache(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_Memcache)())->dynCreate(params, init));
}
Object coo_Memcache() {
  Object r(NEW(c_Memcache)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Memcache
Variant c_Memcache::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_Memcache
Variant c_Memcache::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Memcache
Variant &c_Memcache::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_Memcache
void c_Memcache::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_Memcache
void c_Memcache::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_Memcache
Variant * c_Memcache::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Memcache
Variant * c_Memcache::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Memcache
Variant * c_Memcache::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_Memcache
Variant c_Memcache::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_Memcache
IMPLEMENT_CLASS(Memcache)
void c_Memcache::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_Memcache::cloneImpl() {
  c_Memcache *obj = NEW(c_Memcache)();
  cloneSet(obj);
  return obj;
}
void c_Memcache::cloneSet(c_Memcache *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_Memcache::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x42FAC655280A6146LL, NAMSTR(s_sys_ss280a6146, "replace")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_replace(a0, a1));
        else if (count == 3) return (t_replace(a0, a1, a2));
        else return (t_replace(a0, a1, a2, a3));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x39099707DF7945C7LL, NAMSTR(s_sys_ss2086ba39, "increment")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_increment(a0));
        else return (t_increment(a0, a1));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x3BF3710A1661DE0BLL, NAMSTR(s_sys_ss1661de0b, "setoptimeout")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setoptimeout(a0));
      }
      HASH_GUARD_LITSTR(0x15D34462FC79458BLL, NAMSTR(s_sys_ss0386ba75, "add")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_add(a0, a1));
        else if (count == 3) return (t_add(a0, a1, a2));
        else return (t_add(a0, a1, a2, a3));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x710DE893BB376C4FLL, NAMSTR(s_sys_ss44c893b1, "getserverstatus")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_getserverstatus(a0));
        else return (t_getserverstatus(a0, a1));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x030429D528A8EA92LL, NAMSTR(s_sys_ss28a8ea92, "setcompressthreshold")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_setcompressthreshold(a0));
        else return (t_setcompressthreshold(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x1C660E5BFA6F55D3LL, NAMSTR(s_sys_ss0590aa2d, "delete")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_delete(a0));
        else return (t_delete(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x7521E8833BE3D316LL, NAMSTR(s_sys_ss3be3d316_1, "getversion")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getversion());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x1CCDC4317CE59BD9LL, NAMSTR(s_sys_ss7ce59bd9, "getstats")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getstats());
        else if (count == 1) return (t_getstats(a0));
        else if (count == 2) return (t_getstats(a0, a1));
        else return (t_getstats(a0, a1, a2));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x2A733FC12BA4C1DALL, NAMSTR(s_sys_ss2ba4c1da, "decrement")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_decrement(a0));
        else return (t_decrement(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x399A6427C2185621LL, NAMSTR(s_sys_ss3de7a9df, "set")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_set(a0, a1));
        else if (count == 3) return (t_set(a0, a1, a2));
        else return (t_set(a0, a1, a2, a3));
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x4770E54B86BF7765LL, NAMSTR(s_sys_ss7940889b, "getextendedstats")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getextendedstats());
        else if (count == 1) return (t_getextendedstats(a0));
        else if (count == 2) return (t_getextendedstats(a0, a1));
        else return (t_getextendedstats(a0, a1, a2));
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x56CD24186237AAE6LL, NAMSTR(s_sys_ss6237aae6, "addserver")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        Variant a6;
        Variant a7;
        Variant a8;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a6 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a7 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a8 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addserver(a0));
        else if (count == 2) return (t_addserver(a0, a1));
        else if (count == 3) return (t_addserver(a0, a1, a2));
        else if (count == 4) return (t_addserver(a0, a1, a2, a3));
        else if (count == 5) return (t_addserver(a0, a1, a2, a3, a4));
        else if (count == 6) return (t_addserver(a0, a1, a2, a3, a4, a5));
        else if (count == 7) return (t_addserver(a0, a1, a2, a3, a4, a5, a6));
        else if (count == 8) return (t_addserver(a0, a1, a2, a3, a4, a5, a6, a7));
        else return (t_addserver(a0, a1, a2, a3, a4, a5, a6, a7, a8));
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x25DCCC35D69AD828LL, NAMSTR(s_sys_ss296527d8, "get")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_get(a0));
        else return (t_get(a0, ref(a1)));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x742B441E13CD7279LL, NAMSTR(s_sys_ss13cd7279, "pconnect")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_pconnect(a0));
        else if (count == 2) return (t_pconnect(a0, a1));
        else if (count == 3) return (t_pconnect(a0, a1, a2));
        else return (t_pconnect(a0, a1, a2, a3));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss24ffa186, "flush")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_flush());
        else return (t_flush(a0));
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x1780351E8EFF92BDLL, NAMSTR(s_sys_ss71006d43, "setserverparams")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_setserverparams(a0));
        else if (count == 2) return (t_setserverparams(a0, a1));
        else if (count == 3) return (t_setserverparams(a0, a1, a2));
        else if (count == 4) return (t_setserverparams(a0, a1, a2, a3));
        else if (count == 5) return (t_setserverparams(a0, a1, a2, a3, a4));
        else return (t_setserverparams(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x7032C660AD16D7FELL, NAMSTR(s_sys_ss52e92802, "connect")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_connect(a0));
        else if (count == 2) return (t_connect(a0, a1));
        else if (count == 3) return (t_connect(a0, a1, a2));
        else return (t_connect(a0, a1, a2, a3));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_Memcache::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_Memcache::ci_addserver((void*)&c_Memcache::i_addserver, (void*)&c_Memcache::ifa_addserver, 9, 0, 0x0000000000000000LL);
CallInfo c_Memcache::ci_set((void*)&c_Memcache::i_set, (void*)&c_Memcache::ifa_set, 4, 0, 0x0000000000000000LL);
CallInfo c_Memcache::ci_setserverparams((void*)&c_Memcache::i_setserverparams, (void*)&c_Memcache::ifa_setserverparams, 6, 0, 0x0000000000000000LL);
CallInfo c_Memcache::ci___destruct((void*)&c_Memcache::i___destruct, (void*)&c_Memcache::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_Memcache::ci___construct((void*)&c_Memcache::i___construct, (void*)&c_Memcache::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_Memcache::ci_increment((void*)&c_Memcache::i_increment, (void*)&c_Memcache::ifa_increment, 2, 0, 0x0000000000000000LL);
CallInfo c_Memcache::ci_decrement((void*)&c_Memcache::i_decrement, (void*)&c_Memcache::ifa_decrement, 2, 0, 0x0000000000000000LL);
CallInfo c_Memcache::ci_getstats((void*)&c_Memcache::i_getstats, (void*)&c_Memcache::ifa_getstats, 3, 0, 0x0000000000000000LL);
CallInfo c_Memcache::ci_getserverstatus((void*)&c_Memcache::i_getserverstatus, (void*)&c_Memcache::ifa_getserverstatus, 2, 0, 0x0000000000000000LL);
CallInfo c_Memcache::ci_close((void*)&c_Memcache::i_close, (void*)&c_Memcache::ifa_close, 0, 0, 0x0000000000000000LL);
CallInfo c_Memcache::ci_setoptimeout((void*)&c_Memcache::i_setoptimeout, (void*)&c_Memcache::ifa_setoptimeout, 1, 0, 0x0000000000000000LL);
CallInfo c_Memcache::ci_setcompressthreshold((void*)&c_Memcache::i_setcompressthreshold, (void*)&c_Memcache::ifa_setcompressthreshold, 2, 0, 0x0000000000000000LL);
CallInfo c_Memcache::ci_get((void*)&c_Memcache::i_get, (void*)&c_Memcache::ifa_get, 2, 0, 0x0000000000000002LL);
CallInfo c_Memcache::ci_add((void*)&c_Memcache::i_add, (void*)&c_Memcache::ifa_add, 4, 0, 0x0000000000000000LL);
CallInfo c_Memcache::ci_pconnect((void*)&c_Memcache::i_pconnect, (void*)&c_Memcache::ifa_pconnect, 4, 0, 0x0000000000000000LL);
CallInfo c_Memcache::ci_getversion((void*)&c_Memcache::i_getversion, (void*)&c_Memcache::ifa_getversion, 0, 0, 0x0000000000000000LL);
CallInfo c_Memcache::ci_delete((void*)&c_Memcache::i_delete, (void*)&c_Memcache::ifa_delete, 2, 0, 0x0000000000000000LL);
CallInfo c_Memcache::ci_connect((void*)&c_Memcache::i_connect, (void*)&c_Memcache::ifa_connect, 4, 0, 0x0000000000000000LL);
CallInfo c_Memcache::ci_flush((void*)&c_Memcache::i_flush, (void*)&c_Memcache::ifa_flush, 1, 0, 0x0000000000000000LL);
CallInfo c_Memcache::ci_replace((void*)&c_Memcache::i_replace, (void*)&c_Memcache::ifa_replace, 4, 0, 0x0000000000000000LL);
CallInfo c_Memcache::ci_getextendedstats((void*)&c_Memcache::i_getextendedstats, (void*)&c_Memcache::ifa_getextendedstats, 3, 0, 0x0000000000000000LL);
Variant c_Memcache::i_addserver(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_addserver(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_addserver(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_addserver(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t_addserver(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (self->t_addserver(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (self->t_addserver(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 7) return (self->t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 8) return (self->t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
    CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));
  }
}
Variant c_Memcache::i_set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_set(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_set(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_set(arg0, arg1, arg2, arg3));
  }
}
Variant c_Memcache::i_setserverparams(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_setserverparams(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_setserverparams(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_setserverparams(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t_setserverparams(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (self->t_setserverparams(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setserverparams(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant c_Memcache::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_Memcache::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_Memcache::i_increment(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_increment(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_increment(arg0, arg1));
  }
}
Variant c_Memcache::i_decrement(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_decrement(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_decrement(arg0, arg1));
  }
}
Variant c_Memcache::i_getstats(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_getstats());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_getstats(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_getstats(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getstats(arg0, arg1, arg2));
  }
}
Variant c_Memcache::i_getserverstatus(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_getserverstatus(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getserverstatus(arg0, arg1));
  }
}
Variant c_Memcache::i_close(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("close", 0, 1);
  return (self->t_close());
}
Variant c_Memcache::i_setoptimeout(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setoptimeout(arg0));
  }
}
Variant c_Memcache::i_setcompressthreshold(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_setcompressthreshold(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setcompressthreshold(arg0, arg1));
  }
}
Variant c_Memcache::i_get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_get(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (self->t_get(arg0, arg1));
  }
}
Variant c_Memcache::i_add(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_add(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_add(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_add(arg0, arg1, arg2, arg3));
  }
}
Variant c_Memcache::i_pconnect(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_pconnect(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_pconnect(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_pconnect(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_pconnect(arg0, arg1, arg2, arg3));
  }
}
Variant c_Memcache::i_getversion(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
  return (self->t_getversion());
}
Variant c_Memcache::i_delete(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_delete(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_delete(arg0, arg1));
  }
}
Variant c_Memcache::i_connect(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_connect(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_connect(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_connect(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_connect(arg0, arg1, arg2, arg3));
  }
}
Variant c_Memcache::i_flush(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("flush", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_flush());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_flush(arg0));
  }
}
Variant c_Memcache::i_replace(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_replace(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_replace(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_replace(arg0, arg1, arg2, arg3));
  }
}
Variant c_Memcache::i_getextendedstats(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_getextendedstats());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_getextendedstats(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_getextendedstats(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getextendedstats(arg0, arg1, arg2));
  }
}
Variant c_Memcache::ifa_addserver(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
  if (count <= 1) return (self->t_addserver(a0));
  if (count == 2) return (self->t_addserver(a0, a1));
  if (count == 3) return (self->t_addserver(a0, a1, a2));
  if (count == 4) return (self->t_addserver(a0, a1, a2, a3));
  if (count == 5) return (self->t_addserver(a0, a1, a2, a3, a4));
  return (self->t_addserver(a0, a1, a2, a3, a4, a5));
}
Variant c_Memcache::ifa_set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
  if (count <= 2) return (self->t_set(a0, a1));
  if (count == 3) return (self->t_set(a0, a1, a2));
  return (self->t_set(a0, a1, a2, a3));
}
Variant c_Memcache::ifa_setserverparams(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
  if (count <= 1) return (self->t_setserverparams(a0));
  if (count == 2) return (self->t_setserverparams(a0, a1));
  if (count == 3) return (self->t_setserverparams(a0, a1, a2));
  if (count == 4) return (self->t_setserverparams(a0, a1, a2, a3));
  if (count == 5) return (self->t_setserverparams(a0, a1, a2, a3, a4));
  return (self->t_setserverparams(a0, a1, a2, a3, a4, a5));
}
Variant c_Memcache::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_Memcache::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_Memcache::ifa_increment(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
  if (count <= 1) return (self->t_increment(a0));
  return (self->t_increment(a0, a1));
}
Variant c_Memcache::ifa_decrement(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
  if (count <= 1) return (self->t_decrement(a0));
  return (self->t_decrement(a0, a1));
}
Variant c_Memcache::ifa_getstats(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
  if (count <= 0) return (self->t_getstats());
  if (count == 1) return (self->t_getstats(a0));
  if (count == 2) return (self->t_getstats(a0, a1));
  return (self->t_getstats(a0, a1, a2));
}
Variant c_Memcache::ifa_getserverstatus(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
  if (count <= 1) return (self->t_getserverstatus(a0));
  return (self->t_getserverstatus(a0, a1));
}
Variant c_Memcache::ifa_close(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("close", 0, 1);
  return (self->t_close());
}
Variant c_Memcache::ifa_setoptimeout(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
  return (self->t_setoptimeout(a0));
}
Variant c_Memcache::ifa_setcompressthreshold(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
  if (count <= 1) return (self->t_setcompressthreshold(a0));
  return (self->t_setcompressthreshold(a0, a1));
}
Variant c_Memcache::ifa_get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
  if (count <= 1) return (self->t_get(a0));
  return (self->t_get(a0, ref(a1)));
}
Variant c_Memcache::ifa_add(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
  if (count <= 2) return (self->t_add(a0, a1));
  if (count == 3) return (self->t_add(a0, a1, a2));
  return (self->t_add(a0, a1, a2, a3));
}
Variant c_Memcache::ifa_pconnect(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
  if (count <= 1) return (self->t_pconnect(a0));
  if (count == 2) return (self->t_pconnect(a0, a1));
  if (count == 3) return (self->t_pconnect(a0, a1, a2));
  return (self->t_pconnect(a0, a1, a2, a3));
}
Variant c_Memcache::ifa_getversion(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
  return (self->t_getversion());
}
Variant c_Memcache::ifa_delete(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
  if (count <= 1) return (self->t_delete(a0));
  return (self->t_delete(a0, a1));
}
Variant c_Memcache::ifa_connect(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
  if (count <= 1) return (self->t_connect(a0));
  if (count == 2) return (self->t_connect(a0, a1));
  if (count == 3) return (self->t_connect(a0, a1, a2));
  return (self->t_connect(a0, a1, a2, a3));
}
Variant c_Memcache::ifa_flush(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("flush", 1, 1);
  if (count <= 0) return (self->t_flush());
  return (self->t_flush(a0));
}
Variant c_Memcache::ifa_replace(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
  if (count <= 2) return (self->t_replace(a0, a1));
  if (count == 3) return (self->t_replace(a0, a1, a2));
  return (self->t_replace(a0, a1, a2, a3));
}
Variant c_Memcache::ifa_getextendedstats(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
  if (count <= 0) return (self->t_getextendedstats());
  if (count == 1) return (self->t_getextendedstats(a0));
  if (count == 2) return (self->t_getextendedstats(a0, a1));
  return (self->t_getextendedstats(a0, a1, a2));
}
bool c_Memcache::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        mcp.ci = &c_Memcache::ci_close;
        return true;
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x42FAC655280A6146LL, NAMSTR(s_sys_ss280a6146, "replace")) {
        mcp.ci = &c_Memcache::ci_replace;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x39099707DF7945C7LL, NAMSTR(s_sys_ss2086ba39, "increment")) {
        mcp.ci = &c_Memcache::ci_increment;
        return true;
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x3BF3710A1661DE0BLL, NAMSTR(s_sys_ss1661de0b, "setoptimeout")) {
        mcp.ci = &c_Memcache::ci_setoptimeout;
        return true;
      }
      HASH_GUARD_LITSTR(0x15D34462FC79458BLL, NAMSTR(s_sys_ss0386ba75, "add")) {
        mcp.ci = &c_Memcache::ci_add;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x710DE893BB376C4FLL, NAMSTR(s_sys_ss44c893b1, "getserverstatus")) {
        mcp.ci = &c_Memcache::ci_getserverstatus;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x030429D528A8EA92LL, NAMSTR(s_sys_ss28a8ea92, "setcompressthreshold")) {
        mcp.ci = &c_Memcache::ci_setcompressthreshold;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x1C660E5BFA6F55D3LL, NAMSTR(s_sys_ss0590aa2d, "delete")) {
        mcp.ci = &c_Memcache::ci_delete;
        return true;
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x7521E8833BE3D316LL, NAMSTR(s_sys_ss3be3d316_1, "getversion")) {
        mcp.ci = &c_Memcache::ci_getversion;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x1CCDC4317CE59BD9LL, NAMSTR(s_sys_ss7ce59bd9, "getstats")) {
        mcp.ci = &c_Memcache::ci_getstats;
        return true;
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x2A733FC12BA4C1DALL, NAMSTR(s_sys_ss2ba4c1da, "decrement")) {
        mcp.ci = &c_Memcache::ci_decrement;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_Memcache::ci___construct;
        return true;
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x399A6427C2185621LL, NAMSTR(s_sys_ss3de7a9df, "set")) {
        mcp.ci = &c_Memcache::ci_set;
        return true;
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x4770E54B86BF7765LL, NAMSTR(s_sys_ss7940889b, "getextendedstats")) {
        mcp.ci = &c_Memcache::ci_getextendedstats;
        return true;
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x56CD24186237AAE6LL, NAMSTR(s_sys_ss6237aae6, "addserver")) {
        mcp.ci = &c_Memcache::ci_addserver;
        return true;
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x25DCCC35D69AD828LL, NAMSTR(s_sys_ss296527d8, "get")) {
        mcp.ci = &c_Memcache::ci_get;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_Memcache::ci___destruct;
        return true;
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x742B441E13CD7279LL, NAMSTR(s_sys_ss13cd7279, "pconnect")) {
        mcp.ci = &c_Memcache::ci_pconnect;
        return true;
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss24ffa186, "flush")) {
        mcp.ci = &c_Memcache::ci_flush;
        return true;
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x1780351E8EFF92BDLL, NAMSTR(s_sys_ss71006d43, "setserverparams")) {
        mcp.ci = &c_Memcache::ci_setserverparams;
        return true;
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x7032C660AD16D7FELL, NAMSTR(s_sys_ss52e92802, "connect")) {
        mcp.ci = &c_Memcache::ci_connect;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_Memcache::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        mcp.ci = &c_Memcache::ci_close;
        mcp.obj = this;
        return true;
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x42FAC655280A6146LL, NAMSTR(s_sys_ss280a6146, "replace")) {
        mcp.ci = &c_Memcache::ci_replace;
        mcp.obj = this;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x39099707DF7945C7LL, NAMSTR(s_sys_ss2086ba39, "increment")) {
        mcp.ci = &c_Memcache::ci_increment;
        mcp.obj = this;
        return true;
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x3BF3710A1661DE0BLL, NAMSTR(s_sys_ss1661de0b, "setoptimeout")) {
        mcp.ci = &c_Memcache::ci_setoptimeout;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x15D34462FC79458BLL, NAMSTR(s_sys_ss0386ba75, "add")) {
        mcp.ci = &c_Memcache::ci_add;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x710DE893BB376C4FLL, NAMSTR(s_sys_ss44c893b1, "getserverstatus")) {
        mcp.ci = &c_Memcache::ci_getserverstatus;
        mcp.obj = this;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x030429D528A8EA92LL, NAMSTR(s_sys_ss28a8ea92, "setcompressthreshold")) {
        mcp.ci = &c_Memcache::ci_setcompressthreshold;
        mcp.obj = this;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x1C660E5BFA6F55D3LL, NAMSTR(s_sys_ss0590aa2d, "delete")) {
        mcp.ci = &c_Memcache::ci_delete;
        mcp.obj = this;
        return true;
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x7521E8833BE3D316LL, NAMSTR(s_sys_ss3be3d316_1, "getversion")) {
        mcp.ci = &c_Memcache::ci_getversion;
        mcp.obj = this;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x1CCDC4317CE59BD9LL, NAMSTR(s_sys_ss7ce59bd9, "getstats")) {
        mcp.ci = &c_Memcache::ci_getstats;
        mcp.obj = this;
        return true;
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x2A733FC12BA4C1DALL, NAMSTR(s_sys_ss2ba4c1da, "decrement")) {
        mcp.ci = &c_Memcache::ci_decrement;
        mcp.obj = this;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_Memcache::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x399A6427C2185621LL, NAMSTR(s_sys_ss3de7a9df, "set")) {
        mcp.ci = &c_Memcache::ci_set;
        mcp.obj = this;
        return true;
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x4770E54B86BF7765LL, NAMSTR(s_sys_ss7940889b, "getextendedstats")) {
        mcp.ci = &c_Memcache::ci_getextendedstats;
        mcp.obj = this;
        return true;
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x56CD24186237AAE6LL, NAMSTR(s_sys_ss6237aae6, "addserver")) {
        mcp.ci = &c_Memcache::ci_addserver;
        mcp.obj = this;
        return true;
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x25DCCC35D69AD828LL, NAMSTR(s_sys_ss296527d8, "get")) {
        mcp.ci = &c_Memcache::ci_get;
        mcp.obj = this;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_Memcache::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x742B441E13CD7279LL, NAMSTR(s_sys_ss13cd7279, "pconnect")) {
        mcp.ci = &c_Memcache::ci_pconnect;
        mcp.obj = this;
        return true;
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss24ffa186, "flush")) {
        mcp.ci = &c_Memcache::ci_flush;
        mcp.obj = this;
        return true;
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x1780351E8EFF92BDLL, NAMSTR(s_sys_ss71006d43, "setserverparams")) {
        mcp.ci = &c_Memcache::ci_setserverparams;
        mcp.obj = this;
        return true;
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x7032C660AD16D7FELL, NAMSTR(s_sys_ss52e92802, "connect")) {
        mcp.ci = &c_Memcache::ci_connect;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_Memcache *c_Memcache::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_Memcache::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_Memcache::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_Memcache::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_Memcache::ci___construct;
  mcp.obj = this;
}
void c_Memcache::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_Memcache = {
  c_Memcache::os_getInit,
  c_Memcache::os_get,
  c_Memcache::os_lval,
  c_Memcache::os_invoke,
  c_Memcache::os_constant,
  c_Memcache::os_get_call_info
};
Object co_DOMProcessingInstruction(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMProcessingInstruction)())->dynCreate(params, init));
}
Object coo_DOMProcessingInstruction() {
  Object r(NEW(c_DOMProcessingInstruction)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMProcessingInstruction
Variant c_DOMProcessingInstruction::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMProcessingInstruction
Variant c_DOMProcessingInstruction::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMProcessingInstruction
Variant &c_DOMProcessingInstruction::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMProcessingInstruction
void c_DOMProcessingInstruction::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMProcessingInstruction
void c_DOMProcessingInstruction::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMProcessingInstruction
Variant * c_DOMProcessingInstruction::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMProcessingInstruction
Variant * c_DOMProcessingInstruction::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMProcessingInstruction
Variant * c_DOMProcessingInstruction::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMProcessingInstruction
Variant c_DOMProcessingInstruction::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMProcessingInstruction
IMPLEMENT_CLASS(DOMProcessingInstruction)
void c_DOMProcessingInstruction::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMProcessingInstruction::cloneImpl() {
  c_DOMProcessingInstruction *obj = NEW(c_DOMProcessingInstruction)();
  cloneSet(obj);
  return obj;
}
void c_DOMProcessingInstruction::cloneSet(c_DOMProcessingInstruction *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMProcessingInstruction::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMProcessingInstruction::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMProcessingInstruction::ci___destruct((void*)&c_DOMProcessingInstruction::i___destruct, (void*)&c_DOMProcessingInstruction::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMProcessingInstruction::ci___set((void*)&c_DOMProcessingInstruction::i___set, (void*)&c_DOMProcessingInstruction::ifa___set, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMProcessingInstruction::ci___construct((void*)&c_DOMProcessingInstruction::i___construct, (void*)&c_DOMProcessingInstruction::ifa___construct, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMProcessingInstruction::ci___get((void*)&c_DOMProcessingInstruction::i___get, (void*)&c_DOMProcessingInstruction::ifa___get, 1, 0, 0x0000000000000000LL);
Variant c_DOMProcessingInstruction::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMProcessingInstruction *self = NULL;
  p_DOMProcessingInstruction pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMProcessingInstruction*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMProcessingInstruction::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMProcessingInstruction *self = NULL;
  p_DOMProcessingInstruction pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMProcessingInstruction*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMProcessingInstruction::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMProcessingInstruction *self = NULL;
  p_DOMProcessingInstruction pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMProcessingInstruction*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_DOMProcessingInstruction::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMProcessingInstruction *self = NULL;
  p_DOMProcessingInstruction pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMProcessingInstruction*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMProcessingInstruction::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMProcessingInstruction *self = NULL;
  p_DOMProcessingInstruction pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMProcessingInstruction*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMProcessingInstruction::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMProcessingInstruction *self = NULL;
  p_DOMProcessingInstruction pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMProcessingInstruction*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMProcessingInstruction::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMProcessingInstruction *self = NULL;
  p_DOMProcessingInstruction pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMProcessingInstruction*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
  if (count <= 1) return (self->t___construct(a0), null);
  return (self->t___construct(a0, a1), null);
}
Variant c_DOMProcessingInstruction::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMProcessingInstruction *self = NULL;
  p_DOMProcessingInstruction pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMProcessingInstruction*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
bool c_DOMProcessingInstruction::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMProcessingInstruction::ci___destruct;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMProcessingInstruction::ci___set;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMProcessingInstruction::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMProcessingInstruction::ci___get;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMProcessingInstruction::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMProcessingInstruction::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMProcessingInstruction::ci___set;
        mcp.obj = this;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMProcessingInstruction::ci___construct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMProcessingInstruction::ci___get;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_get_call_info(mcp, hash);
}
c_DOMProcessingInstruction *c_DOMProcessingInstruction::create(String a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_DOMProcessingInstruction::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_DOMProcessingInstruction::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_DOMProcessingInstruction::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMProcessingInstruction::ci___construct;
  mcp.obj = this;
}
void c_DOMProcessingInstruction::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
struct ObjectStaticCallbacks cw_DOMProcessingInstruction = {
  c_DOMProcessingInstruction::os_getInit,
  c_DOMProcessingInstruction::os_get,
  c_DOMProcessingInstruction::os_lval,
  c_DOMProcessingInstruction::os_invoke,
  c_DOMProcessingInstruction::os_constant,
  c_DOMProcessingInstruction::os_get_call_info
};
Object co_PDOStatement(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_PDOStatement)())->dynCreate(params, init));
}
Object coo_PDOStatement() {
  Object r(NEW(c_PDOStatement)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_PDOStatement
Variant c_PDOStatement::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_PDOStatement
Variant c_PDOStatement::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_PDOStatement
Variant &c_PDOStatement::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_PDOStatement
void c_PDOStatement::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_PDOStatement
void c_PDOStatement::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PDOStatement
Variant * c_PDOStatement::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_PDOStatement
Variant * c_PDOStatement::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_PDOStatement
Variant * c_PDOStatement::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_PDOStatement
Variant c_PDOStatement::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_PDOStatement
IMPLEMENT_CLASS(PDOStatement)
void c_PDOStatement::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_PDOStatement::cloneImpl() {
  c_PDOStatement *obj = NEW(c_PDOStatement)();
  cloneSet(obj);
  return obj;
}
void c_PDOStatement::cloneSet(c_PDOStatement *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_PDOStatement::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x5740729B65EB8E41LL, NAMSTR(s_sys_ss65eb8e41, "fetchall")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchall());
        else if (count == 1) return (t_fetchall(a0));
        else if (count == 2) return (t_fetchall(a0, a1));
        else return (t_fetchall(a0, a1, a2));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss3628e403, "bindvalue")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindvalue(a0, a1));
        else return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x75A2E23098C65C05LL, NAMSTR(s_sys_ss6739a3fb, "closecursor")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_closecursor());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss2372f2c7, "errorcode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss14a88eb2, "execute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_execute());
        else return (t_execute(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x32A381ECDC91918FLL, NAMSTR(s_sys_ss236e6e71, "columncount")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columncount());
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x31A8917EC4F2A252LL, NAMSTR(s_sys_ss3b0d5dae, "nextrowset")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_nextrowset());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1ba41696, "bindparam")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        else if (count == 3) return (t_bindparam(a0, ref(a1), a2));
        else if (count == 4) return (t_bindparam(a0, ref(a1), a2, a3));
        else return (t_bindparam(a0, ref(a1), a2, a3, a4));
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x5C38814410C5FFD9LL, NAMSTR(s_sys_ss10c5ffd9, "fetchcolumn")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchcolumn());
        else return (t_fetchcolumn(a0));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0D43A7148903299ALL, NAMSTR(s_sys_ss76fcd666, "rowcount")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rowcount());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss55f7a324, "__wakeup")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___wakeup());
      }
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x1C87AD14A095219DLL, NAMSTR(s_sys_ss5f6ade63, "bindcolumn")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindcolumn(a0, ref(a1)));
        else if (count == 3) return (t_bindcolumn(a0, ref(a1), a2));
        else if (count == 4) return (t_bindcolumn(a0, ref(a1), a2, a3));
        else return (t_bindcolumn(a0, ref(a1), a2, a3, a4));
      }
      HASH_GUARD_LITSTR(0x0E1814AA3327229DLL, NAMSTR(s_sys_ss3327229d, "fetchobject")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchobject());
        else if (count == 1) return (t_fetchobject(a0));
        else return (t_fetchobject(a0, a1));
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss7f04605e, "errorinfo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x78C9BF8620136861LL, NAMSTR(s_sys_ss20136861, "setfetchmode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_setfetchmode(count, a0));
        return (t_setfetchmode(count, a0,vargs));
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x699F5A1E3BD7B2A2LL, NAMSTR(s_sys_ss3bd7b2a2, "debugdumpparams")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_debugdumpparams());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss25243fd3, "__sleep")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___sleep());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x5B6B980006E717FBLL, NAMSTR(s_sys_ss06e717fb, "getcolumnmeta")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcolumnmeta(a0));
      }
      HASH_GUARD_LITSTR(0x5E82B850BB90B0FBLL, NAMSTR(s_sys_ss446f4f05, "fetch")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetch());
        else if (count == 1) return (t_fetch(a0));
        else if (count == 2) return (t_fetch(a0, a1));
        else return (t_fetch(a0, a1, a2));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_PDOStatement::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_PDOStatement::ci_next((void*)&c_PDOStatement::i_next, (void*)&c_PDOStatement::ifa_next, 0, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_errorcode((void*)&c_PDOStatement::i_errorcode, (void*)&c_PDOStatement::ifa_errorcode, 0, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_getattribute((void*)&c_PDOStatement::i_getattribute, (void*)&c_PDOStatement::ifa_getattribute, 1, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_fetchcolumn((void*)&c_PDOStatement::i_fetchcolumn, (void*)&c_PDOStatement::ifa_fetchcolumn, 1, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_key((void*)&c_PDOStatement::i_key, (void*)&c_PDOStatement::ifa_key, 0, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_getcolumnmeta((void*)&c_PDOStatement::i_getcolumnmeta, (void*)&c_PDOStatement::ifa_getcolumnmeta, 1, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_valid((void*)&c_PDOStatement::i_valid, (void*)&c_PDOStatement::ifa_valid, 0, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_nextrowset((void*)&c_PDOStatement::i_nextrowset, (void*)&c_PDOStatement::ifa_nextrowset, 0, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci___destruct((void*)&c_PDOStatement::i___destruct, (void*)&c_PDOStatement::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci___wakeup((void*)&c_PDOStatement::i___wakeup, (void*)&c_PDOStatement::ifa___wakeup, 0, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci___construct((void*)&c_PDOStatement::i___construct, (void*)&c_PDOStatement::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_bindcolumn((void*)&c_PDOStatement::i_bindcolumn, (void*)&c_PDOStatement::ifa_bindcolumn, 5, 0, 0x0000000000000002LL);
CallInfo c_PDOStatement::ci_setfetchmode((void*)&c_PDOStatement::i_setfetchmode, (void*)&c_PDOStatement::ifa_setfetchmode, 1, 1, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_columncount((void*)&c_PDOStatement::i_columncount, (void*)&c_PDOStatement::ifa_columncount, 0, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_bindparam((void*)&c_PDOStatement::i_bindparam, (void*)&c_PDOStatement::ifa_bindparam, 5, 0, 0x0000000000000002LL);
CallInfo c_PDOStatement::ci_closecursor((void*)&c_PDOStatement::i_closecursor, (void*)&c_PDOStatement::ifa_closecursor, 0, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_setattribute((void*)&c_PDOStatement::i_setattribute, (void*)&c_PDOStatement::ifa_setattribute, 2, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_rowcount((void*)&c_PDOStatement::i_rowcount, (void*)&c_PDOStatement::ifa_rowcount, 0, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_execute((void*)&c_PDOStatement::i_execute, (void*)&c_PDOStatement::ifa_execute, 1, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_fetchobject((void*)&c_PDOStatement::i_fetchobject, (void*)&c_PDOStatement::ifa_fetchobject, 2, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_bindvalue((void*)&c_PDOStatement::i_bindvalue, (void*)&c_PDOStatement::ifa_bindvalue, 3, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_fetchall((void*)&c_PDOStatement::i_fetchall, (void*)&c_PDOStatement::ifa_fetchall, 3, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_fetch((void*)&c_PDOStatement::i_fetch, (void*)&c_PDOStatement::ifa_fetch, 3, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_current((void*)&c_PDOStatement::i_current, (void*)&c_PDOStatement::ifa_current, 0, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_errorinfo((void*)&c_PDOStatement::i_errorinfo, (void*)&c_PDOStatement::ifa_errorinfo, 0, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci___sleep((void*)&c_PDOStatement::i___sleep, (void*)&c_PDOStatement::ifa___sleep, 0, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_debugdumpparams((void*)&c_PDOStatement::i_debugdumpparams, (void*)&c_PDOStatement::ifa_debugdumpparams, 0, 0, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_rewind((void*)&c_PDOStatement::i_rewind, (void*)&c_PDOStatement::ifa_rewind, 0, 0, 0x0000000000000000LL);
Variant c_PDOStatement::i_next(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("next", 0, 1);
  return (self->t_next());
}
Variant c_PDOStatement::i_errorcode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
  return (self->t_errorcode());
}
Variant c_PDOStatement::i_getattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getattribute(arg0));
  }
}
Variant c_PDOStatement::i_fetchcolumn(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_fetchcolumn());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_fetchcolumn(arg0));
  }
}
Variant c_PDOStatement::i_key(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("key", 0, 1);
  return (self->t_key());
}
Variant c_PDOStatement::i_getcolumnmeta(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getcolumnmeta(arg0));
  }
}
Variant c_PDOStatement::i_valid(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("valid", 0, 1);
  return (self->t_valid());
}
Variant c_PDOStatement::i_nextrowset(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
  return (self->t_nextrowset());
}
Variant c_PDOStatement::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_PDOStatement::i___wakeup(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
  return (self->t___wakeup());
}
Variant c_PDOStatement::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_PDOStatement::i_bindcolumn(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_bindcolumn(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_bindcolumn(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t_bindcolumn(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_bindcolumn(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant c_PDOStatement::i_setfetchmode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_setfetchmode(count, arg0));
    return (self->t_setfetchmode(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant c_PDOStatement::i_columncount(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
  return (self->t_columncount());
}
Variant c_PDOStatement::i_bindparam(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_bindparam(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_bindparam(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t_bindparam(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_bindparam(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant c_PDOStatement::i_closecursor(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
  return (self->t_closecursor());
}
Variant c_PDOStatement::i_setattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setattribute(arg0, arg1));
  }
}
Variant c_PDOStatement::i_rowcount(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
  return (self->t_rowcount());
}
Variant c_PDOStatement::i_execute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("execute", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_execute());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_execute(arg0));
  }
}
Variant c_PDOStatement::i_fetchobject(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_fetchobject());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_fetchobject(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_fetchobject(arg0, arg1));
  }
}
Variant c_PDOStatement::i_bindvalue(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_bindvalue(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_bindvalue(arg0, arg1, arg2));
  }
}
Variant c_PDOStatement::i_fetchall(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_fetchall());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_fetchall(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_fetchall(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_fetchall(arg0, arg1, arg2));
  }
}
Variant c_PDOStatement::i_fetch(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_fetch());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_fetch(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_fetch(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_fetch(arg0, arg1, arg2));
  }
}
Variant c_PDOStatement::i_current(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("current", 0, 1);
  return (self->t_current());
}
Variant c_PDOStatement::i_errorinfo(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
  return (self->t_errorinfo());
}
Variant c_PDOStatement::i___sleep(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
  return (self->t___sleep());
}
Variant c_PDOStatement::i_debugdumpparams(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
  return (self->t_debugdumpparams());
}
Variant c_PDOStatement::i_rewind(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
  return (self->t_rewind());
}
Variant c_PDOStatement::ifa_next(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("next", 0, 1);
  return (self->t_next());
}
Variant c_PDOStatement::ifa_errorcode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
  return (self->t_errorcode());
}
Variant c_PDOStatement::ifa_getattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
  return (self->t_getattribute(a0));
}
Variant c_PDOStatement::ifa_fetchcolumn(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
  if (count <= 0) return (self->t_fetchcolumn());
  return (self->t_fetchcolumn(a0));
}
Variant c_PDOStatement::ifa_key(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("key", 0, 1);
  return (self->t_key());
}
Variant c_PDOStatement::ifa_getcolumnmeta(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
  return (self->t_getcolumnmeta(a0));
}
Variant c_PDOStatement::ifa_valid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("valid", 0, 1);
  return (self->t_valid());
}
Variant c_PDOStatement::ifa_nextrowset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
  return (self->t_nextrowset());
}
Variant c_PDOStatement::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_PDOStatement::ifa___wakeup(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
  return (self->t___wakeup());
}
Variant c_PDOStatement::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_PDOStatement::ifa_bindcolumn(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
  if (count <= 2) return (self->t_bindcolumn(a0, ref(a1)));
  if (count == 3) return (self->t_bindcolumn(a0, ref(a1), a2));
  if (count == 4) return (self->t_bindcolumn(a0, ref(a1), a2, a3));
  return (self->t_bindcolumn(a0, ref(a1), a2, a3, a4));
}
Variant c_PDOStatement::ifa_setfetchmode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
  if (count <= 1) return (self->t_setfetchmode(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (self->t_setfetchmode(count,a0, params));
}
Variant c_PDOStatement::ifa_columncount(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
  return (self->t_columncount());
}
Variant c_PDOStatement::ifa_bindparam(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
  if (count <= 2) return (self->t_bindparam(a0, ref(a1)));
  if (count == 3) return (self->t_bindparam(a0, ref(a1), a2));
  if (count == 4) return (self->t_bindparam(a0, ref(a1), a2, a3));
  return (self->t_bindparam(a0, ref(a1), a2, a3, a4));
}
Variant c_PDOStatement::ifa_closecursor(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
  return (self->t_closecursor());
}
Variant c_PDOStatement::ifa_setattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
  return (self->t_setattribute(a0, a1));
}
Variant c_PDOStatement::ifa_rowcount(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
  return (self->t_rowcount());
}
Variant c_PDOStatement::ifa_execute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("execute", 1, 1);
  if (count <= 0) return (self->t_execute());
  return (self->t_execute(a0));
}
Variant c_PDOStatement::ifa_fetchobject(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
  if (count <= 0) return (self->t_fetchobject());
  if (count == 1) return (self->t_fetchobject(a0));
  return (self->t_fetchobject(a0, a1));
}
Variant c_PDOStatement::ifa_bindvalue(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
  if (count <= 2) return (self->t_bindvalue(a0, a1));
  return (self->t_bindvalue(a0, a1, a2));
}
Variant c_PDOStatement::ifa_fetchall(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
  if (count <= 0) return (self->t_fetchall());
  if (count == 1) return (self->t_fetchall(a0));
  if (count == 2) return (self->t_fetchall(a0, a1));
  return (self->t_fetchall(a0, a1, a2));
}
Variant c_PDOStatement::ifa_fetch(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
  if (count <= 0) return (self->t_fetch());
  if (count == 1) return (self->t_fetch(a0));
  if (count == 2) return (self->t_fetch(a0, a1));
  return (self->t_fetch(a0, a1, a2));
}
Variant c_PDOStatement::ifa_current(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("current", 0, 1);
  return (self->t_current());
}
Variant c_PDOStatement::ifa_errorinfo(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
  return (self->t_errorinfo());
}
Variant c_PDOStatement::ifa___sleep(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
  return (self->t___sleep());
}
Variant c_PDOStatement::ifa_debugdumpparams(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
  return (self->t_debugdumpparams());
}
Variant c_PDOStatement::ifa_rewind(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
  return (self->t_rewind());
}
bool c_PDOStatement::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x5740729B65EB8E41LL, NAMSTR(s_sys_ss65eb8e41, "fetchall")) {
        mcp.ci = &c_PDOStatement::ci_fetchall;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss3628e403, "bindvalue")) {
        mcp.ci = &c_PDOStatement::ci_bindvalue;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        mcp.ci = &c_PDOStatement::ci_valid;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x75A2E23098C65C05LL, NAMSTR(s_sys_ss6739a3fb, "closecursor")) {
        mcp.ci = &c_PDOStatement::ci_closecursor;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss2372f2c7, "errorcode")) {
        mcp.ci = &c_PDOStatement::ci_errorcode;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        mcp.ci = &c_PDOStatement::ci_setattribute;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss14a88eb2, "execute")) {
        mcp.ci = &c_PDOStatement::ci_execute;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x32A381ECDC91918FLL, NAMSTR(s_sys_ss236e6e71, "columncount")) {
        mcp.ci = &c_PDOStatement::ci_columncount;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        mcp.ci = &c_PDOStatement::ci_key;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x31A8917EC4F2A252LL, NAMSTR(s_sys_ss3b0d5dae, "nextrowset")) {
        mcp.ci = &c_PDOStatement::ci_nextrowset;
        return true;
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1ba41696, "bindparam")) {
        mcp.ci = &c_PDOStatement::ci_bindparam;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x5C38814410C5FFD9LL, NAMSTR(s_sys_ss10c5ffd9, "fetchcolumn")) {
        mcp.ci = &c_PDOStatement::ci_fetchcolumn;
        return true;
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0D43A7148903299ALL, NAMSTR(s_sys_ss76fcd666, "rowcount")) {
        mcp.ci = &c_PDOStatement::ci_rowcount;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss55f7a324, "__wakeup")) {
        mcp.ci = &c_PDOStatement::ci___wakeup;
        return true;
      }
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        mcp.ci = &c_PDOStatement::ci_current;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x1C87AD14A095219DLL, NAMSTR(s_sys_ss5f6ade63, "bindcolumn")) {
        mcp.ci = &c_PDOStatement::ci_bindcolumn;
        return true;
      }
      HASH_GUARD_LITSTR(0x0E1814AA3327229DLL, NAMSTR(s_sys_ss3327229d, "fetchobject")) {
        mcp.ci = &c_PDOStatement::ci_fetchobject;
        return true;
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss7f04605e, "errorinfo")) {
        mcp.ci = &c_PDOStatement::ci_errorinfo;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_PDOStatement::ci___construct;
        return true;
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x78C9BF8620136861LL, NAMSTR(s_sys_ss20136861, "setfetchmode")) {
        mcp.ci = &c_PDOStatement::ci_setfetchmode;
        return true;
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x699F5A1E3BD7B2A2LL, NAMSTR(s_sys_ss3bd7b2a2, "debugdumpparams")) {
        mcp.ci = &c_PDOStatement::ci_debugdumpparams;
        return true;
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        mcp.ci = &c_PDOStatement::ci_getattribute;
        return true;
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        mcp.ci = &c_PDOStatement::ci_rewind;
        return true;
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss25243fd3, "__sleep")) {
        mcp.ci = &c_PDOStatement::ci___sleep;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_PDOStatement::ci___destruct;
        return true;
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        mcp.ci = &c_PDOStatement::ci_next;
        return true;
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x5B6B980006E717FBLL, NAMSTR(s_sys_ss06e717fb, "getcolumnmeta")) {
        mcp.ci = &c_PDOStatement::ci_getcolumnmeta;
        return true;
      }
      HASH_GUARD_LITSTR(0x5E82B850BB90B0FBLL, NAMSTR(s_sys_ss446f4f05, "fetch")) {
        mcp.ci = &c_PDOStatement::ci_fetch;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_PDOStatement::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x5740729B65EB8E41LL, NAMSTR(s_sys_ss65eb8e41, "fetchall")) {
        mcp.ci = &c_PDOStatement::ci_fetchall;
        mcp.obj = this;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss3628e403, "bindvalue")) {
        mcp.ci = &c_PDOStatement::ci_bindvalue;
        mcp.obj = this;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        mcp.ci = &c_PDOStatement::ci_valid;
        mcp.obj = this;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x75A2E23098C65C05LL, NAMSTR(s_sys_ss6739a3fb, "closecursor")) {
        mcp.ci = &c_PDOStatement::ci_closecursor;
        mcp.obj = this;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss2372f2c7, "errorcode")) {
        mcp.ci = &c_PDOStatement::ci_errorcode;
        mcp.obj = this;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        mcp.ci = &c_PDOStatement::ci_setattribute;
        mcp.obj = this;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss14a88eb2, "execute")) {
        mcp.ci = &c_PDOStatement::ci_execute;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x32A381ECDC91918FLL, NAMSTR(s_sys_ss236e6e71, "columncount")) {
        mcp.ci = &c_PDOStatement::ci_columncount;
        mcp.obj = this;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        mcp.ci = &c_PDOStatement::ci_key;
        mcp.obj = this;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x31A8917EC4F2A252LL, NAMSTR(s_sys_ss3b0d5dae, "nextrowset")) {
        mcp.ci = &c_PDOStatement::ci_nextrowset;
        mcp.obj = this;
        return true;
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1ba41696, "bindparam")) {
        mcp.ci = &c_PDOStatement::ci_bindparam;
        mcp.obj = this;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x5C38814410C5FFD9LL, NAMSTR(s_sys_ss10c5ffd9, "fetchcolumn")) {
        mcp.ci = &c_PDOStatement::ci_fetchcolumn;
        mcp.obj = this;
        return true;
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0D43A7148903299ALL, NAMSTR(s_sys_ss76fcd666, "rowcount")) {
        mcp.ci = &c_PDOStatement::ci_rowcount;
        mcp.obj = this;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss55f7a324, "__wakeup")) {
        mcp.ci = &c_PDOStatement::ci___wakeup;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        mcp.ci = &c_PDOStatement::ci_current;
        mcp.obj = this;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x1C87AD14A095219DLL, NAMSTR(s_sys_ss5f6ade63, "bindcolumn")) {
        mcp.ci = &c_PDOStatement::ci_bindcolumn;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x0E1814AA3327229DLL, NAMSTR(s_sys_ss3327229d, "fetchobject")) {
        mcp.ci = &c_PDOStatement::ci_fetchobject;
        mcp.obj = this;
        return true;
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss7f04605e, "errorinfo")) {
        mcp.ci = &c_PDOStatement::ci_errorinfo;
        mcp.obj = this;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_PDOStatement::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x78C9BF8620136861LL, NAMSTR(s_sys_ss20136861, "setfetchmode")) {
        mcp.ci = &c_PDOStatement::ci_setfetchmode;
        mcp.obj = this;
        return true;
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x699F5A1E3BD7B2A2LL, NAMSTR(s_sys_ss3bd7b2a2, "debugdumpparams")) {
        mcp.ci = &c_PDOStatement::ci_debugdumpparams;
        mcp.obj = this;
        return true;
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        mcp.ci = &c_PDOStatement::ci_getattribute;
        mcp.obj = this;
        return true;
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        mcp.ci = &c_PDOStatement::ci_rewind;
        mcp.obj = this;
        return true;
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss25243fd3, "__sleep")) {
        mcp.ci = &c_PDOStatement::ci___sleep;
        mcp.obj = this;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_PDOStatement::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        mcp.ci = &c_PDOStatement::ci_next;
        mcp.obj = this;
        return true;
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x5B6B980006E717FBLL, NAMSTR(s_sys_ss06e717fb, "getcolumnmeta")) {
        mcp.ci = &c_PDOStatement::ci_getcolumnmeta;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x5E82B850BB90B0FBLL, NAMSTR(s_sys_ss446f4f05, "fetch")) {
        mcp.ci = &c_PDOStatement::ci_fetch;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_PDOStatement *c_PDOStatement::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_PDOStatement::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_PDOStatement::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_PDOStatement::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_PDOStatement::ci___construct;
  mcp.obj = this;
}
void c_PDOStatement::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_PDOStatement = {
  c_PDOStatement::os_getInit,
  c_PDOStatement::os_get,
  c_PDOStatement::os_lval,
  c_PDOStatement::os_invoke,
  c_PDOStatement::os_constant,
  c_PDOStatement::os_get_call_info
};
Object co_SoapClient(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SoapClient)())->dynCreate(params, init));
}
Object coo_SoapClient() {
  Object r(NEW(c_SoapClient)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapClient
Variant c_SoapClient::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapClient
Variant c_SoapClient::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapClient
Variant &c_SoapClient::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapClient
void c_SoapClient::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapClient
void c_SoapClient::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SoapClient
Variant * c_SoapClient::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapClient
Variant * c_SoapClient::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapClient
Variant * c_SoapClient::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapClient
Variant c_SoapClient::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapClient
IMPLEMENT_CLASS(SoapClient)
void c_SoapClient::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SoapClient::cloneImpl() {
  c_SoapClient *obj = NEW(c_SoapClient)();
  cloneSet(obj);
  return obj;
}
void c_SoapClient::cloneSet(c_SoapClient *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SoapClient::doCall(Variant v_name, Variant v_arguments, bool fatal) {
  return t___call(v_name, !v_arguments.isNull() ? v_arguments : Variant(Array::Create()));
}
Variant c_SoapClient::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 4:
      HASH_GUARD_LITSTR(0x5C5C1E24A140F6E4LL, NAMSTR(s_sys_ss5ebf091c, "__getlastrequest")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastrequest());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x3648EE7D3B37DE8CLL, NAMSTR(s_sys_ss3b37de8c, "__getlastrequestheaders")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastrequestheaders());
      }
      HASH_GUARD_LITSTR(0x5D73364F53CEEB6CLL, NAMSTR(s_sys_ss53ceeb6c, "__call")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___call(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x1365B3105FC59871LL, NAMSTR(s_sys_ss5fc59871, "__getfunctions")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getfunctions());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x3CA9145031035A54LL, NAMSTR(s_sys_ss31035a54, "__getlastresponse")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastresponse());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x19A26CEC7E8AAEF5LL, NAMSTR(s_sys_ss7e8aaef5, "__dorequest")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 4) return (t___dorequest(a0, a1, a2, a3));
        else return (t___dorequest(a0, a1, a2, a3, a4));
      }
      HASH_GUARD_LITSTR(0x52C6ABACCBFD0C75LL, NAMSTR(s_sys_ss3402f38b, "__setcookie")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___setcookie(a0));
        else return (t___setcookie(a0, a1));
      }
      HASH_GUARD_LITSTR(0x628D398E7604B9D5LL, NAMSTR(s_sys_ss7604b9d5, "__gettypes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___gettypes());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x4A2F89F662050D99LL, NAMSTR(s_sys_ss62050d99, "__soapcall")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___soapcall(a0, a1));
        else if (count == 3) return (t___soapcall(a0, a1, a2));
        else if (count == 4) return (t___soapcall(a0, a1, a2, a3));
        else return (t___soapcall(a0, a1, a2, a3, ref(a4)));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0C94657A58A82CFALL, NAMSTR(s_sys_ss58a82cfa, "__getlastresponseheaders")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastresponseheaders());
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x14842228D5E335BBLL, NAMSTR(s_sys_ss2a1cca45, "__setsoapheaders")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___setsoapheaders());
        else return (t___setsoapheaders(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x232D13904DBC36FFLL, NAMSTR(s_sys_ss4dbc36ff, "__setlocation")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___setlocation());
        else return (t___setlocation(a0));
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SoapClient::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SoapClient::ci___dorequest((void*)&c_SoapClient::i___dorequest, (void*)&c_SoapClient::ifa___dorequest, 5, 0, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___getlastrequest((void*)&c_SoapClient::i___getlastrequest, (void*)&c_SoapClient::ifa___getlastrequest, 0, 0, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___setsoapheaders((void*)&c_SoapClient::i___setsoapheaders, (void*)&c_SoapClient::ifa___setsoapheaders, 1, 0, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___setcookie((void*)&c_SoapClient::i___setcookie, (void*)&c_SoapClient::ifa___setcookie, 2, 0, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___soapcall((void*)&c_SoapClient::i___soapcall, (void*)&c_SoapClient::ifa___soapcall, 5, 0, 0x0000000000000010LL);
CallInfo c_SoapClient::ci___destruct((void*)&c_SoapClient::i___destruct, (void*)&c_SoapClient::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___setlocation((void*)&c_SoapClient::i___setlocation, (void*)&c_SoapClient::ifa___setlocation, 1, 0, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___getlastrequestheaders((void*)&c_SoapClient::i___getlastrequestheaders, (void*)&c_SoapClient::ifa___getlastrequestheaders, 0, 0, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___construct((void*)&c_SoapClient::i___construct, (void*)&c_SoapClient::ifa___construct, 2, 0, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___getfunctions((void*)&c_SoapClient::i___getfunctions, (void*)&c_SoapClient::ifa___getfunctions, 0, 0, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___getlastresponseheaders((void*)&c_SoapClient::i___getlastresponseheaders, (void*)&c_SoapClient::ifa___getlastresponseheaders, 0, 0, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___getlastresponse((void*)&c_SoapClient::i___getlastresponse, (void*)&c_SoapClient::ifa___getlastresponse, 0, 0, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___gettypes((void*)&c_SoapClient::i___gettypes, (void*)&c_SoapClient::ifa___gettypes, 0, 0, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___call((void*)&c_SoapClient::i___call, (void*)&c_SoapClient::ifa___call, 2, 0, 0x0000000000000000LL);
Variant c_SoapClient::i___dorequest(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (self->t___dorequest(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___dorequest(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant c_SoapClient::i___getlastrequest(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
  return (self->t___getlastrequest());
}
Variant c_SoapClient::i___setsoapheaders(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t___setsoapheaders());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___setsoapheaders(arg0));
  }
}
Variant c_SoapClient::i___setcookie(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___setcookie(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___setcookie(arg0, arg1));
  }
}
Variant c_SoapClient::i___soapcall(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t___soapcall(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t___soapcall(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t___soapcall(arg0, arg1, arg2, arg3));
    CVarRef arg4(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (self->t___soapcall(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant c_SoapClient::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapClient::i___setlocation(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t___setlocation());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___setlocation(arg0));
  }
}
Variant c_SoapClient::i___getlastrequestheaders(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
  return (self->t___getlastrequestheaders());
}
Variant c_SoapClient::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_SoapClient::i___getfunctions(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
  return (self->t___getfunctions());
}
Variant c_SoapClient::i___getlastresponseheaders(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
  return (self->t___getlastresponseheaders());
}
Variant c_SoapClient::i___getlastresponse(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
  return (self->t___getlastresponse());
}
Variant c_SoapClient::i___gettypes(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
  return (self->t___gettypes());
}
Variant c_SoapClient::i___call(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___call(arg0, arg1));
  }
}
Variant c_SoapClient::ifa___dorequest(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
  if (count <= 4) return (self->t___dorequest(a0, a1, a2, a3));
  return (self->t___dorequest(a0, a1, a2, a3, a4));
}
Variant c_SoapClient::ifa___getlastrequest(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
  return (self->t___getlastrequest());
}
Variant c_SoapClient::ifa___setsoapheaders(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
  if (count <= 0) return (self->t___setsoapheaders());
  return (self->t___setsoapheaders(a0));
}
Variant c_SoapClient::ifa___setcookie(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
  if (count <= 1) return (self->t___setcookie(a0));
  return (self->t___setcookie(a0, a1));
}
Variant c_SoapClient::ifa___soapcall(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
  if (count <= 2) return (self->t___soapcall(a0, a1));
  if (count == 3) return (self->t___soapcall(a0, a1, a2));
  if (count == 4) return (self->t___soapcall(a0, a1, a2, a3));
  return (self->t___soapcall(a0, a1, a2, a3, ref(a4)));
}
Variant c_SoapClient::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapClient::ifa___setlocation(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
  if (count <= 0) return (self->t___setlocation());
  return (self->t___setlocation(a0));
}
Variant c_SoapClient::ifa___getlastrequestheaders(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
  return (self->t___getlastrequestheaders());
}
Variant c_SoapClient::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
  if (count <= 1) return (self->t___construct(a0), null);
  return (self->t___construct(a0, a1), null);
}
Variant c_SoapClient::ifa___getfunctions(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
  return (self->t___getfunctions());
}
Variant c_SoapClient::ifa___getlastresponseheaders(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
  return (self->t___getlastresponseheaders());
}
Variant c_SoapClient::ifa___getlastresponse(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
  return (self->t___getlastresponse());
}
Variant c_SoapClient::ifa___gettypes(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
  return (self->t___gettypes());
}
Variant c_SoapClient::ifa___call(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
  return (self->t___call(a0, a1));
}
bool c_SoapClient::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 4:
      HASH_GUARD_LITSTR(0x5C5C1E24A140F6E4LL, NAMSTR(s_sys_ss5ebf091c, "__getlastrequest")) {
        mcp.ci = &c_SoapClient::ci___getlastrequest;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x3648EE7D3B37DE8CLL, NAMSTR(s_sys_ss3b37de8c, "__getlastrequestheaders")) {
        mcp.ci = &c_SoapClient::ci___getlastrequestheaders;
        return true;
      }
      HASH_GUARD_LITSTR(0x5D73364F53CEEB6CLL, NAMSTR(s_sys_ss53ceeb6c, "__call")) {
        mcp.ci = &c_SoapClient::ci___call;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x1365B3105FC59871LL, NAMSTR(s_sys_ss5fc59871, "__getfunctions")) {
        mcp.ci = &c_SoapClient::ci___getfunctions;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SoapClient::ci___destruct;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x3CA9145031035A54LL, NAMSTR(s_sys_ss31035a54, "__getlastresponse")) {
        mcp.ci = &c_SoapClient::ci___getlastresponse;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x19A26CEC7E8AAEF5LL, NAMSTR(s_sys_ss7e8aaef5, "__dorequest")) {
        mcp.ci = &c_SoapClient::ci___dorequest;
        return true;
      }
      HASH_GUARD_LITSTR(0x52C6ABACCBFD0C75LL, NAMSTR(s_sys_ss3402f38b, "__setcookie")) {
        mcp.ci = &c_SoapClient::ci___setcookie;
        return true;
      }
      HASH_GUARD_LITSTR(0x628D398E7604B9D5LL, NAMSTR(s_sys_ss7604b9d5, "__gettypes")) {
        mcp.ci = &c_SoapClient::ci___gettypes;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x4A2F89F662050D99LL, NAMSTR(s_sys_ss62050d99, "__soapcall")) {
        mcp.ci = &c_SoapClient::ci___soapcall;
        return true;
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0C94657A58A82CFALL, NAMSTR(s_sys_ss58a82cfa, "__getlastresponseheaders")) {
        mcp.ci = &c_SoapClient::ci___getlastresponseheaders;
        return true;
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x14842228D5E335BBLL, NAMSTR(s_sys_ss2a1cca45, "__setsoapheaders")) {
        mcp.ci = &c_SoapClient::ci___setsoapheaders;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x232D13904DBC36FFLL, NAMSTR(s_sys_ss4dbc36ff, "__setlocation")) {
        mcp.ci = &c_SoapClient::ci___setlocation;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SoapClient::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SoapClient::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 4:
      HASH_GUARD_LITSTR(0x5C5C1E24A140F6E4LL, NAMSTR(s_sys_ss5ebf091c, "__getlastrequest")) {
        mcp.ci = &c_SoapClient::ci___getlastrequest;
        mcp.obj = this;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x3648EE7D3B37DE8CLL, NAMSTR(s_sys_ss3b37de8c, "__getlastrequestheaders")) {
        mcp.ci = &c_SoapClient::ci___getlastrequestheaders;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x5D73364F53CEEB6CLL, NAMSTR(s_sys_ss53ceeb6c, "__call")) {
        mcp.ci = &c_SoapClient::ci___call;
        mcp.obj = this;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x1365B3105FC59871LL, NAMSTR(s_sys_ss5fc59871, "__getfunctions")) {
        mcp.ci = &c_SoapClient::ci___getfunctions;
        mcp.obj = this;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SoapClient::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x3CA9145031035A54LL, NAMSTR(s_sys_ss31035a54, "__getlastresponse")) {
        mcp.ci = &c_SoapClient::ci___getlastresponse;
        mcp.obj = this;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x19A26CEC7E8AAEF5LL, NAMSTR(s_sys_ss7e8aaef5, "__dorequest")) {
        mcp.ci = &c_SoapClient::ci___dorequest;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x52C6ABACCBFD0C75LL, NAMSTR(s_sys_ss3402f38b, "__setcookie")) {
        mcp.ci = &c_SoapClient::ci___setcookie;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x628D398E7604B9D5LL, NAMSTR(s_sys_ss7604b9d5, "__gettypes")) {
        mcp.ci = &c_SoapClient::ci___gettypes;
        mcp.obj = this;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x4A2F89F662050D99LL, NAMSTR(s_sys_ss62050d99, "__soapcall")) {
        mcp.ci = &c_SoapClient::ci___soapcall;
        mcp.obj = this;
        return true;
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0C94657A58A82CFALL, NAMSTR(s_sys_ss58a82cfa, "__getlastresponseheaders")) {
        mcp.ci = &c_SoapClient::ci___getlastresponseheaders;
        mcp.obj = this;
        return true;
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x14842228D5E335BBLL, NAMSTR(s_sys_ss2a1cca45, "__setsoapheaders")) {
        mcp.ci = &c_SoapClient::ci___setsoapheaders;
        mcp.obj = this;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x232D13904DBC36FFLL, NAMSTR(s_sys_ss4dbc36ff, "__setlocation")) {
        mcp.ci = &c_SoapClient::ci___setlocation;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SoapClient::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_SoapClient *c_SoapClient::create(Variant a0, Array a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_SoapClient::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_SoapClient::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_SoapClient::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SoapClient::ci___construct;
  mcp.obj = this;
}
void c_SoapClient::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
struct ObjectStaticCallbacks cw_SoapClient = {
  c_SoapClient::os_getInit,
  c_SoapClient::os_get,
  c_SoapClient::os_lval,
  c_SoapClient::os_invoke,
  c_SoapClient::os_constant,
  c_SoapClient::os_get_call_info
};
Object co_SoapParam(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SoapParam)())->dynCreate(params, init));
}
Object coo_SoapParam() {
  Object r(NEW(c_SoapParam)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapParam
Variant c_SoapParam::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapParam
Variant c_SoapParam::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapParam
Variant &c_SoapParam::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapParam
void c_SoapParam::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapParam
void c_SoapParam::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SoapParam
Variant * c_SoapParam::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapParam
Variant * c_SoapParam::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapParam
Variant * c_SoapParam::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapParam
Variant c_SoapParam::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapParam
IMPLEMENT_CLASS(SoapParam)
void c_SoapParam::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SoapParam::cloneImpl() {
  c_SoapParam *obj = NEW(c_SoapParam)();
  cloneSet(obj);
  return obj;
}
void c_SoapParam::cloneSet(c_SoapParam *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SoapParam::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SoapParam::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SoapParam::ci___destruct((void*)&c_SoapParam::i___destruct, (void*)&c_SoapParam::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_SoapParam::ci___construct((void*)&c_SoapParam::i___construct, (void*)&c_SoapParam::ifa___construct, 2, 0, 0x0000000000000000LL);
Variant c_SoapParam::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapParam *self = NULL;
  p_SoapParam pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapParam*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapParam::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapParam *self = NULL;
  p_SoapParam pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapParam*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_SoapParam::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapParam *self = NULL;
  p_SoapParam pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapParam*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapParam::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapParam *self = NULL;
  p_SoapParam pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapParam*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
  return (self->t___construct(a0, a1), null);
}
bool c_SoapParam::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SoapParam::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SoapParam::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SoapParam::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SoapParam::ci___destruct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SoapParam::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_SoapParam *c_SoapParam::create(Variant a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_SoapParam::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    }
  }
  return this;
}
void c_SoapParam::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  }
}
void c_SoapParam::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SoapParam::ci___construct;
  mcp.obj = this;
}
void c_SoapParam::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0, a1), null);
}
struct ObjectStaticCallbacks cw_SoapParam = {
  c_SoapParam::os_getInit,
  c_SoapParam::os_get,
  c_SoapParam::os_lval,
  c_SoapParam::os_invoke,
  c_SoapParam::os_constant,
  c_SoapParam::os_get_call_info
};
Object co_DateTime(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DateTime)())->dynCreate(params, init));
}
Object coo_DateTime() {
  Object r(NEW(c_DateTime)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DateTime
Variant c_DateTime::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DateTime
Variant c_DateTime::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DateTime
Variant &c_DateTime::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DateTime
void c_DateTime::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DateTime
void c_DateTime::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DateTime
Variant * c_DateTime::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DateTime
Variant * c_DateTime::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DateTime
Variant * c_DateTime::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DateTime
Variant c_DateTime::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 4:
      HASH_RETURN(0x65F665B8975D4C44LL, q_DateTime_RSS, "RSS");
      break;
    case 5:
      HASH_RETURN(0x4C70260A54584B05LL, q_DateTime_ATOM, "ATOM");
      break;
    case 9:
      HASH_RETURN(0x0D93F5DDBEAD7BC9LL, q_DateTime_ISO8601, "ISO8601");
      break;
    case 10:
      HASH_RETURN(0x2E8A54E476F8FF8ALL, q_DateTime_RFC850, "RFC850");
      break;
    case 12:
      HASH_RETURN(0x2183317DB64F7D2CLL, q_DateTime_COOKIE, "COOKIE");
      HASH_RETURN(0x51E9E1D29858652CLL, q_DateTime_RFC1036, "RFC1036");
      HASH_RETURN(0x2035891FE861602CLL, q_DateTime_RFC3339, "RFC3339");
      break;
    case 23:
      HASH_RETURN(0x1CC8F0E77D83F017LL, q_DateTime_RFC2822, "RFC2822");
      break;
    case 27:
      HASH_RETURN(0x64B53064426F891BLL, q_DateTime_RFC822, "RFC822");
      HASH_RETURN(0x0D99FD60C002B3DBLL, q_DateTime_W3C, "W3C");
      break;
    case 30:
      HASH_RETURN(0x325DE23E7968F7FELL, q_DateTime_RFC1123, "RFC1123");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DateTime
IMPLEMENT_CLASS(DateTime)
void c_DateTime::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DateTime::cloneImpl() {
  c_DateTime *obj = NEW(c_DateTime)();
  cloneSet(obj);
  return obj;
}
void c_DateTime::cloneSet(c_DateTime *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DateTime::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 7:
      HASH_GUARD_LITSTR(0x65A9B2950F080587LL, NAMSTR(s_sys_ss0f080587, "modify")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_modify(a0));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x67314943DC9D120BLL, NAMSTR(s_sys_ss2362edf5, "setDate")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setdate(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss0b55bd0b, "getOffset")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getoffset());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x688601F33BE7716CLL, NAMSTR(s_sys_ss3be7716c, "getTimezone")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettimezone());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x16D6DBFD6EE55A74LL, NAMSTR(s_sys_ss6ee55a74, "setISODate")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_setisodate(a0, a1));
        else return (t_setisodate(a0, a1, a2));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x07CB96AB34F4C258LL, NAMSTR(s_sys_ss34f4c258, "setTime")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_settime(a0, a1));
        else return (t_settime(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x3B576E558B957CB8LL, NAMSTR(s_sys_ss746a8348, "setTimezone")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_settimezone(a0));
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x1B6DDAF6AAF8CA9BLL, NAMSTR(s_sys_ss55073565, "format")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_format(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DateTime::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DateTime::ci_format((void*)&c_DateTime::i_format, (void*)&c_DateTime::ifa_format, 1, 0, 0x0000000000000000LL);
CallInfo c_DateTime::ci_setdate((void*)&c_DateTime::i_setdate, (void*)&c_DateTime::ifa_setdate, 3, 0, 0x0000000000000000LL);
CallInfo c_DateTime::ci___destruct((void*)&c_DateTime::i___destruct, (void*)&c_DateTime::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DateTime::ci_getoffset((void*)&c_DateTime::i_getoffset, (void*)&c_DateTime::ifa_getoffset, 0, 0, 0x0000000000000000LL);
CallInfo c_DateTime::ci_settime((void*)&c_DateTime::i_settime, (void*)&c_DateTime::ifa_settime, 3, 0, 0x0000000000000000LL);
CallInfo c_DateTime::ci___construct((void*)&c_DateTime::i___construct, (void*)&c_DateTime::ifa___construct, 2, 0, 0x0000000000000000LL);
CallInfo c_DateTime::ci_gettimezone((void*)&c_DateTime::i_gettimezone, (void*)&c_DateTime::ifa_gettimezone, 0, 0, 0x0000000000000000LL);
CallInfo c_DateTime::ci_setisodate((void*)&c_DateTime::i_setisodate, (void*)&c_DateTime::ifa_setisodate, 3, 0, 0x0000000000000000LL);
CallInfo c_DateTime::ci_settimezone((void*)&c_DateTime::i_settimezone, (void*)&c_DateTime::ifa_settimezone, 1, 0, 0x0000000000000000LL);
CallInfo c_DateTime::ci_modify((void*)&c_DateTime::i_modify, (void*)&c_DateTime::ifa_modify, 1, 0, 0x0000000000000000LL);
Variant c_DateTime::i_format(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_format(arg0));
  }
}
Variant c_DateTime::i_setdate(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setdate(arg0, arg1, arg2));
  }
}
Variant c_DateTime::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DateTime::i_getoffset(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
  return (self->t_getoffset());
}
Variant c_DateTime::i_settime(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_settime(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_settime(arg0, arg1, arg2));
  }
}
Variant c_DateTime::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t___construct(), null);
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_DateTime::i_gettimezone(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
  return (self->t_gettimezone());
}
Variant c_DateTime::i_setisodate(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_setisodate(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setisodate(arg0, arg1, arg2));
  }
}
Variant c_DateTime::i_settimezone(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_settimezone(arg0));
  }
}
Variant c_DateTime::i_modify(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_modify(arg0));
  }
}
Variant c_DateTime::ifa_format(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
  return (self->t_format(a0));
}
Variant c_DateTime::ifa_setdate(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
  return (self->t_setdate(a0, a1, a2));
}
Variant c_DateTime::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DateTime::ifa_getoffset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
  return (self->t_getoffset());
}
Variant c_DateTime::ifa_settime(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
  if (count <= 2) return (self->t_settime(a0, a1));
  return (self->t_settime(a0, a1, a2));
}
Variant c_DateTime::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
  if (count <= 0) return (self->t___construct(), null);
  if (count == 1) return (self->t___construct(a0), null);
  return (self->t___construct(a0, a1), null);
}
Variant c_DateTime::ifa_gettimezone(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
  return (self->t_gettimezone());
}
Variant c_DateTime::ifa_setisodate(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
  if (count <= 2) return (self->t_setisodate(a0, a1));
  return (self->t_setisodate(a0, a1, a2));
}
Variant c_DateTime::ifa_settimezone(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
  return (self->t_settimezone(a0));
}
Variant c_DateTime::ifa_modify(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
  return (self->t_modify(a0));
}
bool c_DateTime::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 7:
      HASH_GUARD_LITSTR(0x65A9B2950F080587LL, NAMSTR(s_sys_ss0f080587, "modify")) {
        mcp.ci = &c_DateTime::ci_modify;
        return true;
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x67314943DC9D120BLL, NAMSTR(s_sys_ss2362edf5, "setDate")) {
        mcp.ci = &c_DateTime::ci_setdate;
        return true;
      }
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss0b55bd0b, "getOffset")) {
        mcp.ci = &c_DateTime::ci_getoffset;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x688601F33BE7716CLL, NAMSTR(s_sys_ss3be7716c, "getTimezone")) {
        mcp.ci = &c_DateTime::ci_gettimezone;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DateTime::ci___destruct;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x16D6DBFD6EE55A74LL, NAMSTR(s_sys_ss6ee55a74, "setISODate")) {
        mcp.ci = &c_DateTime::ci_setisodate;
        return true;
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x07CB96AB34F4C258LL, NAMSTR(s_sys_ss34f4c258, "setTime")) {
        mcp.ci = &c_DateTime::ci_settime;
        return true;
      }
      HASH_GUARD_LITSTR(0x3B576E558B957CB8LL, NAMSTR(s_sys_ss746a8348, "setTimezone")) {
        mcp.ci = &c_DateTime::ci_settimezone;
        return true;
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x1B6DDAF6AAF8CA9BLL, NAMSTR(s_sys_ss55073565, "format")) {
        mcp.ci = &c_DateTime::ci_format;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DateTime::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DateTime::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 7:
      HASH_GUARD_LITSTR(0x65A9B2950F080587LL, NAMSTR(s_sys_ss0f080587, "modify")) {
        mcp.ci = &c_DateTime::ci_modify;
        mcp.obj = this;
        return true;
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x67314943DC9D120BLL, NAMSTR(s_sys_ss2362edf5, "setDate")) {
        mcp.ci = &c_DateTime::ci_setdate;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss0b55bd0b, "getOffset")) {
        mcp.ci = &c_DateTime::ci_getoffset;
        mcp.obj = this;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x688601F33BE7716CLL, NAMSTR(s_sys_ss3be7716c, "getTimezone")) {
        mcp.ci = &c_DateTime::ci_gettimezone;
        mcp.obj = this;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DateTime::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x16D6DBFD6EE55A74LL, NAMSTR(s_sys_ss6ee55a74, "setISODate")) {
        mcp.ci = &c_DateTime::ci_setisodate;
        mcp.obj = this;
        return true;
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x07CB96AB34F4C258LL, NAMSTR(s_sys_ss34f4c258, "setTime")) {
        mcp.ci = &c_DateTime::ci_settime;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x3B576E558B957CB8LL, NAMSTR(s_sys_ss746a8348, "setTimezone")) {
        mcp.ci = &c_DateTime::ci_settimezone;
        mcp.obj = this;
        return true;
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x1B6DDAF6AAF8CA9BLL, NAMSTR(s_sys_ss55073565, "format")) {
        mcp.ci = &c_DateTime::ci_format;
        mcp.obj = this;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DateTime::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_DateTime *c_DateTime::create(String a0, Object a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_DateTime::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("__construct", 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      if (count == 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_DateTime::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_DateTime::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DateTime::ci___construct;
  mcp.obj = this;
}
void c_DateTime::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
struct ObjectStaticCallbacks cw_DateTime = {
  c_DateTime::os_getInit,
  c_DateTime::os_get,
  c_DateTime::os_lval,
  c_DateTime::os_invoke,
  c_DateTime::os_constant,
  c_DateTime::os_get_call_info
};
Object co_Collator(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_Collator)())->dynCreate(params, init));
}
Object coo_Collator() {
  Object r(NEW(c_Collator)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Collator
Variant c_Collator::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_Collator
Variant c_Collator::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Collator
Variant &c_Collator::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_Collator
void c_Collator::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_Collator
void c_Collator::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_Collator
Variant * c_Collator::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Collator
Variant * c_Collator::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Collator
Variant * c_Collator::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_Collator
Variant c_Collator::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_RETURN(0x44D1DA387595A403LL, q_Collator_SORT_REGULAR, "SORT_REGULAR");
      HASH_RETURN(0x243ECA9F2933DFC3LL, q_Collator_ON, "ON");
      break;
    case 4:
      HASH_RETURN(0x2FC0EE2E1B088E44LL, q_Collator_NUMERIC_COLLATION, "NUMERIC_COLLATION");
      break;
    case 7:
      HASH_RETURN(0x11D151DDDD2A4107LL, q_Collator_HIRAGANA_QUATERNARY_MODE, "HIRAGANA_QUATERNARY_MODE");
      break;
    case 12:
      HASH_RETURN(0x12C49411F55E648CLL, q_Collator_QUATERNARY, "QUATERNARY");
      break;
    case 20:
      HASH_RETURN(0x6A7AD33CDF49E8D4LL, q_Collator_SORT_NUMERIC, "SORT_NUMERIC");
      HASH_RETURN(0x342F3FCC372ABD54LL, q_Collator_NON_IGNORABLE, "NON_IGNORABLE");
      break;
    case 21:
      HASH_RETURN(0x43A7AE36C693E955LL, q_Collator_DEFAULT_VALUE, "DEFAULT_VALUE");
      break;
    case 24:
      HASH_RETURN(0x6DED35804EDAD218LL, q_Collator_CASE_LEVEL, "CASE_LEVEL");
      HASH_RETURN(0x0AE48A6C6BE5D798LL, q_Collator_LOWER_FIRST, "LOWER_FIRST");
      break;
    case 27:
      HASH_RETURN(0x2C6A6D2A478AF4DBLL, q_Collator_UPPER_FIRST, "UPPER_FIRST");
      break;
    case 29:
      HASH_RETURN(0x58342E71EC59E4DDLL, q_Collator_IDENTICAL, "IDENTICAL");
      break;
    case 32:
      HASH_RETURN(0x092DDC88428C3A20LL, q_Collator_PRIMARY, "PRIMARY");
      break;
    case 33:
      HASH_RETURN(0x713FE3D58B4C7661LL, q_Collator_FRENCH_COLLATION, "FRENCH_COLLATION");
      HASH_RETURN(0x25FE54F210EC5FE1LL, q_Collator_SECONDARY, "SECONDARY");
      HASH_RETURN(0x6E252898020550A1LL, q_Collator_TERTIARY, "TERTIARY");
      break;
    case 35:
      HASH_RETURN(0x2C984380FDBF8563LL, q_Collator_STRENGTH, "STRENGTH");
      break;
    case 39:
      HASH_RETURN(0x7306AAA31A7C8BE7LL, q_Collator_DEFAULT_STRENGTH, "DEFAULT_STRENGTH");
      break;
    case 45:
      HASH_RETURN(0x304F6E12C5B7486DLL, q_Collator_CASE_FIRST, "CASE_FIRST");
      break;
    case 52:
      HASH_RETURN(0x395D56BB0A8525F4LL, q_Collator_NORMALIZATION_MODE, "NORMALIZATION_MODE");
      break;
    case 53:
      HASH_RETURN(0x595FDD99C9EFE835LL, q_Collator_ALTERNATE_HANDLING, "ALTERNATE_HANDLING");
      break;
    case 60:
      HASH_RETURN(0x334AAA38C97C62FCLL, q_Collator_SORT_STRING, "SORT_STRING");
      HASH_RETURN(0x0039CBFC3620143CLL, q_Collator_SHIFTED, "SHIFTED");
      break;
    case 61:
      HASH_RETURN(0x136402C9E51A75FDLL, q_Collator_OFF, "OFF");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_Collator
IMPLEMENT_CLASS(Collator)
void c_Collator::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_Collator::cloneImpl() {
  c_Collator *obj = NEW(c_Collator)();
  cloneSet(obj);
  return obj;
}
void c_Collator::cloneSet(c_Collator *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_Collator::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x43E057044D6296E0LL, NAMSTR(s_sys_ss4d6296e0, "geterrorcode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_geterrorcode());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x2C7E06EB2965CE02LL, NAMSTR(s_sys_ss2965ce02, "getlocale")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getlocale());
        else return (t_getlocale(a0));
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1F4984938E1DBB2ALL, NAMSTR(s_sys_ss71e244d6, "sort")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_sort(ref(a0)));
        else return (t_sort(ref(a0), a1));
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x365C573D887803EBLL, NAMSTR(s_sys_ss7787fc15, "sortwithsortkeys")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_sortwithsortkeys(ref(a0)));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x790B7C44A3442BEELL, NAMSTR(s_sys_ss5cbbd412, "asort")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_asort(ref(a0)));
        else return (t_asort(ref(a0), a1));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x3B4D97DC8C437CD1LL, NAMSTR(s_sys_ss73bc832f, "geterrormessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_geterrormessage());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x1BF74792BDECF352LL, NAMSTR(s_sys_ss42130cae, "compare")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_compare(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x3A0A2C5D90518456LL, NAMSTR(s_sys_ss6fae7baa, "create")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_create(o_getClassName(), a0));
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x0B7AA0ED4CBF9ED7LL, NAMSTR(s_sys_ss4cbf9ed7, "setstrength")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setstrength(a0));
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1C15B5A1A05B4C5ELL, NAMSTR(s_sys_ss5fa4b3a2, "getstrength")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstrength());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_Collator::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x3A0A2C5D90518456LL, NAMSTR(s_sys_ss6fae7baa, "create")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_create(c, a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_Collator::ci_getattribute((void*)&c_Collator::i_getattribute, (void*)&c_Collator::ifa_getattribute, 1, 0, 0x0000000000000000LL);
CallInfo c_Collator::ci_sortwithsortkeys((void*)&c_Collator::i_sortwithsortkeys, (void*)&c_Collator::ifa_sortwithsortkeys, 1, 0, 0x0000000000000001LL);
CallInfo c_Collator::ci___destruct((void*)&c_Collator::i___destruct, (void*)&c_Collator::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_Collator::ci___construct((void*)&c_Collator::i___construct, (void*)&c_Collator::ifa___construct, 1, 0, 0x0000000000000000LL);
CallInfo c_Collator::ci_sort((void*)&c_Collator::i_sort, (void*)&c_Collator::ifa_sort, 2, 0, 0x0000000000000001LL);
CallInfo c_Collator::ci_geterrorcode((void*)&c_Collator::i_geterrorcode, (void*)&c_Collator::ifa_geterrorcode, 0, 0, 0x0000000000000000LL);
CallInfo c_Collator::ci_getstrength((void*)&c_Collator::i_getstrength, (void*)&c_Collator::ifa_getstrength, 0, 0, 0x0000000000000000LL);
CallInfo c_Collator::ci_asort((void*)&c_Collator::i_asort, (void*)&c_Collator::ifa_asort, 2, 0, 0x0000000000000001LL);
CallInfo c_Collator::ci_setstrength((void*)&c_Collator::i_setstrength, (void*)&c_Collator::ifa_setstrength, 1, 0, 0x0000000000000000LL);
CallInfo c_Collator::ci_create((void*)&c_Collator::i_create, (void*)&c_Collator::ifa_create, 1, 0, 0x0000000000000000LL);
CallInfo c_Collator::ci_setattribute((void*)&c_Collator::i_setattribute, (void*)&c_Collator::ifa_setattribute, 2, 0, 0x0000000000000000LL);
CallInfo c_Collator::ci_getlocale((void*)&c_Collator::i_getlocale, (void*)&c_Collator::ifa_getlocale, 1, 0, 0x0000000000000000LL);
CallInfo c_Collator::ci_geterrormessage((void*)&c_Collator::i_geterrormessage, (void*)&c_Collator::ifa_geterrormessage, 0, 0, 0x0000000000000000LL);
CallInfo c_Collator::ci_compare((void*)&c_Collator::i_compare, (void*)&c_Collator::ifa_compare, 2, 0, 0x0000000000000000LL);
Variant c_Collator::i_getattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getattribute(arg0));
  }
}
Variant c_Collator::i_sortwithsortkeys(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (self->t_sortwithsortkeys(arg0));
  }
}
Variant c_Collator::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_Collator::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___construct(arg0), null);
  }
}
Variant c_Collator::i_sort(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (self->t_sort(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_sort(arg0, arg1));
  }
}
Variant c_Collator::i_geterrorcode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
  return (self->t_geterrorcode());
}
Variant c_Collator::i_getstrength(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
  return (self->t_getstrength());
}
Variant c_Collator::i_asort(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (self->t_asort(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_asort(arg0, arg1));
  }
}
Variant c_Collator::i_setstrength(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setstrength(arg0));
  }
}
Variant c_Collator::i_create(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  const char *c;
  if (mcp.rootObj.is(KindOfObject)) {
    c = mcp.rootObj.getObjectData()->o_getClassName();
  } else {
    c = mcp.rootObj.getCStr();
  }
  if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (c_Collator::ti_create(c, arg0));
  }
}
Variant c_Collator::i_setattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setattribute(arg0, arg1));
  }
}
Variant c_Collator::i_getlocale(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_getlocale());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getlocale(arg0));
  }
}
Variant c_Collator::i_geterrormessage(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
  return (self->t_geterrormessage());
}
Variant c_Collator::i_compare(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_compare(arg0, arg1));
  }
}
Variant c_Collator::ifa_getattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
  return (self->t_getattribute(a0));
}
Variant c_Collator::ifa_sortwithsortkeys(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
  return (self->t_sortwithsortkeys(ref(a0)));
}
Variant c_Collator::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_Collator::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  return (self->t___construct(a0), null);
}
Variant c_Collator::ifa_sort(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
  if (count <= 1) return (self->t_sort(ref(a0)));
  return (self->t_sort(ref(a0), a1));
}
Variant c_Collator::ifa_geterrorcode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
  return (self->t_geterrorcode());
}
Variant c_Collator::ifa_getstrength(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
  return (self->t_getstrength());
}
Variant c_Collator::ifa_asort(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
  if (count <= 1) return (self->t_asort(ref(a0)));
  return (self->t_asort(ref(a0), a1));
}
Variant c_Collator::ifa_setstrength(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
  return (self->t_setstrength(a0));
}
Variant c_Collator::ifa_create(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  const char *c;
  if (mcp.rootObj.is(KindOfObject)) {
    c = mcp.rootObj.getObjectData()->o_getClassName();
  } else {
    c = mcp.rootObj.getCStr();
  }
  if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
  return (c_Collator::ti_create(c, a0));
}
Variant c_Collator::ifa_setattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
  return (self->t_setattribute(a0, a1));
}
Variant c_Collator::ifa_getlocale(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
  if (count <= 0) return (self->t_getlocale());
  return (self->t_getlocale(a0));
}
Variant c_Collator::ifa_geterrormessage(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
  return (self->t_geterrormessage());
}
Variant c_Collator::ifa_compare(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
  return (self->t_compare(a0, a1));
}
bool c_Collator::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x43E057044D6296E0LL, NAMSTR(s_sys_ss4d6296e0, "geterrorcode")) {
        mcp.ci = &c_Collator::ci_geterrorcode;
        return true;
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x2C7E06EB2965CE02LL, NAMSTR(s_sys_ss2965ce02, "getlocale")) {
        mcp.ci = &c_Collator::ci_getlocale;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        mcp.ci = &c_Collator::ci_getattribute;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1F4984938E1DBB2ALL, NAMSTR(s_sys_ss71e244d6, "sort")) {
        mcp.ci = &c_Collator::ci_sort;
        return true;
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        mcp.ci = &c_Collator::ci_setattribute;
        return true;
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x365C573D887803EBLL, NAMSTR(s_sys_ss7787fc15, "sortwithsortkeys")) {
        mcp.ci = &c_Collator::ci_sortwithsortkeys;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x790B7C44A3442BEELL, NAMSTR(s_sys_ss5cbbd412, "asort")) {
        mcp.ci = &c_Collator::ci_asort;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x3B4D97DC8C437CD1LL, NAMSTR(s_sys_ss73bc832f, "geterrormessage")) {
        mcp.ci = &c_Collator::ci_geterrormessage;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x1BF74792BDECF352LL, NAMSTR(s_sys_ss42130cae, "compare")) {
        mcp.ci = &c_Collator::ci_compare;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_Collator::ci___destruct;
        return true;
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x3A0A2C5D90518456LL, NAMSTR(s_sys_ss6fae7baa, "create")) {
        mcp.ci = &c_Collator::ci_create;
        return true;
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x0B7AA0ED4CBF9ED7LL, NAMSTR(s_sys_ss4cbf9ed7, "setstrength")) {
        mcp.ci = &c_Collator::ci_setstrength;
        return true;
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1C15B5A1A05B4C5ELL, NAMSTR(s_sys_ss5fa4b3a2, "getstrength")) {
        mcp.ci = &c_Collator::ci_getstrength;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_Collator::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_Collator::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x43E057044D6296E0LL, NAMSTR(s_sys_ss4d6296e0, "geterrorcode")) {
        mcp.ci = &c_Collator::ci_geterrorcode;
        mcp.obj = this;
        return true;
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x2C7E06EB2965CE02LL, NAMSTR(s_sys_ss2965ce02, "getlocale")) {
        mcp.ci = &c_Collator::ci_getlocale;
        mcp.obj = this;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        mcp.ci = &c_Collator::ci_getattribute;
        mcp.obj = this;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1F4984938E1DBB2ALL, NAMSTR(s_sys_ss71e244d6, "sort")) {
        mcp.ci = &c_Collator::ci_sort;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        mcp.ci = &c_Collator::ci_setattribute;
        mcp.obj = this;
        return true;
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x365C573D887803EBLL, NAMSTR(s_sys_ss7787fc15, "sortwithsortkeys")) {
        mcp.ci = &c_Collator::ci_sortwithsortkeys;
        mcp.obj = this;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x790B7C44A3442BEELL, NAMSTR(s_sys_ss5cbbd412, "asort")) {
        mcp.ci = &c_Collator::ci_asort;
        mcp.obj = this;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x3B4D97DC8C437CD1LL, NAMSTR(s_sys_ss73bc832f, "geterrormessage")) {
        mcp.ci = &c_Collator::ci_geterrormessage;
        mcp.obj = this;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x1BF74792BDECF352LL, NAMSTR(s_sys_ss42130cae, "compare")) {
        mcp.ci = &c_Collator::ci_compare;
        mcp.obj = this;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_Collator::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x3A0A2C5D90518456LL, NAMSTR(s_sys_ss6fae7baa, "create")) {
        mcp.ci = &c_Collator::ci_create;
        mcp.obj = this;
        return true;
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x0B7AA0ED4CBF9ED7LL, NAMSTR(s_sys_ss4cbf9ed7, "setstrength")) {
        mcp.ci = &c_Collator::ci_setstrength;
        mcp.obj = this;
        return true;
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1C15B5A1A05B4C5ELL, NAMSTR(s_sys_ss5fa4b3a2, "getstrength")) {
        mcp.ci = &c_Collator::ci_getstrength;
        mcp.obj = this;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_Collator::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_Collator *c_Collator::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_Collator::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_Collator::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_Collator::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_Collator::ci___construct;
  mcp.obj = this;
}
void c_Collator::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
struct ObjectStaticCallbacks cw_Collator = {
  c_Collator::os_getInit,
  c_Collator::os_get,
  c_Collator::os_lval,
  c_Collator::os_invoke,
  c_Collator::os_constant,
  c_Collator::os_get_call_info
};
Object co_PDO(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_PDO)())->dynCreate(params, init));
}
Object coo_PDO() {
  Object r(NEW(c_PDO)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_PDO
Variant c_PDO::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_PDO
Variant c_PDO::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_PDO
Variant &c_PDO::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_PDO
void c_PDO::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_PDO
void c_PDO::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PDO
Variant * c_PDO::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_PDO
Variant * c_PDO::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_PDO
Variant * c_PDO::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_PDO
Variant c_PDO::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 0:
      HASH_RETURN(0x1800ED92A8884D00LL, q_PDO_ATTR_CASE, "ATTR_CASE");
      break;
    case 2:
      HASH_RETURN(0x07BAFBAE5A431902LL, q_PDO_ATTR_STATEMENT_CLASS, "ATTR_STATEMENT_CLASS");
      break;
    case 4:
      HASH_RETURN(0x0229D662F91D9C04LL, q_PDO_ERRMODE_EXCEPTION, "ERRMODE_EXCEPTION");
      break;
    case 8:
      HASH_RETURN(0x3BE7A02FD980AA08LL, q_PDO_CASE_NATURAL, "CASE_NATURAL");
      break;
    case 13:
      HASH_RETURN(0x099B533427CCC20DLL, q_PDO_FETCH_OBJ, "FETCH_OBJ");
      break;
    case 17:
      HASH_RETURN(0x5FAD218776C6E511LL, q_PDO_FETCH_INTO, "FETCH_INTO");
      break;
    case 25:
      HASH_RETURN(0x78CB81320C710019LL, q_PDO_FETCH_BOUND, "FETCH_BOUND");
      break;
    case 27:
      HASH_RETURN(0x3158D52C3627FE1BLL, q_PDO_MYSQL_ATTR_INIT_COMMAND, "MYSQL_ATTR_INIT_COMMAND");
      break;
    case 28:
      HASH_RETURN(0x03CF598D3CCCD01CLL, q_PDO_ATTR_CLIENT_VERSION, "ATTR_CLIENT_VERSION");
      break;
    case 29:
      HASH_RETURN(0x2BE16C4111A7B41DLL, q_PDO_ATTR_FETCH_CATALOG_NAMES, "ATTR_FETCH_CATALOG_NAMES");
      break;
    case 30:
      HASH_RETURN(0x2A5BA04D0218F11ELL, q_PDO_CASE_LOWER, "CASE_LOWER");
      break;
    case 35:
      HASH_RETURN(0x16B15CF4B0DD7E23LL, q_PDO_FETCH_GROUP, "FETCH_GROUP");
      break;
    case 37:
      HASH_RETURN(0x37F650C462FB6A25LL, q_PDO_CASE_UPPER, "CASE_UPPER");
      break;
    case 42:
      HASH_RETURN(0x262D9BE84029992ALL, q_PDO_PARAM_EVT_FETCH_POST, "PARAM_EVT_FETCH_POST");
      break;
    case 51:
      HASH_RETURN(0x15D2BCCED7726933LL, q_PDO_ATTR_TIMEOUT, "ATTR_TIMEOUT");
      break;
    case 59:
      HASH_RETURN(0x01B17428BEE0243BLL, q_PDO_PARAM_EVT_EXEC_PRE, "PARAM_EVT_EXEC_PRE");
      break;
    case 60:
      HASH_RETURN(0x2739A1D49673D43CLL, q_PDO_ATTR_ERRMODE, "ATTR_ERRMODE");
      HASH_RETURN(0x6AC5C285F4DD863CLL, q_PDO_ATTR_DEFAULT_FETCH_MODE, "ATTR_DEFAULT_FETCH_MODE");
      break;
    case 61:
      HASH_RETURN(0x3E11051E4101D73DLL, q_PDO_ATTR_EMULATE_PREPARES, "ATTR_EMULATE_PREPARES");
      break;
    case 68:
      HASH_RETURN(0x2189354E22363544LL, q_PDO_ATTR_PREFETCH, "ATTR_PREFETCH");
      break;
    case 72:
      HASH_RETURN(0x428D5CA64BB99E48LL, q_PDO_FETCH_UNIQUE, "FETCH_UNIQUE");
      break;
    case 78:
      HASH_RETURN(0x39B4E90F36E93B4ELL, q_PDO_MYSQL_ATTR_READ_DEFAULT_GROUP, "MYSQL_ATTR_READ_DEFAULT_GROUP");
      break;
    case 82:
      HASH_RETURN(0x58A833E2336C6152LL, q_PDO_ATTR_SERVER_INFO, "ATTR_SERVER_INFO");
      break;
    case 86:
      HASH_RETURN(0x57B75F4773C81556LL, q_PDO_PARAM_EVT_NORMALIZE, "PARAM_EVT_NORMALIZE");
      break;
    case 91:
      HASH_RETURN(0x5495020CF262F15BLL, q_PDO_ATTR_CONNECTION_STATUS, "ATTR_CONNECTION_STATUS");
      HASH_RETURN(0x37888F551D85275BLL, q_PDO_ATTR_ORACLE_NULLS, "ATTR_ORACLE_NULLS");
      break;
    case 97:
      HASH_RETURN(0x416A0550A8F12E61LL, q_PDO_MYSQL_ATTR_FOUND_ROWS, "MYSQL_ATTR_FOUND_ROWS");
      break;
    case 101:
      HASH_RETURN(0x15A3522970275465LL, q_PDO_FETCH_ORI_NEXT, "FETCH_ORI_NEXT");
      break;
    case 104:
      HASH_RETURN(0x162EAA2134F1C068LL, q_PDO_ATTR_FETCH_TABLE_NAMES, "ATTR_FETCH_TABLE_NAMES");
      break;
    case 111:
      HASH_RETURN(0x350E9275757FD66FLL, q_PDO_FETCH_ORI_REL, "FETCH_ORI_REL");
      break;
    case 112:
      HASH_RETURN(0x6870D9DE66F43D70LL, q_PDO_FETCH_ASSOC, "FETCH_ASSOC");
      break;
    case 113:
      HASH_RETURN(0x713C8339790FC071LL, q_PDO_ATTR_CURSOR_NAME, "ATTR_CURSOR_NAME");
      break;
    case 116:
      HASH_RETURN(0x1FB97A35B6711374LL, q_PDO_ATTR_MAX_COLUMN_LEN, "ATTR_MAX_COLUMN_LEN");
      break;
    case 117:
      HASH_RETURN(0x0E51487F9370EE75LL, q_PDO_ATTR_AUTOCOMMIT, "ATTR_AUTOCOMMIT");
      break;
    case 121:
      HASH_RETURN(0x630122BA9EC73379LL, q_PDO_PARAM_NULL, "PARAM_NULL");
      HASH_RETURN(0x05B00276031D7D79LL, q_PDO_PARAM_EVT_ALLOC, "PARAM_EVT_ALLOC");
      break;
    case 125:
      HASH_RETURN(0x500C039681520C7DLL, q_PDO_PARAM_BOOL, "PARAM_BOOL");
      break;
    case 126:
      HASH_RETURN(0x5CF4F38A0D7D087ELL, q_PDO_NULL_NATURAL, "NULL_NATURAL");
      break;
    case 131:
      HASH_RETURN(0x3F414F2735132983LL, q_PDO_PARAM_INT, "PARAM_INT");
      break;
    case 132:
      HASH_RETURN(0x2011B5A528057784LL, q_PDO_FETCH_NUM, "FETCH_NUM");
      break;
    case 133:
      HASH_RETURN(0x5451E44C627DD885LL, q_PDO_FETCH_ORI_PRIOR, "FETCH_ORI_PRIOR");
      break;
    case 134:
      HASH_RETURN(0x1B8BA5EEAABCB786LL, q_PDO_PARAM_EVT_EXEC_POST, "PARAM_EVT_EXEC_POST");
      HASH_RETURN(0x1B51C692B91D7486LL, q_PDO_MYSQL_ATTR_USE_BUFFERED_QUERY, "MYSQL_ATTR_USE_BUFFERED_QUERY");
      break;
    case 136:
      HASH_RETURN(0x7E64209D5A925F88LL, q_PDO_PARAM_STR, "PARAM_STR");
      break;
    case 138:
      HASH_RETURN(0x45AB9806DE21EA8ALL, q_PDO_ATTR_CURSOR, "ATTR_CURSOR");
      break;
    case 141:
      HASH_RETURN(0x0EDB017494A81E8DLL, q_PDO_ATTR_DRIVER_NAME, "ATTR_DRIVER_NAME");
      break;
    case 142:
      HASH_RETURN(0x126B3038F3355A8ELL, q_PDO_FETCH_USE_DEFAULT, "FETCH_USE_DEFAULT");
      break;
    case 143:
      HASH_RETURN(0x1F200B094608BE8FLL, q_PDO_ATTR_SERVER_VERSION, "ATTR_SERVER_VERSION");
      HASH_RETURN(0x1175C5F56147488FLL, q_PDO_MYSQL_ATTR_DIRECT_QUERY, "MYSQL_ATTR_DIRECT_QUERY");
      break;
    case 150:
      HASH_RETURN(0x25BE9238386C2796LL, q_PDO_FETCH_PROPS_LATE, "FETCH_PROPS_LATE");
      break;
    case 153:
      HASH_RETURN(0x657BEA5F741C4999LL, q_PDO_FETCH_COLUMN, "FETCH_COLUMN");
      HASH_RETURN(0x18B801DE8D8C9099LL, q_PDO_FETCH_CLASSTYPE, "FETCH_CLASSTYPE");
      break;
    case 156:
      HASH_RETURN(0x1EC178DF86F4FD9CLL, q_PDO_FETCH_SERIALIZE, "FETCH_SERIALIZE");
      break;
    case 160:
      HASH_RETURN(0x052245CE02FBF4A0LL, q_PDO_MYSQL_ATTR_LOCAL_INFILE, "MYSQL_ATTR_LOCAL_INFILE");
      break;
    case 162:
      HASH_RETURN(0x28D5B850B76FEEA2LL, q_PDO_FETCH_BOTH, "FETCH_BOTH");
      HASH_RETURN(0x0D0BCCC6768A88A2LL, q_PDO_FETCH_KEY_PAIR, "FETCH_KEY_PAIR");
      break;
    case 164:
      HASH_RETURN(0x6851B7545234FCA4LL, q_PDO_PARAM_EVT_FETCH_PRE, "PARAM_EVT_FETCH_PRE");
      break;
    case 168:
      HASH_RETURN(0x167DD614E842FAA8LL, q_PDO_CURSOR_FWDONLY, "CURSOR_FWDONLY");
      break;
    case 169:
      HASH_RETURN(0x6AEB66DE7A454FA9LL, q_PDO_FETCH_ORI_FIRST, "FETCH_ORI_FIRST");
      break;
    case 170:
      HASH_RETURN(0x392400A66B305EAALL, q_PDO_CURSOR_SCROLL, "CURSOR_SCROLL");
      break;
    case 171:
      HASH_RETURN(0x2F6AE87AF5701AABLL, q_PDO_FETCH_ORI_LAST, "FETCH_ORI_LAST");
      break;
    case 180:
      HASH_RETURN(0x56D59339A0F5D8B4LL, q_PDO_ATTR_PERSISTENT, "ATTR_PERSISTENT");
      break;
    case 184:
      HASH_RETURN(0x08657D6005DD08B8LL, q_PDO_NULL_EMPTY_STRING, "NULL_EMPTY_STRING");
      break;
    case 197:
      HASH_RETURN(0x60CE39F6493319C5LL, q_PDO_ATTR_STRINGIFY_FETCHES, "ATTR_STRINGIFY_FETCHES");
      break;
    case 198:
      HASH_RETURN(0x61BD1667BB46C9C6LL, q_PDO_MYSQL_ATTR_READ_DEFAULT_FILE, "MYSQL_ATTR_READ_DEFAULT_FILE");
      break;
    case 200:
      HASH_RETURN(0x30D00303975C98C8LL, q_PDO_FETCH_FUNC, "FETCH_FUNC");
      HASH_RETURN(0x47D4494BE4FA26C8LL, q_PDO_FETCH_ORI_ABS, "FETCH_ORI_ABS");
      break;
    case 202:
      HASH_RETURN(0x29B68A596E0615CALL, q_PDO_NULL_TO_STRING, "NULL_TO_STRING");
      break;
    case 203:
      HASH_RETURN(0x73FAA1AA068D19CBLL, q_PDO_MYSQL_ATTR_MAX_BUFFER_SIZE, "MYSQL_ATTR_MAX_BUFFER_SIZE");
      break;
    case 208:
      HASH_RETURN(0x439351C7C64634D0LL, q_PDO_FETCH_CLASS, "FETCH_CLASS");
      break;
    case 209:
      HASH_RETURN(0x5C75BB222F23C4D1LL, q_PDO_FETCH_LAZY, "FETCH_LAZY");
      break;
    case 211:
      HASH_RETURN(0x57F9152D7EC3A5D3LL, q_PDO_MYSQL_ATTR_COMPRESS, "MYSQL_ATTR_COMPRESS");
      break;
    case 220:
      HASH_RETURN(0x4D1DDF7F772C54DCLL, q_PDO_ERRMODE_WARNING, "ERRMODE_WARNING");
      break;
    case 235:
      HASH_RETURN(0x2E4175EAAB1F75EBLL, q_PDO_ERRMODE_SILENT, "ERRMODE_SILENT");
      break;
    case 245:
      HASH_RETURN(0x16017F3F58821EF5LL, q_PDO_ERR_NONE, "ERR_NONE");
      break;
    case 246:
      HASH_RETURN(0x674F9B0D2030C3F6LL, q_PDO_PARAM_LOB, "PARAM_LOB");
      break;
    case 247:
      HASH_RETURN(0x16EC9F213D7F57F7LL, q_PDO_FETCH_NAMED, "FETCH_NAMED");
      break;
    case 248:
      HASH_RETURN(0x6C0021FD5D20A1F8LL, q_PDO_PARAM_INPUT_OUTPUT, "PARAM_INPUT_OUTPUT");
      break;
    case 251:
      HASH_RETURN(0x13EC16B8F7B7B1FBLL, q_PDO_MYSQL_ATTR_IGNORE_SPACE, "MYSQL_ATTR_IGNORE_SPACE");
      break;
    case 253:
      HASH_RETURN(0x51938FCA0AE827FDLL, q_PDO_PARAM_STMT, "PARAM_STMT");
      break;
    case 254:
      HASH_RETURN(0x56335EC3392D8EFELL, q_PDO_PARAM_EVT_FREE, "PARAM_EVT_FREE");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_PDO
IMPLEMENT_CLASS(PDO)
void c_PDO::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_PDO::cloneImpl() {
  c_PDO *obj = NEW(c_PDO)();
  cloneSet(obj);
  return obj;
}
void c_PDO::cloneSet(c_PDO *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_PDO::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss2372f2c7, "errorcode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss4f78df74, "exec")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_exec(a0));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7FF4D594AC38340ELL, NAMSTR(s_sys_ss53c7cbf2, "getavailabledrivers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x25466EABBA2D7C12LL, NAMSTR(s_sys_ss45d283ee, "lastinsertid")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_lastinsertid());
        else return (t_lastinsertid(a0));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss55f7a324, "__wakeup")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___wakeup());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss7f04605e, "errorinfo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x24D23BE465E3F324LL, NAMSTR(s_sys_ss65e3f324, "commit")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_commit());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss25243fd3, "__sleep")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___sleep());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x1740B14E849464EELL, NAMSTR(s_sys_ss7b6b9b12, "quote")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_quote(a0));
        else return (t_quote(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss4ba591af, "prepare")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_prepare(a0));
        else return (t_prepare(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x374B46BC6D79EC36LL, NAMSTR(s_sys_ss6d79ec36, "rollback")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rollback());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_query(a0));
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x0DE392135C33E23BLL, NAMSTR(s_sys_ss5c33e23b, "begintransaction")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_begintransaction());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_PDO::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x7FF4D594AC38340ELL, NAMSTR(s_sys_ss53c7cbf2, "getavailabledrivers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_getavailabledrivers(c));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_PDO::ci_errorcode((void*)&c_PDO::i_errorcode, (void*)&c_PDO::ifa_errorcode, 0, 0, 0x0000000000000000LL);
CallInfo c_PDO::ci_getattribute((void*)&c_PDO::i_getattribute, (void*)&c_PDO::ifa_getattribute, 1, 0, 0x0000000000000000LL);
CallInfo c_PDO::ci_exec((void*)&c_PDO::i_exec, (void*)&c_PDO::ifa_exec, 1, 0, 0x0000000000000000LL);
CallInfo c_PDO::ci_lastinsertid((void*)&c_PDO::i_lastinsertid, (void*)&c_PDO::ifa_lastinsertid, 1, 0, 0x0000000000000000LL);
CallInfo c_PDO::ci___destruct((void*)&c_PDO::i___destruct, (void*)&c_PDO::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_PDO::ci___wakeup((void*)&c_PDO::i___wakeup, (void*)&c_PDO::ifa___wakeup, 0, 0, 0x0000000000000000LL);
CallInfo c_PDO::ci___construct((void*)&c_PDO::i___construct, (void*)&c_PDO::ifa___construct, 4, 0, 0x0000000000000000LL);
CallInfo c_PDO::ci_query((void*)&c_PDO::i_query, (void*)&c_PDO::ifa_query, 1, 0, 0x0000000000000000LL);
CallInfo c_PDO::ci_rollback((void*)&c_PDO::i_rollback, (void*)&c_PDO::ifa_rollback, 0, 0, 0x0000000000000000LL);
CallInfo c_PDO::ci_commit((void*)&c_PDO::i_commit, (void*)&c_PDO::ifa_commit, 0, 0, 0x0000000000000000LL);
CallInfo c_PDO::ci_getavailabledrivers((void*)&c_PDO::i_getavailabledrivers, (void*)&c_PDO::ifa_getavailabledrivers, 0, 0, 0x0000000000000000LL);
CallInfo c_PDO::ci_quote((void*)&c_PDO::i_quote, (void*)&c_PDO::ifa_quote, 2, 0, 0x0000000000000000LL);
CallInfo c_PDO::ci_setattribute((void*)&c_PDO::i_setattribute, (void*)&c_PDO::ifa_setattribute, 2, 0, 0x0000000000000000LL);
CallInfo c_PDO::ci_begintransaction((void*)&c_PDO::i_begintransaction, (void*)&c_PDO::ifa_begintransaction, 0, 0, 0x0000000000000000LL);
CallInfo c_PDO::ci_prepare((void*)&c_PDO::i_prepare, (void*)&c_PDO::ifa_prepare, 2, 0, 0x0000000000000000LL);
CallInfo c_PDO::ci_errorinfo((void*)&c_PDO::i_errorinfo, (void*)&c_PDO::ifa_errorinfo, 0, 0, 0x0000000000000000LL);
CallInfo c_PDO::ci___sleep((void*)&c_PDO::i___sleep, (void*)&c_PDO::ifa___sleep, 0, 0, 0x0000000000000000LL);
Variant c_PDO::i_errorcode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
  return (self->t_errorcode());
}
Variant c_PDO::i_getattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getattribute(arg0));
  }
}
Variant c_PDO::i_exec(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_exec(arg0));
  }
}
Variant c_PDO::i_lastinsertid(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_lastinsertid());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_lastinsertid(arg0));
  }
}
Variant c_PDO::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_PDO::i___wakeup(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
  return (self->t___wakeup());
}
Variant c_PDO::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t___construct(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t___construct(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1, arg2, arg3), null);
  }
}
Variant c_PDO::i_query(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_query(arg0));
  }
}
Variant c_PDO::i_rollback(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
  return (self->t_rollback());
}
Variant c_PDO::i_commit(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("commit", 0, 1);
  return (self->t_commit());
}
Variant c_PDO::i_getavailabledrivers(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  const char *c;
  if (mcp.rootObj.is(KindOfObject)) {
    c = mcp.rootObj.getObjectData()->o_getClassName();
  } else {
    c = mcp.rootObj.getCStr();
  }
  if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
  return (c_PDO::ti_getavailabledrivers(c));
}
Variant c_PDO::i_quote(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_quote(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_quote(arg0, arg1));
  }
}
Variant c_PDO::i_setattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setattribute(arg0, arg1));
  }
}
Variant c_PDO::i_begintransaction(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
  return (self->t_begintransaction());
}
Variant c_PDO::i_prepare(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_prepare(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_prepare(arg0, arg1));
  }
}
Variant c_PDO::i_errorinfo(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
  return (self->t_errorinfo());
}
Variant c_PDO::i___sleep(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
  return (self->t___sleep());
}
Variant c_PDO::ifa_errorcode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
  return (self->t_errorcode());
}
Variant c_PDO::ifa_getattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
  return (self->t_getattribute(a0));
}
Variant c_PDO::ifa_exec(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
  return (self->t_exec(a0));
}
Variant c_PDO::ifa_lastinsertid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
  if (count <= 0) return (self->t_lastinsertid());
  return (self->t_lastinsertid(a0));
}
Variant c_PDO::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_PDO::ifa___wakeup(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
  return (self->t___wakeup());
}
Variant c_PDO::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
  if (count <= 1) return (self->t___construct(a0), null);
  if (count == 2) return (self->t___construct(a0, a1), null);
  if (count == 3) return (self->t___construct(a0, a1, a2), null);
  return (self->t___construct(a0, a1, a2, a3), null);
}
Variant c_PDO::ifa_query(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
  return (self->t_query(a0));
}
Variant c_PDO::ifa_rollback(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
  return (self->t_rollback());
}
Variant c_PDO::ifa_commit(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("commit", 0, 1);
  return (self->t_commit());
}
Variant c_PDO::ifa_getavailabledrivers(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  const char *c;
  if (mcp.rootObj.is(KindOfObject)) {
    c = mcp.rootObj.getObjectData()->o_getClassName();
  } else {
    c = mcp.rootObj.getCStr();
  }
  if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
  return (c_PDO::ti_getavailabledrivers(c));
}
Variant c_PDO::ifa_quote(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
  if (count <= 1) return (self->t_quote(a0));
  return (self->t_quote(a0, a1));
}
Variant c_PDO::ifa_setattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
  return (self->t_setattribute(a0, a1));
}
Variant c_PDO::ifa_begintransaction(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
  return (self->t_begintransaction());
}
Variant c_PDO::ifa_prepare(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
  if (count <= 1) return (self->t_prepare(a0));
  return (self->t_prepare(a0, a1));
}
Variant c_PDO::ifa_errorinfo(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
  return (self->t_errorinfo());
}
Variant c_PDO::ifa___sleep(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
  return (self->t___sleep());
}
bool c_PDO::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss2372f2c7, "errorcode")) {
        mcp.ci = &c_PDO::ci_errorcode;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        mcp.ci = &c_PDO::ci_setattribute;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss4f78df74, "exec")) {
        mcp.ci = &c_PDO::ci_exec;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7FF4D594AC38340ELL, NAMSTR(s_sys_ss53c7cbf2, "getavailabledrivers")) {
        mcp.ci = &c_PDO::ci_getavailabledrivers;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x25466EABBA2D7C12LL, NAMSTR(s_sys_ss45d283ee, "lastinsertid")) {
        mcp.ci = &c_PDO::ci_lastinsertid;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss55f7a324, "__wakeup")) {
        mcp.ci = &c_PDO::ci___wakeup;
        return true;
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss7f04605e, "errorinfo")) {
        mcp.ci = &c_PDO::ci_errorinfo;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_PDO::ci___construct;
        return true;
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x24D23BE465E3F324LL, NAMSTR(s_sys_ss65e3f324, "commit")) {
        mcp.ci = &c_PDO::ci_commit;
        return true;
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        mcp.ci = &c_PDO::ci_getattribute;
        return true;
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss25243fd3, "__sleep")) {
        mcp.ci = &c_PDO::ci___sleep;
        return true;
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x1740B14E849464EELL, NAMSTR(s_sys_ss7b6b9b12, "quote")) {
        mcp.ci = &c_PDO::ci_quote;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss4ba591af, "prepare")) {
        mcp.ci = &c_PDO::ci_prepare;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_PDO::ci___destruct;
        return true;
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x374B46BC6D79EC36LL, NAMSTR(s_sys_ss6d79ec36, "rollback")) {
        mcp.ci = &c_PDO::ci_rollback;
        return true;
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        mcp.ci = &c_PDO::ci_query;
        return true;
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x0DE392135C33E23BLL, NAMSTR(s_sys_ss5c33e23b, "begintransaction")) {
        mcp.ci = &c_PDO::ci_begintransaction;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_PDO::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss2372f2c7, "errorcode")) {
        mcp.ci = &c_PDO::ci_errorcode;
        mcp.obj = this;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        mcp.ci = &c_PDO::ci_setattribute;
        mcp.obj = this;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss4f78df74, "exec")) {
        mcp.ci = &c_PDO::ci_exec;
        mcp.obj = this;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7FF4D594AC38340ELL, NAMSTR(s_sys_ss53c7cbf2, "getavailabledrivers")) {
        mcp.ci = &c_PDO::ci_getavailabledrivers;
        mcp.obj = this;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x25466EABBA2D7C12LL, NAMSTR(s_sys_ss45d283ee, "lastinsertid")) {
        mcp.ci = &c_PDO::ci_lastinsertid;
        mcp.obj = this;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss55f7a324, "__wakeup")) {
        mcp.ci = &c_PDO::ci___wakeup;
        mcp.obj = this;
        return true;
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss7f04605e, "errorinfo")) {
        mcp.ci = &c_PDO::ci_errorinfo;
        mcp.obj = this;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_PDO::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x24D23BE465E3F324LL, NAMSTR(s_sys_ss65e3f324, "commit")) {
        mcp.ci = &c_PDO::ci_commit;
        mcp.obj = this;
        return true;
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        mcp.ci = &c_PDO::ci_getattribute;
        mcp.obj = this;
        return true;
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss25243fd3, "__sleep")) {
        mcp.ci = &c_PDO::ci___sleep;
        mcp.obj = this;
        return true;
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x1740B14E849464EELL, NAMSTR(s_sys_ss7b6b9b12, "quote")) {
        mcp.ci = &c_PDO::ci_quote;
        mcp.obj = this;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss4ba591af, "prepare")) {
        mcp.ci = &c_PDO::ci_prepare;
        mcp.obj = this;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_PDO::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x374B46BC6D79EC36LL, NAMSTR(s_sys_ss6d79ec36, "rollback")) {
        mcp.ci = &c_PDO::ci_rollback;
        mcp.obj = this;
        return true;
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        mcp.ci = &c_PDO::ci_query;
        mcp.obj = this;
        return true;
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x0DE392135C33E23BLL, NAMSTR(s_sys_ss5c33e23b, "begintransaction")) {
        mcp.ci = &c_PDO::ci_begintransaction;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_PDO *c_PDO::create(String a0, String a1, String a2, Array a3) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3);
  return this;
}
ObjectData *c_PDO::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 4) throw_wrong_arguments("__construct", count, 1, 4, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1, arg2, arg3));
    } while (false);
  }
  return this;
}
void c_PDO::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) throw_wrong_arguments("__construct", count, 1, 4, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2, arg3));
  } while (false);
}
void c_PDO::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_PDO::ci___construct;
  mcp.obj = this;
}
void c_PDO::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) throw_wrong_arguments("__construct", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else (t___construct(a0, a1, a2, a3), null);
}
struct ObjectStaticCallbacks cw_PDO = {
  c_PDO::os_getInit,
  c_PDO::os_get,
  c_PDO::os_lval,
  c_PDO::os_invoke,
  c_PDO::os_constant,
  c_PDO::os_get_call_info
};
Object co_ImageSprite(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_ImageSprite)())->dynCreate(params, init));
}
Object coo_ImageSprite() {
  Object r(NEW(c_ImageSprite)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ImageSprite
Variant c_ImageSprite::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_ImageSprite
Variant c_ImageSprite::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ImageSprite
Variant &c_ImageSprite::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_ImageSprite
void c_ImageSprite::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_ImageSprite
void c_ImageSprite::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_ImageSprite
Variant * c_ImageSprite::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ImageSprite
Variant * c_ImageSprite::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ImageSprite
Variant * c_ImageSprite::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_ImageSprite
Variant c_ImageSprite::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_ImageSprite
IMPLEMENT_CLASS(ImageSprite)
void c_ImageSprite::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_ImageSprite::cloneImpl() {
  c_ImageSprite *obj = NEW(c_ImageSprite)();
  cloneSet(obj);
  return obj;
}
void c_ImageSprite::cloneSet(c_ImageSprite *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_ImageSprite::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x05D2634BA4310200LL, NAMSTR(s_sys_ss5bcefe00, "getErrors")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("geterrors", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_geterrors());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x6A37A496C57D57A2LL, NAMSTR(s_sys_ss3a82a85e, "loadDims")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("loaddims", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_loaddims());
        else return (t_loaddims(a0));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x31DA235C5A226667LL, NAMSTR(s_sys_ss5a226667, "clear")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clear", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clear());
        else return (t_clear(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x13A96E5A21D1906FLL, NAMSTR(s_sys_ss21d1906f, "addFile")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("addfile", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addfile(a0));
        else return (t_addfile(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x305D94BB2EC0B554LL, NAMSTR(s_sys_ss2ec0b554, "loadImages")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("loadimages", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_loadimages());
        else return (t_loadimages(a0));
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x4D8226FDFA2CA297LL, NAMSTR(s_sys_ss05d35d69, "mapping")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("mapping", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_mapping());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x386BF72B932D233ALL, NAMSTR(s_sys_ss6cd2dcc6, "addString")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("addstring", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_addstring(a0, a1));
        else return (t_addstring(a0, a1, a2));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x63388F643871547CLL, NAMSTR(s_sys_ss3871547c, "css")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("css", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_css(a0));
        else if (count == 2) return (t_css(a0, a1));
        else if (count == 3) return (t_css(a0, a1, a2));
        else return (t_css(a0, a1, a2, a3));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x79CFC8610DC84A7DLL, NAMSTR(s_sys_ss0dc84a7d, "addUrl")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addurl", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addurl(a0));
        else if (count == 2) return (t_addurl(a0, a1));
        else return (t_addurl(a0, a1, a2));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x07B89E83B77C677FLL, NAMSTR(s_sys_ss48839881, "output")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("output", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_output());
        else if (count == 1) return (t_output(a0));
        else if (count == 2) return (t_output(a0, a1));
        else return (t_output(a0, a1, a2));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_ImageSprite::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_ImageSprite::ci_addstring((void*)&c_ImageSprite::i_addstring, (void*)&c_ImageSprite::ifa_addstring, 3, 0, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci_loaddims((void*)&c_ImageSprite::i_loaddims, (void*)&c_ImageSprite::ifa_loaddims, 1, 0, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci___destruct((void*)&c_ImageSprite::i___destruct, (void*)&c_ImageSprite::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci_mapping((void*)&c_ImageSprite::i_mapping, (void*)&c_ImageSprite::ifa_mapping, 0, 0, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci___construct((void*)&c_ImageSprite::i___construct, (void*)&c_ImageSprite::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci_css((void*)&c_ImageSprite::i_css, (void*)&c_ImageSprite::ifa_css, 4, 0, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci_output((void*)&c_ImageSprite::i_output, (void*)&c_ImageSprite::ifa_output, 3, 0, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci_loadimages((void*)&c_ImageSprite::i_loadimages, (void*)&c_ImageSprite::ifa_loadimages, 1, 0, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci_clear((void*)&c_ImageSprite::i_clear, (void*)&c_ImageSprite::ifa_clear, 1, 0, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci_geterrors((void*)&c_ImageSprite::i_geterrors, (void*)&c_ImageSprite::ifa_geterrors, 0, 0, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci_addurl((void*)&c_ImageSprite::i_addurl, (void*)&c_ImageSprite::ifa_addurl, 3, 0, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci_addfile((void*)&c_ImageSprite::i_addfile, (void*)&c_ImageSprite::ifa_addfile, 2, 0, 0x0000000000000000LL);
Variant c_ImageSprite::i_addstring(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("addstring", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_addstring(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_addstring(arg0, arg1, arg2));
  }
}
Variant c_ImageSprite::i_loaddims(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("loaddims", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_loaddims());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_loaddims(arg0));
  }
}
Variant c_ImageSprite::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_ImageSprite::i_mapping(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("mapping", 0, 1);
  return (self->t_mapping());
}
Variant c_ImageSprite::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_ImageSprite::i_css(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("css", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_css(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_css(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_css(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_css(arg0, arg1, arg2, arg3));
  }
}
Variant c_ImageSprite::i_output(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("output", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_output());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_output(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_output(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_output(arg0, arg1, arg2));
  }
}
Variant c_ImageSprite::i_loadimages(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("loadimages", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_loadimages());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_loadimages(arg0));
  }
}
Variant c_ImageSprite::i_clear(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("clear", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_clear());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_clear(arg0));
  }
}
Variant c_ImageSprite::i_geterrors(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("geterrors", 0, 1);
  return (self->t_geterrors());
}
Variant c_ImageSprite::i_addurl(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("addurl", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_addurl(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_addurl(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_addurl(arg0, arg1, arg2));
  }
}
Variant c_ImageSprite::i_addfile(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("addfile", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_addfile(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_addfile(arg0, arg1));
  }
}
Variant c_ImageSprite::ifa_addstring(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("addstring", count, 2, 3, 1);
  if (count <= 2) return (self->t_addstring(a0, a1));
  return (self->t_addstring(a0, a1, a2));
}
Variant c_ImageSprite::ifa_loaddims(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("loaddims", 1, 1);
  if (count <= 0) return (self->t_loaddims());
  return (self->t_loaddims(a0));
}
Variant c_ImageSprite::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_ImageSprite::ifa_mapping(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("mapping", 0, 1);
  return (self->t_mapping());
}
Variant c_ImageSprite::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_ImageSprite::ifa_css(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("css", count, 1, 4, 1);
  if (count <= 1) return (self->t_css(a0));
  if (count == 2) return (self->t_css(a0, a1));
  if (count == 3) return (self->t_css(a0, a1, a2));
  return (self->t_css(a0, a1, a2, a3));
}
Variant c_ImageSprite::ifa_output(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("output", 3, 1);
  if (count <= 0) return (self->t_output());
  if (count == 1) return (self->t_output(a0));
  if (count == 2) return (self->t_output(a0, a1));
  return (self->t_output(a0, a1, a2));
}
Variant c_ImageSprite::ifa_loadimages(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("loadimages", 1, 1);
  if (count <= 0) return (self->t_loadimages());
  return (self->t_loadimages(a0));
}
Variant c_ImageSprite::ifa_clear(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("clear", 1, 1);
  if (count <= 0) return (self->t_clear());
  return (self->t_clear(a0));
}
Variant c_ImageSprite::ifa_geterrors(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("geterrors", 0, 1);
  return (self->t_geterrors());
}
Variant c_ImageSprite::ifa_addurl(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("addurl", count, 1, 3, 1);
  if (count <= 1) return (self->t_addurl(a0));
  if (count == 2) return (self->t_addurl(a0, a1));
  return (self->t_addurl(a0, a1, a2));
}
Variant c_ImageSprite::ifa_addfile(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("addfile", count, 1, 2, 1);
  if (count <= 1) return (self->t_addfile(a0));
  return (self->t_addfile(a0, a1));
}
bool c_ImageSprite::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x05D2634BA4310200LL, NAMSTR(s_sys_ss5bcefe00, "getErrors")) {
        mcp.ci = &c_ImageSprite::ci_geterrors;
        return true;
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x6A37A496C57D57A2LL, NAMSTR(s_sys_ss3a82a85e, "loadDims")) {
        mcp.ci = &c_ImageSprite::ci_loaddims;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x31DA235C5A226667LL, NAMSTR(s_sys_ss5a226667, "clear")) {
        mcp.ci = &c_ImageSprite::ci_clear;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x13A96E5A21D1906FLL, NAMSTR(s_sys_ss21d1906f, "addFile")) {
        mcp.ci = &c_ImageSprite::ci_addfile;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_ImageSprite::ci___destruct;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x305D94BB2EC0B554LL, NAMSTR(s_sys_ss2ec0b554, "loadImages")) {
        mcp.ci = &c_ImageSprite::ci_loadimages;
        return true;
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x4D8226FDFA2CA297LL, NAMSTR(s_sys_ss05d35d69, "mapping")) {
        mcp.ci = &c_ImageSprite::ci_mapping;
        return true;
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x386BF72B932D233ALL, NAMSTR(s_sys_ss6cd2dcc6, "addString")) {
        mcp.ci = &c_ImageSprite::ci_addstring;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x63388F643871547CLL, NAMSTR(s_sys_ss3871547c, "css")) {
        mcp.ci = &c_ImageSprite::ci_css;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x79CFC8610DC84A7DLL, NAMSTR(s_sys_ss0dc84a7d, "addUrl")) {
        mcp.ci = &c_ImageSprite::ci_addurl;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_ImageSprite::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x07B89E83B77C677FLL, NAMSTR(s_sys_ss48839881, "output")) {
        mcp.ci = &c_ImageSprite::ci_output;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_ImageSprite::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x05D2634BA4310200LL, NAMSTR(s_sys_ss5bcefe00, "getErrors")) {
        mcp.ci = &c_ImageSprite::ci_geterrors;
        mcp.obj = this;
        return true;
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x6A37A496C57D57A2LL, NAMSTR(s_sys_ss3a82a85e, "loadDims")) {
        mcp.ci = &c_ImageSprite::ci_loaddims;
        mcp.obj = this;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x31DA235C5A226667LL, NAMSTR(s_sys_ss5a226667, "clear")) {
        mcp.ci = &c_ImageSprite::ci_clear;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x13A96E5A21D1906FLL, NAMSTR(s_sys_ss21d1906f, "addFile")) {
        mcp.ci = &c_ImageSprite::ci_addfile;
        mcp.obj = this;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_ImageSprite::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x305D94BB2EC0B554LL, NAMSTR(s_sys_ss2ec0b554, "loadImages")) {
        mcp.ci = &c_ImageSprite::ci_loadimages;
        mcp.obj = this;
        return true;
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x4D8226FDFA2CA297LL, NAMSTR(s_sys_ss05d35d69, "mapping")) {
        mcp.ci = &c_ImageSprite::ci_mapping;
        mcp.obj = this;
        return true;
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x386BF72B932D233ALL, NAMSTR(s_sys_ss6cd2dcc6, "addString")) {
        mcp.ci = &c_ImageSprite::ci_addstring;
        mcp.obj = this;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x63388F643871547CLL, NAMSTR(s_sys_ss3871547c, "css")) {
        mcp.ci = &c_ImageSprite::ci_css;
        mcp.obj = this;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x79CFC8610DC84A7DLL, NAMSTR(s_sys_ss0dc84a7d, "addUrl")) {
        mcp.ci = &c_ImageSprite::ci_addurl;
        mcp.obj = this;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_ImageSprite::ci___construct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x07B89E83B77C677FLL, NAMSTR(s_sys_ss48839881, "output")) {
        mcp.ci = &c_ImageSprite::ci_output;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_ImageSprite *c_ImageSprite::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_ImageSprite::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_ImageSprite::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_ImageSprite::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_ImageSprite::ci___construct;
  mcp.obj = this;
}
void c_ImageSprite::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_ImageSprite = {
  c_ImageSprite::os_getInit,
  c_ImageSprite::os_get,
  c_ImageSprite::os_lval,
  c_ImageSprite::os_invoke,
  c_ImageSprite::os_constant,
  c_ImageSprite::os_get_call_info
};
Object co_DOMEntity(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMEntity)())->dynCreate(params, init));
}
Object coo_DOMEntity() {
  Object r(NEW(c_DOMEntity)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMEntity
Variant c_DOMEntity::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMEntity
Variant c_DOMEntity::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMEntity
Variant &c_DOMEntity::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMEntity
void c_DOMEntity::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMEntity
void c_DOMEntity::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMEntity
Variant * c_DOMEntity::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMEntity
Variant * c_DOMEntity::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMEntity
Variant * c_DOMEntity::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMEntity
Variant c_DOMEntity::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMEntity
IMPLEMENT_CLASS(DOMEntity)
void c_DOMEntity::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMEntity::cloneImpl() {
  c_DOMEntity *obj = NEW(c_DOMEntity)();
  cloneSet(obj);
  return obj;
}
void c_DOMEntity::cloneSet(c_DOMEntity *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMEntity::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMEntity::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMEntity::ci___destruct((void*)&c_DOMEntity::i___destruct, (void*)&c_DOMEntity::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMEntity::ci___set((void*)&c_DOMEntity::i___set, (void*)&c_DOMEntity::ifa___set, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMEntity::ci___construct((void*)&c_DOMEntity::i___construct, (void*)&c_DOMEntity::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMEntity::ci___get((void*)&c_DOMEntity::i___get, (void*)&c_DOMEntity::ifa___get, 1, 0, 0x0000000000000000LL);
Variant c_DOMEntity::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMEntity *self = NULL;
  p_DOMEntity pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntity*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMEntity::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMEntity *self = NULL;
  p_DOMEntity pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntity*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMEntity::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMEntity *self = NULL;
  p_DOMEntity pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntity*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMEntity::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMEntity *self = NULL;
  p_DOMEntity pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntity*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMEntity::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMEntity *self = NULL;
  p_DOMEntity pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntity*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMEntity::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMEntity *self = NULL;
  p_DOMEntity pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntity*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMEntity::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMEntity *self = NULL;
  p_DOMEntity pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntity*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMEntity::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMEntity *self = NULL;
  p_DOMEntity pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntity*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
bool c_DOMEntity::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMEntity::ci___destruct;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMEntity::ci___set;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMEntity::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMEntity::ci___get;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMEntity::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMEntity::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMEntity::ci___set;
        mcp.obj = this;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMEntity::ci___construct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMEntity::ci___get;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_get_call_info(mcp, hash);
}
c_DOMEntity *c_DOMEntity::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMEntity::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMEntity::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMEntity::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMEntity::ci___construct;
  mcp.obj = this;
}
void c_DOMEntity::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMEntity = {
  c_DOMEntity::os_getInit,
  c_DOMEntity::os_get,
  c_DOMEntity::os_lval,
  c_DOMEntity::os_invoke,
  c_DOMEntity::os_constant,
  c_DOMEntity::os_get_call_info
};
Object co_XMLWriter(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_XMLWriter)())->dynCreate(params, init));
}
Object coo_XMLWriter() {
  Object r(NEW(c_XMLWriter)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_XMLWriter
Variant c_XMLWriter::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_XMLWriter
Variant c_XMLWriter::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_XMLWriter
Variant &c_XMLWriter::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_XMLWriter
void c_XMLWriter::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_XMLWriter
void c_XMLWriter::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_XMLWriter
Variant * c_XMLWriter::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_XMLWriter
Variant * c_XMLWriter::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_XMLWriter
Variant * c_XMLWriter::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_XMLWriter
Variant c_XMLWriter::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_XMLWriter
IMPLEMENT_CLASS(XMLWriter)
void c_XMLWriter::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_XMLWriter::cloneImpl() {
  c_XMLWriter *obj = NEW(c_XMLWriter)();
  cloneSet(obj);
  return obj;
}
void c_XMLWriter::cloneSet(c_XMLWriter *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_XMLWriter::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 2:
      HASH_GUARD_LITSTR(0x1EBCBEA66B6B0982LL, NAMSTR(s_sys_ss6b6b0982, "writeCData")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writecdata(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x55E29E84E96ACF83LL, NAMSTR(s_sys_ss1695307d, "startDTD")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_startdtd(a0));
        else if (count == 2) return (t_startdtd(a0, a1));
        else return (t_startdtd(a0, a1, a2));
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x7C1FF8A79BAB3608LL, NAMSTR(s_sys_ss6454c9f8, "writeDTD")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_writedtd(a0));
        else if (count == 2) return (t_writedtd(a0, a1));
        else if (count == 3) return (t_writedtd(a0, a1, a2));
        else return (t_writedtd(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x119CC9E7C3E7EF0ELL, NAMSTR(s_sys_ss3c1810f2, "openMemory")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_openmemory());
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x0A7FE14C41766610LL, NAMSTR(s_sys_ss41766610, "endCData")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endcdata());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x75F8C992981A4093LL, NAMSTR(s_sys_ss67e5bf6d, "writeComment")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writecomment(a0));
      }
      HASH_GUARD_LITSTR(0x5A7AE5A26994FF13LL, NAMSTR(s_sys_ss6994ff13, "startAttribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startattribute(a0));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x337EFFF3783B919CLL, NAMSTR(s_sys_ss783b919c, "writeElement")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_writeelement(a0));
        else return (t_writeelement(a0, a1));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4D26D167066BB11DLL, NAMSTR(s_sys_ss066bb11d, "text")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_text(a0));
      }
      break;
    case 32:
      HASH_GUARD_LITSTR(0x7DF0368A44C01B20LL, NAMSTR(s_sys_ss44c01b20, "startCData")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startcdata());
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x5D49A460168D5C21LL, NAMSTR(s_sys_ss168d5c21, "endPI")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endpi());
      }
      break;
    case 41:
      HASH_GUARD_LITSTR(0x1D81ABDC9890C5A9LL, NAMSTR(s_sys_ss676f3a57, "writeDTDAttlist")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writedtdattlist(a0, a1));
      }
      break;
    case 43:
      HASH_GUARD_LITSTR(0x0DEAF425F1AD73ABLL, NAMSTR(s_sys_ss0e528c55, "setIndentString")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setindentstring(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x78A7A5D96EF2F4AFLL, NAMSTR(s_sys_ss6ef2f4af, "endElement")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endelement());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x75B357D89DDE6EB5LL, NAMSTR(s_sys_ss6221914b, "endComment")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endcomment());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x4B0F1F6361A59C37LL, NAMSTR(s_sys_ss61a59c37, "writeRaw")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeraw(a0));
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x7FC89CF1AFFB1E38LL, NAMSTR(s_sys_ss5004e1c8, "startDocument")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_startdocument());
        else if (count == 1) return (t_startdocument(a0));
        else if (count == 2) return (t_startdocument(a0, a1));
        else return (t_startdocument(a0, a1, a2));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0D155D1E5C6641BALL, NAMSTR(s_sys_ss5c6641ba, "outputMemory")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_outputmemory());
        else return (t_outputmemory(a0));
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x1FBE635680ADB7BELL, NAMSTR(s_sys_ss7f524842, "openURI")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_openuri(a0));
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x275896BFD7A77144LL, NAMSTR(s_sys_ss28588ebc, "endDTD")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtd());
      }
      break;
    case 70:
      HASH_GUARD_LITSTR(0x5D4650E5C0DAEE46LL, NAMSTR(s_sys_ss3f2511ba, "writeDTDEntity")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_writedtdentity(a0, a1));
        else if (count == 3) return (t_writedtdentity(a0, a1, a2));
        else if (count == 4) return (t_writedtdentity(a0, a1, a2, a3));
        else if (count == 5) return (t_writedtdentity(a0, a1, a2, a3, a4));
        else return (t_writedtdentity(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x017687FD7029CCC7LL, NAMSTR(s_sys_ss7029ccc7, "endDTDElement")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdelement());
      }
      break;
    case 75:
      HASH_GUARD_LITSTR(0x3954A2C0306CCCCBLL, NAMSTR(s_sys_ss306ccccb, "writeAttribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeattribute(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7C43ECE80FF886CBLL, NAMSTR(s_sys_ss0ff886cb, "endAttribute")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endattribute());
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x4F1D890D5B36D24DLL, NAMSTR(s_sys_ss5b36d24d, "startAttributens")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startattributens(a0, a1, a2));
      }
      break;
    case 82:
      HASH_GUARD_LITSTR(0x1357CA1E92397452LL, NAMSTR(s_sys_ss6dc68bae, "writeDTDElement")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writedtdelement(a0, a1));
      }
      break;
    case 84:
      HASH_GUARD_LITSTR(0x154AE94AEFAC7C54LL, NAMSTR(s_sys_ss105383ac, "writeAttributeNS")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeattributens(a0, a1, a2, a3));
      }
      break;
    case 86:
      HASH_GUARD_LITSTR(0x4520735705A382D6LL, NAMSTR(s_sys_ss05a382d6, "endDTDEntity")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdentity());
      }
      HASH_GUARD_LITSTR(0x37D51A94C6EE8F56LL, NAMSTR(s_sys_ss391170aa, "writePI")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writepi(a0, a1));
      }
      break;
    case 88:
      HASH_GUARD_LITSTR(0x24A376E9310BF058LL, NAMSTR(s_sys_ss310bf058, "writeElementNS")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_writeelementns(a0, a1, a2));
        else return (t_writeelementns(a0, a1, a2, a3));
      }
      break;
    case 89:
      HASH_GUARD_LITSTR(0x390B6C01AE7C4159LL, NAMSTR(s_sys_ss5183bea7, "startPI")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startpi(a0));
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x0DC5AC1E0A2F63DCLL, NAMSTR(s_sys_ss0a2f63dc, "endDocument")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddocument());
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x75A033B824EA1ADDLL, NAMSTR(s_sys_ss24ea1add, "startDTDEntity")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdentity(a0, a1));
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 98:
      HASH_GUARD_LITSTR(0x55BFFBE5717EFD62LL, NAMSTR(s_sys_ss717efd62, "startElement")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startelement(a0));
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x349B7446B5EE65E5LL, NAMSTR(s_sys_ss4a119a1b, "setIndent")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setindent(a0));
      }
      break;
    case 105:
      HASH_GUARD_LITSTR(0x608A2D39DE12E169LL, NAMSTR(s_sys_ss21ed1e97, "startElementNS")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startelementns(a0, a1, a2));
      }
      break;
    case 112:
      HASH_GUARD_LITSTR(0x0CBB10FA542B7D70LL, NAMSTR(s_sys_ss542b7d70, "startDTDAttlist")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdattlist(a0));
      }
      break;
    case 113:
      HASH_GUARD_LITSTR(0x496175DBD52E1771LL, NAMSTR(s_sys_ss2ad1e88f, "endDTDAttlist")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdattlist());
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x451436438EBA2AF8LL, NAMSTR(s_sys_ss7145d508, "startDTDElement")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdelement(a0));
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss24ffa186, "flush")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_flush());
        else return (t_flush(a0));
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x3174CCE00BFB9FFELL, NAMSTR(s_sys_ss0bfb9ffe, "fullEndElement")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fullendelement());
      }
      break;
    case 127:
      HASH_GUARD_LITSTR(0x6A8CC27A7F0466FFLL, NAMSTR(s_sys_ss7f0466ff, "startComment")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_XMLWriter::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_XMLWriter::ci_writeelementns((void*)&c_XMLWriter::i_writeelementns, (void*)&c_XMLWriter::ifa_writeelementns, 4, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_outputmemory((void*)&c_XMLWriter::i_outputmemory, (void*)&c_XMLWriter::ifa_outputmemory, 1, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_enddtdattlist((void*)&c_XMLWriter::i_enddtdattlist, (void*)&c_XMLWriter::ifa_enddtdattlist, 0, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_fullendelement((void*)&c_XMLWriter::i_fullendelement, (void*)&c_XMLWriter::ifa_fullendelement, 0, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startdocument((void*)&c_XMLWriter::i_startdocument, (void*)&c_XMLWriter::ifa_startdocument, 3, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startdtdentity((void*)&c_XMLWriter::i_startdtdentity, (void*)&c_XMLWriter::ifa_startdtdentity, 2, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_endcdata((void*)&c_XMLWriter::i_endcdata, (void*)&c_XMLWriter::ifa_endcdata, 0, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writecomment((void*)&c_XMLWriter::i_writecomment, (void*)&c_XMLWriter::ifa_writecomment, 1, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writeattribute((void*)&c_XMLWriter::i_writeattribute, (void*)&c_XMLWriter::ifa_writeattribute, 2, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_endcomment((void*)&c_XMLWriter::i_endcomment, (void*)&c_XMLWriter::ifa_endcomment, 0, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci___destruct((void*)&c_XMLWriter::i___destruct, (void*)&c_XMLWriter::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writedtd((void*)&c_XMLWriter::i_writedtd, (void*)&c_XMLWriter::ifa_writedtd, 4, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci___construct((void*)&c_XMLWriter::i___construct, (void*)&c_XMLWriter::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_enddtdentity((void*)&c_XMLWriter::i_enddtdentity, (void*)&c_XMLWriter::ifa_enddtdentity, 0, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startattributens((void*)&c_XMLWriter::i_startattributens, (void*)&c_XMLWriter::ifa_startattributens, 3, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startelement((void*)&c_XMLWriter::i_startelement, (void*)&c_XMLWriter::ifa_startelement, 1, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startelementns((void*)&c_XMLWriter::i_startelementns, (void*)&c_XMLWriter::ifa_startelementns, 3, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startdtdelement((void*)&c_XMLWriter::i_startdtdelement, (void*)&c_XMLWriter::ifa_startdtdelement, 1, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_enddocument((void*)&c_XMLWriter::i_enddocument, (void*)&c_XMLWriter::ifa_enddocument, 0, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writecdata((void*)&c_XMLWriter::i_writecdata, (void*)&c_XMLWriter::ifa_writecdata, 1, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writedtdelement((void*)&c_XMLWriter::i_writedtdelement, (void*)&c_XMLWriter::ifa_writedtdelement, 2, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writeattributens((void*)&c_XMLWriter::i_writeattributens, (void*)&c_XMLWriter::ifa_writeattributens, 4, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writepi((void*)&c_XMLWriter::i_writepi, (void*)&c_XMLWriter::ifa_writepi, 2, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_setindentstring((void*)&c_XMLWriter::i_setindentstring, (void*)&c_XMLWriter::ifa_setindentstring, 1, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startattribute((void*)&c_XMLWriter::i_startattribute, (void*)&c_XMLWriter::ifa_startattribute, 1, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writeelement((void*)&c_XMLWriter::i_writeelement, (void*)&c_XMLWriter::ifa_writeelement, 2, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_endelement((void*)&c_XMLWriter::i_endelement, (void*)&c_XMLWriter::ifa_endelement, 0, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writeraw((void*)&c_XMLWriter::i_writeraw, (void*)&c_XMLWriter::ifa_writeraw, 1, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writedtdentity((void*)&c_XMLWriter::i_writedtdentity, (void*)&c_XMLWriter::ifa_writedtdentity, 6, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_endpi((void*)&c_XMLWriter::i_endpi, (void*)&c_XMLWriter::ifa_endpi, 0, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startdtd((void*)&c_XMLWriter::i_startdtd, (void*)&c_XMLWriter::ifa_startdtd, 3, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_setindent((void*)&c_XMLWriter::i_setindent, (void*)&c_XMLWriter::ifa_setindent, 1, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_enddtdelement((void*)&c_XMLWriter::i_enddtdelement, (void*)&c_XMLWriter::ifa_enddtdelement, 0, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startdtdattlist((void*)&c_XMLWriter::i_startdtdattlist, (void*)&c_XMLWriter::ifa_startdtdattlist, 1, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startcdata((void*)&c_XMLWriter::i_startcdata, (void*)&c_XMLWriter::ifa_startcdata, 0, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writedtdattlist((void*)&c_XMLWriter::i_writedtdattlist, (void*)&c_XMLWriter::ifa_writedtdattlist, 2, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_enddtd((void*)&c_XMLWriter::i_enddtd, (void*)&c_XMLWriter::ifa_enddtd, 0, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_openuri((void*)&c_XMLWriter::i_openuri, (void*)&c_XMLWriter::ifa_openuri, 1, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_openmemory((void*)&c_XMLWriter::i_openmemory, (void*)&c_XMLWriter::ifa_openmemory, 0, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_endattribute((void*)&c_XMLWriter::i_endattribute, (void*)&c_XMLWriter::ifa_endattribute, 0, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startpi((void*)&c_XMLWriter::i_startpi, (void*)&c_XMLWriter::ifa_startpi, 1, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_text((void*)&c_XMLWriter::i_text, (void*)&c_XMLWriter::ifa_text, 1, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_flush((void*)&c_XMLWriter::i_flush, (void*)&c_XMLWriter::ifa_flush, 1, 0, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startcomment((void*)&c_XMLWriter::i_startcomment, (void*)&c_XMLWriter::ifa_startcomment, 0, 0, 0x0000000000000000LL);
Variant c_XMLWriter::i_writeelementns(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (self->t_writeelementns(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_writeelementns(arg0, arg1, arg2, arg3));
  }
}
Variant c_XMLWriter::i_outputmemory(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_outputmemory());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_outputmemory(arg0));
  }
}
Variant c_XMLWriter::i_enddtdattlist(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
  return (self->t_enddtdattlist());
}
Variant c_XMLWriter::i_fullendelement(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
  return (self->t_fullendelement());
}
Variant c_XMLWriter::i_startdocument(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_startdocument());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_startdocument(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_startdocument(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_startdocument(arg0, arg1, arg2));
  }
}
Variant c_XMLWriter::i_startdtdentity(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_startdtdentity(arg0, arg1));
  }
}
Variant c_XMLWriter::i_endcdata(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
  return (self->t_endcdata());
}
Variant c_XMLWriter::i_writecomment(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_writecomment(arg0));
  }
}
Variant c_XMLWriter::i_writeattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_writeattribute(arg0, arg1));
  }
}
Variant c_XMLWriter::i_endcomment(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
  return (self->t_endcomment());
}
Variant c_XMLWriter::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_XMLWriter::i_writedtd(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_writedtd(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_writedtd(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_writedtd(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_writedtd(arg0, arg1, arg2, arg3));
  }
}
Variant c_XMLWriter::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_XMLWriter::i_enddtdentity(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
  return (self->t_enddtdentity());
}
Variant c_XMLWriter::i_startattributens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_startattributens(arg0, arg1, arg2));
  }
}
Variant c_XMLWriter::i_startelement(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_startelement(arg0));
  }
}
Variant c_XMLWriter::i_startelementns(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_startelementns(arg0, arg1, arg2));
  }
}
Variant c_XMLWriter::i_startdtdelement(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_startdtdelement(arg0));
  }
}
Variant c_XMLWriter::i_enddocument(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
  return (self->t_enddocument());
}
Variant c_XMLWriter::i_writecdata(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_writecdata(arg0));
  }
}
Variant c_XMLWriter::i_writedtdelement(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_writedtdelement(arg0, arg1));
  }
}
Variant c_XMLWriter::i_writeattributens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_writeattributens(arg0, arg1, arg2, arg3));
  }
}
Variant c_XMLWriter::i_writepi(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_writepi(arg0, arg1));
  }
}
Variant c_XMLWriter::i_setindentstring(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setindentstring(arg0));
  }
}
Variant c_XMLWriter::i_startattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_startattribute(arg0));
  }
}
Variant c_XMLWriter::i_writeelement(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_writeelement(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_writeelement(arg0, arg1));
  }
}
Variant c_XMLWriter::i_endelement(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
  return (self->t_endelement());
}
Variant c_XMLWriter::i_writeraw(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_writeraw(arg0));
  }
}
Variant c_XMLWriter::i_writedtdentity(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_writedtdentity(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_writedtdentity(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t_writedtdentity(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (self->t_writedtdentity(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_writedtdentity(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant c_XMLWriter::i_endpi(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
  return (self->t_endpi());
}
Variant c_XMLWriter::i_startdtd(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_startdtd(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_startdtd(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_startdtd(arg0, arg1, arg2));
  }
}
Variant c_XMLWriter::i_setindent(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setindent(arg0));
  }
}
Variant c_XMLWriter::i_enddtdelement(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
  return (self->t_enddtdelement());
}
Variant c_XMLWriter::i_startdtdattlist(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_startdtdattlist(arg0));
  }
}
Variant c_XMLWriter::i_startcdata(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
  return (self->t_startcdata());
}
Variant c_XMLWriter::i_writedtdattlist(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_writedtdattlist(arg0, arg1));
  }
}
Variant c_XMLWriter::i_enddtd(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
  return (self->t_enddtd());
}
Variant c_XMLWriter::i_openuri(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_openuri(arg0));
  }
}
Variant c_XMLWriter::i_openmemory(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
  return (self->t_openmemory());
}
Variant c_XMLWriter::i_endattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
  return (self->t_endattribute());
}
Variant c_XMLWriter::i_startpi(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_startpi(arg0));
  }
}
Variant c_XMLWriter::i_text(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_text(arg0));
  }
}
Variant c_XMLWriter::i_flush(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("flush", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_flush());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_flush(arg0));
  }
}
Variant c_XMLWriter::i_startcomment(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
  return (self->t_startcomment());
}
Variant c_XMLWriter::ifa_writeelementns(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
  if (count <= 3) return (self->t_writeelementns(a0, a1, a2));
  return (self->t_writeelementns(a0, a1, a2, a3));
}
Variant c_XMLWriter::ifa_outputmemory(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
  if (count <= 0) return (self->t_outputmemory());
  return (self->t_outputmemory(a0));
}
Variant c_XMLWriter::ifa_enddtdattlist(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
  return (self->t_enddtdattlist());
}
Variant c_XMLWriter::ifa_fullendelement(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
  return (self->t_fullendelement());
}
Variant c_XMLWriter::ifa_startdocument(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
  if (count <= 0) return (self->t_startdocument());
  if (count == 1) return (self->t_startdocument(a0));
  if (count == 2) return (self->t_startdocument(a0, a1));
  return (self->t_startdocument(a0, a1, a2));
}
Variant c_XMLWriter::ifa_startdtdentity(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
  return (self->t_startdtdentity(a0, a1));
}
Variant c_XMLWriter::ifa_endcdata(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
  return (self->t_endcdata());
}
Variant c_XMLWriter::ifa_writecomment(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
  return (self->t_writecomment(a0));
}
Variant c_XMLWriter::ifa_writeattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
  return (self->t_writeattribute(a0, a1));
}
Variant c_XMLWriter::ifa_endcomment(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
  return (self->t_endcomment());
}
Variant c_XMLWriter::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_XMLWriter::ifa_writedtd(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
  if (count <= 1) return (self->t_writedtd(a0));
  if (count == 2) return (self->t_writedtd(a0, a1));
  if (count == 3) return (self->t_writedtd(a0, a1, a2));
  return (self->t_writedtd(a0, a1, a2, a3));
}
Variant c_XMLWriter::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_XMLWriter::ifa_enddtdentity(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
  return (self->t_enddtdentity());
}
Variant c_XMLWriter::ifa_startattributens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
  return (self->t_startattributens(a0, a1, a2));
}
Variant c_XMLWriter::ifa_startelement(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
  return (self->t_startelement(a0));
}
Variant c_XMLWriter::ifa_startelementns(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
  return (self->t_startelementns(a0, a1, a2));
}
Variant c_XMLWriter::ifa_startdtdelement(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
  return (self->t_startdtdelement(a0));
}
Variant c_XMLWriter::ifa_enddocument(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
  return (self->t_enddocument());
}
Variant c_XMLWriter::ifa_writecdata(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
  return (self->t_writecdata(a0));
}
Variant c_XMLWriter::ifa_writedtdelement(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
  return (self->t_writedtdelement(a0, a1));
}
Variant c_XMLWriter::ifa_writeattributens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
  return (self->t_writeattributens(a0, a1, a2, a3));
}
Variant c_XMLWriter::ifa_writepi(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
  return (self->t_writepi(a0, a1));
}
Variant c_XMLWriter::ifa_setindentstring(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
  return (self->t_setindentstring(a0));
}
Variant c_XMLWriter::ifa_startattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
  return (self->t_startattribute(a0));
}
Variant c_XMLWriter::ifa_writeelement(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
  if (count <= 1) return (self->t_writeelement(a0));
  return (self->t_writeelement(a0, a1));
}
Variant c_XMLWriter::ifa_endelement(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
  return (self->t_endelement());
}
Variant c_XMLWriter::ifa_writeraw(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
  return (self->t_writeraw(a0));
}
Variant c_XMLWriter::ifa_writedtdentity(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
  if (count <= 2) return (self->t_writedtdentity(a0, a1));
  if (count == 3) return (self->t_writedtdentity(a0, a1, a2));
  if (count == 4) return (self->t_writedtdentity(a0, a1, a2, a3));
  if (count == 5) return (self->t_writedtdentity(a0, a1, a2, a3, a4));
  return (self->t_writedtdentity(a0, a1, a2, a3, a4, a5));
}
Variant c_XMLWriter::ifa_endpi(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
  return (self->t_endpi());
}
Variant c_XMLWriter::ifa_startdtd(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
  if (count <= 1) return (self->t_startdtd(a0));
  if (count == 2) return (self->t_startdtd(a0, a1));
  return (self->t_startdtd(a0, a1, a2));
}
Variant c_XMLWriter::ifa_setindent(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
  return (self->t_setindent(a0));
}
Variant c_XMLWriter::ifa_enddtdelement(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
  return (self->t_enddtdelement());
}
Variant c_XMLWriter::ifa_startdtdattlist(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
  return (self->t_startdtdattlist(a0));
}
Variant c_XMLWriter::ifa_startcdata(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
  return (self->t_startcdata());
}
Variant c_XMLWriter::ifa_writedtdattlist(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
  return (self->t_writedtdattlist(a0, a1));
}
Variant c_XMLWriter::ifa_enddtd(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
  return (self->t_enddtd());
}
Variant c_XMLWriter::ifa_openuri(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
  return (self->t_openuri(a0));
}
Variant c_XMLWriter::ifa_openmemory(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
  return (self->t_openmemory());
}
Variant c_XMLWriter::ifa_endattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
  return (self->t_endattribute());
}
Variant c_XMLWriter::ifa_startpi(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
  return (self->t_startpi(a0));
}
Variant c_XMLWriter::ifa_text(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
  return (self->t_text(a0));
}
Variant c_XMLWriter::ifa_flush(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("flush", 1, 1);
  if (count <= 0) return (self->t_flush());
  return (self->t_flush(a0));
}
Variant c_XMLWriter::ifa_startcomment(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
  return (self->t_startcomment());
}
bool c_XMLWriter::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 127) {
    case 2:
      HASH_GUARD_LITSTR(0x1EBCBEA66B6B0982LL, NAMSTR(s_sys_ss6b6b0982, "writeCData")) {
        mcp.ci = &c_XMLWriter::ci_writecdata;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x55E29E84E96ACF83LL, NAMSTR(s_sys_ss1695307d, "startDTD")) {
        mcp.ci = &c_XMLWriter::ci_startdtd;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x7C1FF8A79BAB3608LL, NAMSTR(s_sys_ss6454c9f8, "writeDTD")) {
        mcp.ci = &c_XMLWriter::ci_writedtd;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x119CC9E7C3E7EF0ELL, NAMSTR(s_sys_ss3c1810f2, "openMemory")) {
        mcp.ci = &c_XMLWriter::ci_openmemory;
        return true;
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x0A7FE14C41766610LL, NAMSTR(s_sys_ss41766610, "endCData")) {
        mcp.ci = &c_XMLWriter::ci_endcdata;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x75F8C992981A4093LL, NAMSTR(s_sys_ss67e5bf6d, "writeComment")) {
        mcp.ci = &c_XMLWriter::ci_writecomment;
        return true;
      }
      HASH_GUARD_LITSTR(0x5A7AE5A26994FF13LL, NAMSTR(s_sys_ss6994ff13, "startAttribute")) {
        mcp.ci = &c_XMLWriter::ci_startattribute;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x337EFFF3783B919CLL, NAMSTR(s_sys_ss783b919c, "writeElement")) {
        mcp.ci = &c_XMLWriter::ci_writeelement;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4D26D167066BB11DLL, NAMSTR(s_sys_ss066bb11d, "text")) {
        mcp.ci = &c_XMLWriter::ci_text;
        return true;
      }
      break;
    case 32:
      HASH_GUARD_LITSTR(0x7DF0368A44C01B20LL, NAMSTR(s_sys_ss44c01b20, "startCData")) {
        mcp.ci = &c_XMLWriter::ci_startcdata;
        return true;
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x5D49A460168D5C21LL, NAMSTR(s_sys_ss168d5c21, "endPI")) {
        mcp.ci = &c_XMLWriter::ci_endpi;
        return true;
      }
      break;
    case 41:
      HASH_GUARD_LITSTR(0x1D81ABDC9890C5A9LL, NAMSTR(s_sys_ss676f3a57, "writeDTDAttlist")) {
        mcp.ci = &c_XMLWriter::ci_writedtdattlist;
        return true;
      }
      break;
    case 43:
      HASH_GUARD_LITSTR(0x0DEAF425F1AD73ABLL, NAMSTR(s_sys_ss0e528c55, "setIndentString")) {
        mcp.ci = &c_XMLWriter::ci_setindentstring;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x78A7A5D96EF2F4AFLL, NAMSTR(s_sys_ss6ef2f4af, "endElement")) {
        mcp.ci = &c_XMLWriter::ci_endelement;
        return true;
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x75B357D89DDE6EB5LL, NAMSTR(s_sys_ss6221914b, "endComment")) {
        mcp.ci = &c_XMLWriter::ci_endcomment;
        return true;
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x4B0F1F6361A59C37LL, NAMSTR(s_sys_ss61a59c37, "writeRaw")) {
        mcp.ci = &c_XMLWriter::ci_writeraw;
        return true;
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x7FC89CF1AFFB1E38LL, NAMSTR(s_sys_ss5004e1c8, "startDocument")) {
        mcp.ci = &c_XMLWriter::ci_startdocument;
        return true;
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0D155D1E5C6641BALL, NAMSTR(s_sys_ss5c6641ba, "outputMemory")) {
        mcp.ci = &c_XMLWriter::ci_outputmemory;
        return true;
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x1FBE635680ADB7BELL, NAMSTR(s_sys_ss7f524842, "openURI")) {
        mcp.ci = &c_XMLWriter::ci_openuri;
        return true;
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x275896BFD7A77144LL, NAMSTR(s_sys_ss28588ebc, "endDTD")) {
        mcp.ci = &c_XMLWriter::ci_enddtd;
        return true;
      }
      break;
    case 70:
      HASH_GUARD_LITSTR(0x5D4650E5C0DAEE46LL, NAMSTR(s_sys_ss3f2511ba, "writeDTDEntity")) {
        mcp.ci = &c_XMLWriter::ci_writedtdentity;
        return true;
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x017687FD7029CCC7LL, NAMSTR(s_sys_ss7029ccc7, "endDTDElement")) {
        mcp.ci = &c_XMLWriter::ci_enddtdelement;
        return true;
      }
      break;
    case 75:
      HASH_GUARD_LITSTR(0x3954A2C0306CCCCBLL, NAMSTR(s_sys_ss306ccccb, "writeAttribute")) {
        mcp.ci = &c_XMLWriter::ci_writeattribute;
        return true;
      }
      HASH_GUARD_LITSTR(0x7C43ECE80FF886CBLL, NAMSTR(s_sys_ss0ff886cb, "endAttribute")) {
        mcp.ci = &c_XMLWriter::ci_endattribute;
        return true;
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x4F1D890D5B36D24DLL, NAMSTR(s_sys_ss5b36d24d, "startAttributens")) {
        mcp.ci = &c_XMLWriter::ci_startattributens;
        return true;
      }
      break;
    case 82:
      HASH_GUARD_LITSTR(0x1357CA1E92397452LL, NAMSTR(s_sys_ss6dc68bae, "writeDTDElement")) {
        mcp.ci = &c_XMLWriter::ci_writedtdelement;
        return true;
      }
      break;
    case 84:
      HASH_GUARD_LITSTR(0x154AE94AEFAC7C54LL, NAMSTR(s_sys_ss105383ac, "writeAttributeNS")) {
        mcp.ci = &c_XMLWriter::ci_writeattributens;
        return true;
      }
      break;
    case 86:
      HASH_GUARD_LITSTR(0x4520735705A382D6LL, NAMSTR(s_sys_ss05a382d6, "endDTDEntity")) {
        mcp.ci = &c_XMLWriter::ci_enddtdentity;
        return true;
      }
      HASH_GUARD_LITSTR(0x37D51A94C6EE8F56LL, NAMSTR(s_sys_ss391170aa, "writePI")) {
        mcp.ci = &c_XMLWriter::ci_writepi;
        return true;
      }
      break;
    case 88:
      HASH_GUARD_LITSTR(0x24A376E9310BF058LL, NAMSTR(s_sys_ss310bf058, "writeElementNS")) {
        mcp.ci = &c_XMLWriter::ci_writeelementns;
        return true;
      }
      break;
    case 89:
      HASH_GUARD_LITSTR(0x390B6C01AE7C4159LL, NAMSTR(s_sys_ss5183bea7, "startPI")) {
        mcp.ci = &c_XMLWriter::ci_startpi;
        return true;
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x0DC5AC1E0A2F63DCLL, NAMSTR(s_sys_ss0a2f63dc, "endDocument")) {
        mcp.ci = &c_XMLWriter::ci_enddocument;
        return true;
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x75A033B824EA1ADDLL, NAMSTR(s_sys_ss24ea1add, "startDTDEntity")) {
        mcp.ci = &c_XMLWriter::ci_startdtdentity;
        return true;
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_XMLWriter::ci___construct;
        return true;
      }
      break;
    case 98:
      HASH_GUARD_LITSTR(0x55BFFBE5717EFD62LL, NAMSTR(s_sys_ss717efd62, "startElement")) {
        mcp.ci = &c_XMLWriter::ci_startelement;
        return true;
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x349B7446B5EE65E5LL, NAMSTR(s_sys_ss4a119a1b, "setIndent")) {
        mcp.ci = &c_XMLWriter::ci_setindent;
        return true;
      }
      break;
    case 105:
      HASH_GUARD_LITSTR(0x608A2D39DE12E169LL, NAMSTR(s_sys_ss21ed1e97, "startElementNS")) {
        mcp.ci = &c_XMLWriter::ci_startelementns;
        return true;
      }
      break;
    case 112:
      HASH_GUARD_LITSTR(0x0CBB10FA542B7D70LL, NAMSTR(s_sys_ss542b7d70, "startDTDAttlist")) {
        mcp.ci = &c_XMLWriter::ci_startdtdattlist;
        return true;
      }
      break;
    case 113:
      HASH_GUARD_LITSTR(0x496175DBD52E1771LL, NAMSTR(s_sys_ss2ad1e88f, "endDTDAttlist")) {
        mcp.ci = &c_XMLWriter::ci_enddtdattlist;
        return true;
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_XMLWriter::ci___destruct;
        return true;
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x451436438EBA2AF8LL, NAMSTR(s_sys_ss7145d508, "startDTDElement")) {
        mcp.ci = &c_XMLWriter::ci_startdtdelement;
        return true;
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss24ffa186, "flush")) {
        mcp.ci = &c_XMLWriter::ci_flush;
        return true;
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x3174CCE00BFB9FFELL, NAMSTR(s_sys_ss0bfb9ffe, "fullEndElement")) {
        mcp.ci = &c_XMLWriter::ci_fullendelement;
        return true;
      }
      break;
    case 127:
      HASH_GUARD_LITSTR(0x6A8CC27A7F0466FFLL, NAMSTR(s_sys_ss7f0466ff, "startComment")) {
        mcp.ci = &c_XMLWriter::ci_startcomment;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_XMLWriter::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 127) {
    case 2:
      HASH_GUARD_LITSTR(0x1EBCBEA66B6B0982LL, NAMSTR(s_sys_ss6b6b0982, "writeCData")) {
        mcp.ci = &c_XMLWriter::ci_writecdata;
        mcp.obj = this;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x55E29E84E96ACF83LL, NAMSTR(s_sys_ss1695307d, "startDTD")) {
        mcp.ci = &c_XMLWriter::ci_startdtd;
        mcp.obj = this;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x7C1FF8A79BAB3608LL, NAMSTR(s_sys_ss6454c9f8, "writeDTD")) {
        mcp.ci = &c_XMLWriter::ci_writedtd;
        mcp.obj = this;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x119CC9E7C3E7EF0ELL, NAMSTR(s_sys_ss3c1810f2, "openMemory")) {
        mcp.ci = &c_XMLWriter::ci_openmemory;
        mcp.obj = this;
        return true;
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x0A7FE14C41766610LL, NAMSTR(s_sys_ss41766610, "endCData")) {
        mcp.ci = &c_XMLWriter::ci_endcdata;
        mcp.obj = this;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x75F8C992981A4093LL, NAMSTR(s_sys_ss67e5bf6d, "writeComment")) {
        mcp.ci = &c_XMLWriter::ci_writecomment;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x5A7AE5A26994FF13LL, NAMSTR(s_sys_ss6994ff13, "startAttribute")) {
        mcp.ci = &c_XMLWriter::ci_startattribute;
        mcp.obj = this;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x337EFFF3783B919CLL, NAMSTR(s_sys_ss783b919c, "writeElement")) {
        mcp.ci = &c_XMLWriter::ci_writeelement;
        mcp.obj = this;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4D26D167066BB11DLL, NAMSTR(s_sys_ss066bb11d, "text")) {
        mcp.ci = &c_XMLWriter::ci_text;
        mcp.obj = this;
        return true;
      }
      break;
    case 32:
      HASH_GUARD_LITSTR(0x7DF0368A44C01B20LL, NAMSTR(s_sys_ss44c01b20, "startCData")) {
        mcp.ci = &c_XMLWriter::ci_startcdata;
        mcp.obj = this;
        return true;
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x5D49A460168D5C21LL, NAMSTR(s_sys_ss168d5c21, "endPI")) {
        mcp.ci = &c_XMLWriter::ci_endpi;
        mcp.obj = this;
        return true;
      }
      break;
    case 41:
      HASH_GUARD_LITSTR(0x1D81ABDC9890C5A9LL, NAMSTR(s_sys_ss676f3a57, "writeDTDAttlist")) {
        mcp.ci = &c_XMLWriter::ci_writedtdattlist;
        mcp.obj = this;
        return true;
      }
      break;
    case 43:
      HASH_GUARD_LITSTR(0x0DEAF425F1AD73ABLL, NAMSTR(s_sys_ss0e528c55, "setIndentString")) {
        mcp.ci = &c_XMLWriter::ci_setindentstring;
        mcp.obj = this;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x78A7A5D96EF2F4AFLL, NAMSTR(s_sys_ss6ef2f4af, "endElement")) {
        mcp.ci = &c_XMLWriter::ci_endelement;
        mcp.obj = this;
        return true;
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x75B357D89DDE6EB5LL, NAMSTR(s_sys_ss6221914b, "endComment")) {
        mcp.ci = &c_XMLWriter::ci_endcomment;
        mcp.obj = this;
        return true;
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x4B0F1F6361A59C37LL, NAMSTR(s_sys_ss61a59c37, "writeRaw")) {
        mcp.ci = &c_XMLWriter::ci_writeraw;
        mcp.obj = this;
        return true;
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x7FC89CF1AFFB1E38LL, NAMSTR(s_sys_ss5004e1c8, "startDocument")) {
        mcp.ci = &c_XMLWriter::ci_startdocument;
        mcp.obj = this;
        return true;
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0D155D1E5C6641BALL, NAMSTR(s_sys_ss5c6641ba, "outputMemory")) {
        mcp.ci = &c_XMLWriter::ci_outputmemory;
        mcp.obj = this;
        return true;
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x1FBE635680ADB7BELL, NAMSTR(s_sys_ss7f524842, "openURI")) {
        mcp.ci = &c_XMLWriter::ci_openuri;
        mcp.obj = this;
        return true;
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x275896BFD7A77144LL, NAMSTR(s_sys_ss28588ebc, "endDTD")) {
        mcp.ci = &c_XMLWriter::ci_enddtd;
        mcp.obj = this;
        return true;
      }
      break;
    case 70:
      HASH_GUARD_LITSTR(0x5D4650E5C0DAEE46LL, NAMSTR(s_sys_ss3f2511ba, "writeDTDEntity")) {
        mcp.ci = &c_XMLWriter::ci_writedtdentity;
        mcp.obj = this;
        return true;
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x017687FD7029CCC7LL, NAMSTR(s_sys_ss7029ccc7, "endDTDElement")) {
        mcp.ci = &c_XMLWriter::ci_enddtdelement;
        mcp.obj = this;
        return true;
      }
      break;
    case 75:
      HASH_GUARD_LITSTR(0x3954A2C0306CCCCBLL, NAMSTR(s_sys_ss306ccccb, "writeAttribute")) {
        mcp.ci = &c_XMLWriter::ci_writeattribute;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x7C43ECE80FF886CBLL, NAMSTR(s_sys_ss0ff886cb, "endAttribute")) {
        mcp.ci = &c_XMLWriter::ci_endattribute;
        mcp.obj = this;
        return true;
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x4F1D890D5B36D24DLL, NAMSTR(s_sys_ss5b36d24d, "startAttributens")) {
        mcp.ci = &c_XMLWriter::ci_startattributens;
        mcp.obj = this;
        return true;
      }
      break;
    case 82:
      HASH_GUARD_LITSTR(0x1357CA1E92397452LL, NAMSTR(s_sys_ss6dc68bae, "writeDTDElement")) {
        mcp.ci = &c_XMLWriter::ci_writedtdelement;
        mcp.obj = this;
        return true;
      }
      break;
    case 84:
      HASH_GUARD_LITSTR(0x154AE94AEFAC7C54LL, NAMSTR(s_sys_ss105383ac, "writeAttributeNS")) {
        mcp.ci = &c_XMLWriter::ci_writeattributens;
        mcp.obj = this;
        return true;
      }
      break;
    case 86:
      HASH_GUARD_LITSTR(0x4520735705A382D6LL, NAMSTR(s_sys_ss05a382d6, "endDTDEntity")) {
        mcp.ci = &c_XMLWriter::ci_enddtdentity;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x37D51A94C6EE8F56LL, NAMSTR(s_sys_ss391170aa, "writePI")) {
        mcp.ci = &c_XMLWriter::ci_writepi;
        mcp.obj = this;
        return true;
      }
      break;
    case 88:
      HASH_GUARD_LITSTR(0x24A376E9310BF058LL, NAMSTR(s_sys_ss310bf058, "writeElementNS")) {
        mcp.ci = &c_XMLWriter::ci_writeelementns;
        mcp.obj = this;
        return true;
      }
      break;
    case 89:
      HASH_GUARD_LITSTR(0x390B6C01AE7C4159LL, NAMSTR(s_sys_ss5183bea7, "startPI")) {
        mcp.ci = &c_XMLWriter::ci_startpi;
        mcp.obj = this;
        return true;
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x0DC5AC1E0A2F63DCLL, NAMSTR(s_sys_ss0a2f63dc, "endDocument")) {
        mcp.ci = &c_XMLWriter::ci_enddocument;
        mcp.obj = this;
        return true;
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x75A033B824EA1ADDLL, NAMSTR(s_sys_ss24ea1add, "startDTDEntity")) {
        mcp.ci = &c_XMLWriter::ci_startdtdentity;
        mcp.obj = this;
        return true;
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_XMLWriter::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    case 98:
      HASH_GUARD_LITSTR(0x55BFFBE5717EFD62LL, NAMSTR(s_sys_ss717efd62, "startElement")) {
        mcp.ci = &c_XMLWriter::ci_startelement;
        mcp.obj = this;
        return true;
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x349B7446B5EE65E5LL, NAMSTR(s_sys_ss4a119a1b, "setIndent")) {
        mcp.ci = &c_XMLWriter::ci_setindent;
        mcp.obj = this;
        return true;
      }
      break;
    case 105:
      HASH_GUARD_LITSTR(0x608A2D39DE12E169LL, NAMSTR(s_sys_ss21ed1e97, "startElementNS")) {
        mcp.ci = &c_XMLWriter::ci_startelementns;
        mcp.obj = this;
        return true;
      }
      break;
    case 112:
      HASH_GUARD_LITSTR(0x0CBB10FA542B7D70LL, NAMSTR(s_sys_ss542b7d70, "startDTDAttlist")) {
        mcp.ci = &c_XMLWriter::ci_startdtdattlist;
        mcp.obj = this;
        return true;
      }
      break;
    case 113:
      HASH_GUARD_LITSTR(0x496175DBD52E1771LL, NAMSTR(s_sys_ss2ad1e88f, "endDTDAttlist")) {
        mcp.ci = &c_XMLWriter::ci_enddtdattlist;
        mcp.obj = this;
        return true;
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_XMLWriter::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x451436438EBA2AF8LL, NAMSTR(s_sys_ss7145d508, "startDTDElement")) {
        mcp.ci = &c_XMLWriter::ci_startdtdelement;
        mcp.obj = this;
        return true;
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss24ffa186, "flush")) {
        mcp.ci = &c_XMLWriter::ci_flush;
        mcp.obj = this;
        return true;
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x3174CCE00BFB9FFELL, NAMSTR(s_sys_ss0bfb9ffe, "fullEndElement")) {
        mcp.ci = &c_XMLWriter::ci_fullendelement;
        mcp.obj = this;
        return true;
      }
      break;
    case 127:
      HASH_GUARD_LITSTR(0x6A8CC27A7F0466FFLL, NAMSTR(s_sys_ss7f0466ff, "startComment")) {
        mcp.ci = &c_XMLWriter::ci_startcomment;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_XMLWriter *c_XMLWriter::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_XMLWriter::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_XMLWriter::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_XMLWriter::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_XMLWriter::ci___construct;
  mcp.obj = this;
}
void c_XMLWriter::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_XMLWriter = {
  c_XMLWriter::os_getInit,
  c_XMLWriter::os_get,
  c_XMLWriter::os_lval,
  c_XMLWriter::os_invoke,
  c_XMLWriter::os_constant,
  c_XMLWriter::os_get_call_info
};
Object co_DOMException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMException)())->dynCreate(params, init));
}
Object coo_DOMException() {
  Object r(NEW(c_DOMException)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMException
Variant c_DOMException::os_getInit(CStrRef s) {
  return c_Exception::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMException
Variant c_DOMException::os_get(CStrRef s) {
  return c_Exception::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMException
Variant &c_DOMException::os_lval(CStrRef s) {
  return c_Exception::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMException
void c_DOMException::o_getArray(Array &props) const {
  c_Exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMException
void c_DOMException::o_setArray(CArrRef props) {
  c_Exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMException
Variant * c_DOMException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMException
Variant * c_DOMException::o_realPropPublic(CStrRef s, int flags) const {
  return c_Exception::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMException
Variant * c_DOMException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMException
Variant c_DOMException::os_constant(const char *s) {
  return c_Exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMException
IMPLEMENT_CLASS(DOMException)
void c_DOMException::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMException::cloneImpl() {
  c_DOMException *obj = NEW(c_DOMException)();
  cloneSet(obj);
  return obj;
}
void c_DOMException::cloneSet(c_DOMException *clone) {
  c_Exception::cloneSet(clone);
}
Variant c_DOMException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_Exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_Exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMException::ci___destruct((void*)&c_DOMException::i___destruct, (void*)&c_DOMException::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMException::ci___construct((void*)&c_DOMException::i___construct, (void*)&c_DOMException::ifa___construct, 2, 0, 0x0000000000000000LL);
Variant c_DOMException::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMException *self = NULL;
  p_DOMException pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMException::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMException *self = NULL;
  p_DOMException pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t___construct(), null);
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_DOMException::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMException *self = NULL;
  p_DOMException pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMException::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMException *self = NULL;
  p_DOMException pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
  if (count <= 0) return (self->t___construct(), null);
  if (count == 1) return (self->t___construct(a0), null);
  return (self->t___construct(a0, a1), null);
}
bool c_DOMException::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMException::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMException::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_Exception::os_get_call_info(mcp, hash);
}
bool c_DOMException::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMException::ci___destruct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMException::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_Exception::o_get_call_info(mcp, hash);
}
c_DOMException *c_DOMException::create(String a0, int64 a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_DOMException::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("__construct", 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      if (count == 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_DOMException::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_DOMException::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMException::ci___construct;
  mcp.obj = this;
}
void c_DOMException::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
struct ObjectStaticCallbacks cw_DOMException = {
  c_DOMException::os_getInit,
  c_DOMException::os_get,
  c_DOMException::os_lval,
  c_DOMException::os_invoke,
  c_DOMException::os_constant,
  c_DOMException::os_get_call_info
};
Object co_DOMXPath(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMXPath)())->dynCreate(params, init));
}
Object coo_DOMXPath() {
  Object r(NEW(c_DOMXPath)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMXPath
Variant c_DOMXPath::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMXPath
Variant c_DOMXPath::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMXPath
Variant &c_DOMXPath::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMXPath
void c_DOMXPath::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMXPath
void c_DOMXPath::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMXPath
Variant * c_DOMXPath::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMXPath
Variant * c_DOMXPath::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMXPath
Variant * c_DOMXPath::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMXPath
Variant c_DOMXPath::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMXPath
IMPLEMENT_CLASS(DOMXPath)
void c_DOMXPath::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMXPath::cloneImpl() {
  c_DOMXPath *obj = NEW(c_DOMXPath)();
  cloneSet(obj);
  return obj;
}
void c_DOMXPath::cloneSet(c_DOMXPath *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DOMXPath::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 2:
      HASH_GUARD_LITSTR(0x144FADF6B374AB82LL, NAMSTR(s_sys_ss4c8b547e, "registerPHPFunctions")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_registerphpfunctions());
        else return (t_registerphpfunctions(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_query(a0));
        else return (t_query(a0, a1));
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x47ACFB6D8681B0E8LL, NAMSTR(s_sys_ss797e4f18, "registerNamespace")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registernamespace(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      HASH_GUARD_LITSTR(0x2443593B6F3C912FLL, NAMSTR(s_sys_ss6f3c912f, "evaluate")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_evaluate(a0));
        else return (t_evaluate(a0, a1));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMXPath::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMXPath::ci___destruct((void*)&c_DOMXPath::i___destruct, (void*)&c_DOMXPath::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMXPath::ci___set((void*)&c_DOMXPath::i___set, (void*)&c_DOMXPath::ifa___set, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMXPath::ci___construct((void*)&c_DOMXPath::i___construct, (void*)&c_DOMXPath::ifa___construct, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMXPath::ci_query((void*)&c_DOMXPath::i_query, (void*)&c_DOMXPath::ifa_query, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMXPath::ci_evaluate((void*)&c_DOMXPath::i_evaluate, (void*)&c_DOMXPath::ifa_evaluate, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMXPath::ci_registerphpfunctions((void*)&c_DOMXPath::i_registerphpfunctions, (void*)&c_DOMXPath::ifa_registerphpfunctions, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMXPath::ci___get((void*)&c_DOMXPath::i___get, (void*)&c_DOMXPath::ifa___get, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMXPath::ci_registernamespace((void*)&c_DOMXPath::i_registernamespace, (void*)&c_DOMXPath::ifa_registernamespace, 2, 0, 0x0000000000000000LL);
Variant c_DOMXPath::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMXPath::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMXPath::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___construct(arg0), null);
  }
}
Variant c_DOMXPath::i_query(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_query(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_query(arg0, arg1));
  }
}
Variant c_DOMXPath::i_evaluate(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_evaluate(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_evaluate(arg0, arg1));
  }
}
Variant c_DOMXPath::i_registerphpfunctions(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_registerphpfunctions());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_registerphpfunctions(arg0));
  }
}
Variant c_DOMXPath::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMXPath::i_registernamespace(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_registernamespace(arg0, arg1));
  }
}
Variant c_DOMXPath::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMXPath::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMXPath::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  return (self->t___construct(a0), null);
}
Variant c_DOMXPath::ifa_query(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
  if (count <= 1) return (self->t_query(a0));
  return (self->t_query(a0, a1));
}
Variant c_DOMXPath::ifa_evaluate(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
  if (count <= 1) return (self->t_evaluate(a0));
  return (self->t_evaluate(a0, a1));
}
Variant c_DOMXPath::ifa_registerphpfunctions(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
  if (count <= 0) return (self->t_registerphpfunctions());
  return (self->t_registerphpfunctions(a0));
}
Variant c_DOMXPath::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
Variant c_DOMXPath::ifa_registernamespace(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
  return (self->t_registernamespace(a0, a1));
}
bool c_DOMXPath::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 2:
      HASH_GUARD_LITSTR(0x144FADF6B374AB82LL, NAMSTR(s_sys_ss4c8b547e, "registerPHPFunctions")) {
        mcp.ci = &c_DOMXPath::ci_registerphpfunctions;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMXPath::ci___destruct;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMXPath::ci___set;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        mcp.ci = &c_DOMXPath::ci_query;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x47ACFB6D8681B0E8LL, NAMSTR(s_sys_ss797e4f18, "registerNamespace")) {
        mcp.ci = &c_DOMXPath::ci_registernamespace;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMXPath::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x2443593B6F3C912FLL, NAMSTR(s_sys_ss6f3c912f, "evaluate")) {
        mcp.ci = &c_DOMXPath::ci_evaluate;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMXPath::ci___get;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DOMXPath::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 2:
      HASH_GUARD_LITSTR(0x144FADF6B374AB82LL, NAMSTR(s_sys_ss4c8b547e, "registerPHPFunctions")) {
        mcp.ci = &c_DOMXPath::ci_registerphpfunctions;
        mcp.obj = this;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMXPath::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMXPath::ci___set;
        mcp.obj = this;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        mcp.ci = &c_DOMXPath::ci_query;
        mcp.obj = this;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x47ACFB6D8681B0E8LL, NAMSTR(s_sys_ss797e4f18, "registerNamespace")) {
        mcp.ci = &c_DOMXPath::ci_registernamespace;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMXPath::ci___construct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x2443593B6F3C912FLL, NAMSTR(s_sys_ss6f3c912f, "evaluate")) {
        mcp.ci = &c_DOMXPath::ci_evaluate;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMXPath::ci___get;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_DOMXPath *c_DOMXPath::create(Variant a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_DOMXPath::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_DOMXPath::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_DOMXPath::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMXPath::ci___construct;
  mcp.obj = this;
}
void c_DOMXPath::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
struct ObjectStaticCallbacks cw_DOMXPath = {
  c_DOMXPath::os_getInit,
  c_DOMXPath::os_get,
  c_DOMXPath::os_lval,
  c_DOMXPath::os_invoke,
  c_DOMXPath::os_constant,
  c_DOMXPath::os_get_call_info
};
Object co_SoapServer(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SoapServer)())->dynCreate(params, init));
}
Object coo_SoapServer() {
  Object r(NEW(c_SoapServer)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapServer
Variant c_SoapServer::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapServer
Variant c_SoapServer::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapServer
Variant &c_SoapServer::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapServer
void c_SoapServer::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapServer
void c_SoapServer::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SoapServer
Variant * c_SoapServer::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapServer
Variant * c_SoapServer::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapServer
Variant * c_SoapServer::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapServer
Variant c_SoapServer::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapServer
IMPLEMENT_CLASS(SoapServer)
void c_SoapServer::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SoapServer::cloneImpl() {
  c_SoapServer *obj = NEW(c_SoapServer)();
  cloneSet(obj);
  return obj;
}
void c_SoapServer::cloneSet(c_SoapServer *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SoapServer::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD_LITSTR(0x758A4E04590FE203LL, NAMSTR(s_sys_ss590fe203, "fault")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_fault(a0, a1), null);
        else if (count == 3) return (t_fault(a0, a1, a2), null);
        else if (count == 4) return (t_fault(a0, a1, a2, a3), null);
        else return (t_fault(a0, a1, a2, a3, a4), null);
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x5E77DD94E0A69328LL, NAMSTR(s_sys_ss1f596cd8, "setpersistence")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setpersistence(a0), null);
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x652BDFA6E22F17AFLL, NAMSTR(s_sys_ss1dd0e851_1, "getfunctions")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfunctions());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x5C4CA333F4541532LL, NAMSTR(s_sys_ss0babeace, "handle")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_handle(), null);
        else return (t_handle(a0), null);
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x597B151CC4F70834LL, NAMSTR(s_sys_ss3b08f7cc, "setclass")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_setclass(count, a0), null);
        return (t_setclass(count, a0,vargs), null);
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x559622F84FE626B9LL, NAMSTR(s_sys_ss4fe626b9, "setobject")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setobject(a0), null);
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x278B0E6CCA74963ELL, NAMSTR(s_sys_ss358b69c2, "addsoapheader")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addsoapheader(a0), null);
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x48B5852A397D2D9FLL, NAMSTR(s_sys_ss397d2d9f, "addfunction")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addfunction(a0), null);
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SoapServer::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SoapServer::ci_addfunction((void*)&c_SoapServer::i_addfunction, (void*)&c_SoapServer::ifa_addfunction, 1, 0, 0x0000000000000000LL);
CallInfo c_SoapServer::ci___destruct((void*)&c_SoapServer::i___destruct, (void*)&c_SoapServer::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_SoapServer::ci___construct((void*)&c_SoapServer::i___construct, (void*)&c_SoapServer::ifa___construct, 2, 0, 0x0000000000000000LL);
CallInfo c_SoapServer::ci_getfunctions((void*)&c_SoapServer::i_getfunctions, (void*)&c_SoapServer::ifa_getfunctions, 0, 0, 0x0000000000000000LL);
CallInfo c_SoapServer::ci_addsoapheader((void*)&c_SoapServer::i_addsoapheader, (void*)&c_SoapServer::ifa_addsoapheader, 1, 0, 0x0000000000000000LL);
CallInfo c_SoapServer::ci_setpersistence((void*)&c_SoapServer::i_setpersistence, (void*)&c_SoapServer::ifa_setpersistence, 1, 0, 0x0000000000000000LL);
CallInfo c_SoapServer::ci_handle((void*)&c_SoapServer::i_handle, (void*)&c_SoapServer::ifa_handle, 1, 0, 0x0000000000000000LL);
CallInfo c_SoapServer::ci_setobject((void*)&c_SoapServer::i_setobject, (void*)&c_SoapServer::ifa_setobject, 1, 0, 0x0000000000000000LL);
CallInfo c_SoapServer::ci_fault((void*)&c_SoapServer::i_fault, (void*)&c_SoapServer::ifa_fault, 5, 0, 0x0000000000000000LL);
CallInfo c_SoapServer::ci_setclass((void*)&c_SoapServer::i_setclass, (void*)&c_SoapServer::ifa_setclass, 1, 1, 0x0000000000000000LL);
Variant c_SoapServer::i_addfunction(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_addfunction(arg0), null);
  }
}
Variant c_SoapServer::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapServer::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_SoapServer::i_getfunctions(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
  return (self->t_getfunctions());
}
Variant c_SoapServer::i_addsoapheader(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_addsoapheader(arg0), null);
  }
}
Variant c_SoapServer::i_setpersistence(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setpersistence(arg0), null);
  }
}
Variant c_SoapServer::i_handle(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("handle", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_handle(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_handle(arg0), null);
  }
}
Variant c_SoapServer::i_setobject(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setobject(arg0), null);
  }
}
Variant c_SoapServer::i_fault(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_fault(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_fault(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t_fault(arg0, arg1, arg2, arg3), null);
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_fault(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant c_SoapServer::i_setclass(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_setclass(count, arg0), null);
    return (self->t_setclass(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant c_SoapServer::ifa_addfunction(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
  return (self->t_addfunction(a0), null);
}
Variant c_SoapServer::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapServer::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
  if (count <= 1) return (self->t___construct(a0), null);
  return (self->t___construct(a0, a1), null);
}
Variant c_SoapServer::ifa_getfunctions(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
  return (self->t_getfunctions());
}
Variant c_SoapServer::ifa_addsoapheader(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
  return (self->t_addsoapheader(a0), null);
}
Variant c_SoapServer::ifa_setpersistence(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
  return (self->t_setpersistence(a0), null);
}
Variant c_SoapServer::ifa_handle(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("handle", 1, 1);
  if (count <= 0) return (self->t_handle(), null);
  return (self->t_handle(a0), null);
}
Variant c_SoapServer::ifa_setobject(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
  return (self->t_setobject(a0), null);
}
Variant c_SoapServer::ifa_fault(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
  if (count <= 2) return (self->t_fault(a0, a1), null);
  if (count == 3) return (self->t_fault(a0, a1, a2), null);
  if (count == 4) return (self->t_fault(a0, a1, a2, a3), null);
  return (self->t_fault(a0, a1, a2, a3, a4), null);
}
Variant c_SoapServer::ifa_setclass(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
  if (count <= 1) return (self->t_setclass(count, a0), null);
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (self->t_setclass(count,a0, params), null);
}
bool c_SoapServer::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 3:
      HASH_GUARD_LITSTR(0x758A4E04590FE203LL, NAMSTR(s_sys_ss590fe203, "fault")) {
        mcp.ci = &c_SoapServer::ci_fault;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x5E77DD94E0A69328LL, NAMSTR(s_sys_ss1f596cd8, "setpersistence")) {
        mcp.ci = &c_SoapServer::ci_setpersistence;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x652BDFA6E22F17AFLL, NAMSTR(s_sys_ss1dd0e851_1, "getfunctions")) {
        mcp.ci = &c_SoapServer::ci_getfunctions;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x5C4CA333F4541532LL, NAMSTR(s_sys_ss0babeace, "handle")) {
        mcp.ci = &c_SoapServer::ci_handle;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SoapServer::ci___destruct;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x597B151CC4F70834LL, NAMSTR(s_sys_ss3b08f7cc, "setclass")) {
        mcp.ci = &c_SoapServer::ci_setclass;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x559622F84FE626B9LL, NAMSTR(s_sys_ss4fe626b9, "setobject")) {
        mcp.ci = &c_SoapServer::ci_setobject;
        return true;
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x278B0E6CCA74963ELL, NAMSTR(s_sys_ss358b69c2, "addsoapheader")) {
        mcp.ci = &c_SoapServer::ci_addsoapheader;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x48B5852A397D2D9FLL, NAMSTR(s_sys_ss397d2d9f, "addfunction")) {
        mcp.ci = &c_SoapServer::ci_addfunction;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SoapServer::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SoapServer::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 3:
      HASH_GUARD_LITSTR(0x758A4E04590FE203LL, NAMSTR(s_sys_ss590fe203, "fault")) {
        mcp.ci = &c_SoapServer::ci_fault;
        mcp.obj = this;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x5E77DD94E0A69328LL, NAMSTR(s_sys_ss1f596cd8, "setpersistence")) {
        mcp.ci = &c_SoapServer::ci_setpersistence;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x652BDFA6E22F17AFLL, NAMSTR(s_sys_ss1dd0e851_1, "getfunctions")) {
        mcp.ci = &c_SoapServer::ci_getfunctions;
        mcp.obj = this;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x5C4CA333F4541532LL, NAMSTR(s_sys_ss0babeace, "handle")) {
        mcp.ci = &c_SoapServer::ci_handle;
        mcp.obj = this;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SoapServer::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x597B151CC4F70834LL, NAMSTR(s_sys_ss3b08f7cc, "setclass")) {
        mcp.ci = &c_SoapServer::ci_setclass;
        mcp.obj = this;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x559622F84FE626B9LL, NAMSTR(s_sys_ss4fe626b9, "setobject")) {
        mcp.ci = &c_SoapServer::ci_setobject;
        mcp.obj = this;
        return true;
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x278B0E6CCA74963ELL, NAMSTR(s_sys_ss358b69c2, "addsoapheader")) {
        mcp.ci = &c_SoapServer::ci_addsoapheader;
        mcp.obj = this;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x48B5852A397D2D9FLL, NAMSTR(s_sys_ss397d2d9f, "addfunction")) {
        mcp.ci = &c_SoapServer::ci_addfunction;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SoapServer::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_SoapServer *c_SoapServer::create(Variant a0, Array a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_SoapServer::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_SoapServer::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_SoapServer::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SoapServer::ci___construct;
  mcp.obj = this;
}
void c_SoapServer::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
struct ObjectStaticCallbacks cw_SoapServer = {
  c_SoapServer::os_getInit,
  c_SoapServer::os_get,
  c_SoapServer::os_lval,
  c_SoapServer::os_invoke,
  c_SoapServer::os_constant,
  c_SoapServer::os_get_call_info
};
Object co_DOMNode(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMNode)())->dynCreate(params, init));
}
Object coo_DOMNode() {
  Object r(NEW(c_DOMNode)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNode
Variant c_DOMNode::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNode
Variant c_DOMNode::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNode
Variant &c_DOMNode::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNode
void c_DOMNode::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNode
void c_DOMNode::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMNode
Variant * c_DOMNode::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNode
Variant * c_DOMNode::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNode
Variant * c_DOMNode::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNode
Variant c_DOMNode::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNode
IMPLEMENT_CLASS(DOMNode)
void c_DOMNode::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMNode::cloneImpl() {
  c_DOMNode *obj = NEW(c_DOMNode)();
  cloneSet(obj);
  return obj;
}
void c_DOMNode::cloneSet(c_DOMNode *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DOMNode::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMNode::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMNode::ci_getlineno((void*)&c_DOMNode::i_getlineno, (void*)&c_DOMNode::ifa_getlineno, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_insertbefore((void*)&c_DOMNode::i_insertbefore, (void*)&c_DOMNode::ifa_insertbefore, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_isdefaultnamespace((void*)&c_DOMNode::i_isdefaultnamespace, (void*)&c_DOMNode::ifa_isdefaultnamespace, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_lookupnamespaceuri((void*)&c_DOMNode::i_lookupnamespaceuri, (void*)&c_DOMNode::ifa_lookupnamespaceuri, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_appendchild((void*)&c_DOMNode::i_appendchild, (void*)&c_DOMNode::ifa_appendchild, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci___destruct((void*)&c_DOMNode::i___destruct, (void*)&c_DOMNode::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci___set((void*)&c_DOMNode::i___set, (void*)&c_DOMNode::ifa___set, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_clonenode((void*)&c_DOMNode::i_clonenode, (void*)&c_DOMNode::ifa_clonenode, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci___construct((void*)&c_DOMNode::i___construct, (void*)&c_DOMNode::ifa___construct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_replacechild((void*)&c_DOMNode::i_replacechild, (void*)&c_DOMNode::ifa_replacechild, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_c14n((void*)&c_DOMNode::i_c14n, (void*)&c_DOMNode::ifa_c14n, 4, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_hasattributes((void*)&c_DOMNode::i_hasattributes, (void*)&c_DOMNode::ifa_hasattributes, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_lookupprefix((void*)&c_DOMNode::i_lookupprefix, (void*)&c_DOMNode::ifa_lookupprefix, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_normalize((void*)&c_DOMNode::i_normalize, (void*)&c_DOMNode::ifa_normalize, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_getnodepath((void*)&c_DOMNode::i_getnodepath, (void*)&c_DOMNode::ifa_getnodepath, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_c14nfile((void*)&c_DOMNode::i_c14nfile, (void*)&c_DOMNode::ifa_c14nfile, 5, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_issamenode((void*)&c_DOMNode::i_issamenode, (void*)&c_DOMNode::ifa_issamenode, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_removechild((void*)&c_DOMNode::i_removechild, (void*)&c_DOMNode::ifa_removechild, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci___get((void*)&c_DOMNode::i___get, (void*)&c_DOMNode::ifa___get, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_issupported((void*)&c_DOMNode::i_issupported, (void*)&c_DOMNode::ifa_issupported, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_haschildnodes((void*)&c_DOMNode::i_haschildnodes, (void*)&c_DOMNode::ifa_haschildnodes, 0, 0, 0x0000000000000000LL);
Variant c_DOMNode::i_getlineno(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
  return (self->t_getlineno());
}
Variant c_DOMNode::i_insertbefore(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_insertbefore(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_insertbefore(arg0, arg1));
  }
}
Variant c_DOMNode::i_isdefaultnamespace(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_isdefaultnamespace(arg0));
  }
}
Variant c_DOMNode::i_lookupnamespaceuri(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_lookupnamespaceuri(arg0));
  }
}
Variant c_DOMNode::i_appendchild(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_appendchild(arg0));
  }
}
Variant c_DOMNode::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNode::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMNode::i_clonenode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_clonenode());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_clonenode(arg0));
  }
}
Variant c_DOMNode::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNode::i_replacechild(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_replacechild(arg0, arg1));
  }
}
Variant c_DOMNode::i_c14n(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_c14n());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_c14n(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_c14n(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_c14n(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_c14n(arg0, arg1, arg2, arg3));
  }
}
Variant c_DOMNode::i_hasattributes(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
  return (self->t_hasattributes());
}
Variant c_DOMNode::i_lookupprefix(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_lookupprefix(arg0));
  }
}
Variant c_DOMNode::i_normalize(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
  return (self->t_normalize(), null);
}
Variant c_DOMNode::i_getnodepath(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
  return (self->t_getnodepath());
}
Variant c_DOMNode::i_c14nfile(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_c14nfile(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_c14nfile(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_c14nfile(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t_c14nfile(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_c14nfile(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant c_DOMNode::i_issamenode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_issamenode(arg0));
  }
}
Variant c_DOMNode::i_removechild(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_removechild(arg0));
  }
}
Variant c_DOMNode::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMNode::i_issupported(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_issupported(arg0, arg1));
  }
}
Variant c_DOMNode::i_haschildnodes(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
  return (self->t_haschildnodes());
}
Variant c_DOMNode::ifa_getlineno(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
  return (self->t_getlineno());
}
Variant c_DOMNode::ifa_insertbefore(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
  if (count <= 1) return (self->t_insertbefore(a0));
  return (self->t_insertbefore(a0, a1));
}
Variant c_DOMNode::ifa_isdefaultnamespace(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
  return (self->t_isdefaultnamespace(a0));
}
Variant c_DOMNode::ifa_lookupnamespaceuri(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
  return (self->t_lookupnamespaceuri(a0));
}
Variant c_DOMNode::ifa_appendchild(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
  return (self->t_appendchild(a0));
}
Variant c_DOMNode::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNode::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMNode::ifa_clonenode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
  if (count <= 0) return (self->t_clonenode());
  return (self->t_clonenode(a0));
}
Variant c_DOMNode::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNode::ifa_replacechild(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
  return (self->t_replacechild(a0, a1));
}
Variant c_DOMNode::ifa_c14n(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
  if (count <= 0) return (self->t_c14n());
  if (count == 1) return (self->t_c14n(a0));
  if (count == 2) return (self->t_c14n(a0, a1));
  if (count == 3) return (self->t_c14n(a0, a1, a2));
  return (self->t_c14n(a0, a1, a2, a3));
}
Variant c_DOMNode::ifa_hasattributes(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
  return (self->t_hasattributes());
}
Variant c_DOMNode::ifa_lookupprefix(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
  return (self->t_lookupprefix(a0));
}
Variant c_DOMNode::ifa_normalize(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
  return (self->t_normalize(), null);
}
Variant c_DOMNode::ifa_getnodepath(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
  return (self->t_getnodepath());
}
Variant c_DOMNode::ifa_c14nfile(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
  if (count <= 1) return (self->t_c14nfile(a0));
  if (count == 2) return (self->t_c14nfile(a0, a1));
  if (count == 3) return (self->t_c14nfile(a0, a1, a2));
  if (count == 4) return (self->t_c14nfile(a0, a1, a2, a3));
  return (self->t_c14nfile(a0, a1, a2, a3, a4));
}
Variant c_DOMNode::ifa_issamenode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
  return (self->t_issamenode(a0));
}
Variant c_DOMNode::ifa_removechild(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
  return (self->t_removechild(a0));
}
Variant c_DOMNode::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
Variant c_DOMNode::ifa_issupported(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
  return (self->t_issupported(a0, a1));
}
Variant c_DOMNode::ifa_haschildnodes(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
  return (self->t_haschildnodes());
}
bool c_DOMNode::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        mcp.ci = &c_DOMNode::ci_getnodepath;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        mcp.ci = &c_DOMNode::ci_c14n;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        mcp.ci = &c_DOMNode::ci_replacechild;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        mcp.ci = &c_DOMNode::ci_appendchild;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMNode::ci___get;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        mcp.ci = &c_DOMNode::ci_clonenode;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMNode::ci___set;
        return true;
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        mcp.ci = &c_DOMNode::ci_getlineno;
        return true;
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        mcp.ci = &c_DOMNode::ci_normalize;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        mcp.ci = &c_DOMNode::ci_lookupnamespaceuri;
        return true;
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        mcp.ci = &c_DOMNode::ci_removechild;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMNode::ci___construct;
        return true;
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        mcp.ci = &c_DOMNode::ci_lookupprefix;
        return true;
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        mcp.ci = &c_DOMNode::ci_isdefaultnamespace;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        mcp.ci = &c_DOMNode::ci_issamenode;
        return true;
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        mcp.ci = &c_DOMNode::ci_hasattributes;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        mcp.ci = &c_DOMNode::ci_insertbefore;
        return true;
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMNode::ci___destruct;
        return true;
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        mcp.ci = &c_DOMNode::ci_c14nfile;
        return true;
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        mcp.ci = &c_DOMNode::ci_issupported;
        return true;
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        mcp.ci = &c_DOMNode::ci_haschildnodes;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DOMNode::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        mcp.ci = &c_DOMNode::ci_getnodepath;
        mcp.obj = this;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        mcp.ci = &c_DOMNode::ci_c14n;
        mcp.obj = this;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        mcp.ci = &c_DOMNode::ci_replacechild;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        mcp.ci = &c_DOMNode::ci_appendchild;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMNode::ci___get;
        mcp.obj = this;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        mcp.ci = &c_DOMNode::ci_clonenode;
        mcp.obj = this;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMNode::ci___set;
        mcp.obj = this;
        return true;
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        mcp.ci = &c_DOMNode::ci_getlineno;
        mcp.obj = this;
        return true;
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        mcp.ci = &c_DOMNode::ci_normalize;
        mcp.obj = this;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        mcp.ci = &c_DOMNode::ci_lookupnamespaceuri;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        mcp.ci = &c_DOMNode::ci_removechild;
        mcp.obj = this;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMNode::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        mcp.ci = &c_DOMNode::ci_lookupprefix;
        mcp.obj = this;
        return true;
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        mcp.ci = &c_DOMNode::ci_isdefaultnamespace;
        mcp.obj = this;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        mcp.ci = &c_DOMNode::ci_issamenode;
        mcp.obj = this;
        return true;
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        mcp.ci = &c_DOMNode::ci_hasattributes;
        mcp.obj = this;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        mcp.ci = &c_DOMNode::ci_insertbefore;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMNode::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        mcp.ci = &c_DOMNode::ci_c14nfile;
        mcp.obj = this;
        return true;
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        mcp.ci = &c_DOMNode::ci_issupported;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        mcp.ci = &c_DOMNode::ci_haschildnodes;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_DOMNode *c_DOMNode::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMNode::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMNode::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMNode::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMNode::ci___construct;
  mcp.obj = this;
}
void c_DOMNode::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMNode = {
  c_DOMNode::os_getInit,
  c_DOMNode::os_get,
  c_DOMNode::os_lval,
  c_DOMNode::os_invoke,
  c_DOMNode::os_constant,
  c_DOMNode::os_get_call_info
};
Object co_DOMDocument(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMDocument)())->dynCreate(params, init));
}
Object coo_DOMDocument() {
  Object r(NEW(c_DOMDocument)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMDocument
Variant c_DOMDocument::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMDocument
Variant c_DOMDocument::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMDocument
Variant &c_DOMDocument::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMDocument
void c_DOMDocument::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMDocument
void c_DOMDocument::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMDocument
Variant * c_DOMDocument::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMDocument
Variant * c_DOMDocument::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMDocument
Variant * c_DOMDocument::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMDocument
Variant c_DOMDocument::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMDocument
IMPLEMENT_CLASS(DOMDocument)
void c_DOMDocument::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMDocument::cloneImpl() {
  c_DOMDocument *obj = NEW(c_DOMDocument)();
  cloneSet(obj);
  return obj;
}
void c_DOMDocument::cloneSet(c_DOMDocument *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMDocument::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 5:
      HASH_GUARD_LITSTR(0x515FE7746601E385LL, NAMSTR(s_sys_ss6601e385, "getElementById")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementbyid(a0));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x142A28F8CE4A4E8ALL, NAMSTR(s_sys_ss31b5b176, "xinclude")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_xinclude());
        else return (t_xinclude(a0));
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x0D128C363EBF7F0DLL, NAMSTR(s_sys_ss3ebf7f0d, "createCDATASection")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createcdatasection(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x69C6F7D584EC5011LL, NAMSTR(s_sys_ss7b13afef, "schemaValidateSource")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_schemavalidatesource(a0));
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x04F8F7CEA46D0514LL, NAMSTR(s_sys_ss5b92faec, "save")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_save(a0));
        else return (t_save(a0, a1));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      HASH_GUARD_LITSTR(0x2FC58024A75AEB15LL, NAMSTR(s_sys_ss58a514eb, "createAttributens")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createattributens(a0, a1));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x1A78385D7CD10A1CLL, NAMSTR(s_sys_ss7cd10a1c, "relaxNGValidate")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_relaxngvalidate(a0));
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x1B0F4D437C8404A2LL, NAMSTR(s_sys_ss7c8404a2, "loadHTML")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadhtml(a0));
      }
      HASH_GUARD_LITSTR(0x4C40B0F935B39FA2LL, NAMSTR(s_sys_ss35b39fa2, "createElement")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_createelement(a0));
        else return (t_createelement(a0, a1));
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x1304C35F6E006FACLL, NAMSTR(s_sys_ss6e006fac, "relaxNGValidateSource")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_relaxngvalidatesource(a0));
      }
      HASH_GUARD_LITSTR(0x2BFDE9CF0FE9A82CLL, NAMSTR(s_sys_ss0fe9a82c, "createAttribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x4A6C6D9AB88CD42FLL, NAMSTR(s_sys_ss47732bd1, "importNode")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_importnode(a0));
        else return (t_importnode(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5FE94CA513F14AAFLL, NAMSTR(s_sys_ss13f14aaf, "loadHTMLFile")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadhtmlfile(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x20E2B2FD2B7AE431LL, NAMSTR(s_sys_ss2b7ae431, "loadXML")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_loadxml(a0));
        else return (t_loadxml(a0, a1));
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x7A9C4709CAD09832LL, NAMSTR(s_sys_ss352f67ce, "createEntityReference")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createentityreference(a0));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x1CA408E02262F737LL, NAMSTR(s_sys_ss2262f737, "validate")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_validate());
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x29C79E90C6FCC0C7LL, NAMSTR(s_sys_ss39033f39, "createComment")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createcomment(a0));
      }
      break;
    case 72:
      HASH_GUARD_LITSTR(0x7EB8C68BABDC5648LL, NAMSTR(s_sys_ss5423a9b8, "schemaValidate")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_schemavalidate(a0));
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss13546c36, "getElementsByTagName")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss35b7e836, "getElementsByTagNameNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagnamens(a0, a1));
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x35C0FF513ED3054DLL, NAMSTR(s_sys_ss3ed3054d, "saveHTMLFile")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_savehtmlfile(a0));
      }
      break;
    case 83:
      HASH_GUARD_LITSTR(0x21F3F1C9058310D3LL, NAMSTR(s_sys_ss058310d3, "saveHTML")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_savehtml());
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      HASH_GUARD_LITSTR(0x79B7A5774A0943DFLL, NAMSTR(s_sys_ss4a0943df, "load")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_load(a0));
        else return (t_load(a0, a1));
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x26D66F56DDDC32E5LL, NAMSTR(s_sys_ss2223cd1b, "saveXML")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_savexml());
        else if (count == 1) return (t_savexml(a0));
        else return (t_savexml(a0, a1));
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x0AC931EAB2FE3D6ALL, NAMSTR(s_sys_ss4d01c296, "normalizeDocument")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalizedocument(), null);
      }
      break;
    case 107:
      HASH_GUARD_LITSTR(0x05EA36F416B7EBEBLL, NAMSTR(s_sys_ss16b7ebeb, "createElementNS")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_createelementns(a0, a1));
        else return (t_createelementns(a0, a1, a2));
      }
      break;
    case 109:
      HASH_GUARD_LITSTR(0x2A99431FC6E7BA6DLL, NAMSTR(s_sys_ss39184593, "createProcessingInstruction")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_createprocessinginstruction(a0));
        else return (t_createprocessinginstruction(a0, a1));
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD_LITSTR(0x615771958E1EB375LL, NAMSTR(s_sys_ss71e14c8b, "registerNodeClass")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registernodeclass(a0, a1));
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x44FD8C24F4EA46F8LL, NAMSTR(s_sys_ss0b15b908, "createDocumentFragment")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createdocumentfragment());
      }
      break;
    case 123:
      HASH_GUARD_LITSTR(0x6056A5BB9855D7FBLL, NAMSTR(s_sys_ss67aa2805, "createTextNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createtextnode(a0));
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMDocument::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMDocument::ci_getelementsbytagname((void*)&c_DOMDocument::i_getelementsbytagname, (void*)&c_DOMDocument::ifa_getelementsbytagname, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createcdatasection((void*)&c_DOMDocument::i_createcdatasection, (void*)&c_DOMDocument::ifa_createcdatasection, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_validate((void*)&c_DOMDocument::i_validate, (void*)&c_DOMDocument::ifa_validate, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_getelementsbytagnamens((void*)&c_DOMDocument::i_getelementsbytagnamens, (void*)&c_DOMDocument::ifa_getelementsbytagnamens, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_schemavalidatesource((void*)&c_DOMDocument::i_schemavalidatesource, (void*)&c_DOMDocument::ifa_schemavalidatesource, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_relaxngvalidate((void*)&c_DOMDocument::i_relaxngvalidate, (void*)&c_DOMDocument::ifa_relaxngvalidate, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_loadhtml((void*)&c_DOMDocument::i_loadhtml, (void*)&c_DOMDocument::ifa_loadhtml, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createentityreference((void*)&c_DOMDocument::i_createentityreference, (void*)&c_DOMDocument::ifa_createentityreference, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_schemavalidate((void*)&c_DOMDocument::i_schemavalidate, (void*)&c_DOMDocument::ifa_schemavalidate, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci___destruct((void*)&c_DOMDocument::i___destruct, (void*)&c_DOMDocument::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci___set((void*)&c_DOMDocument::i___set, (void*)&c_DOMDocument::ifa___set, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_savexml((void*)&c_DOMDocument::i_savexml, (void*)&c_DOMDocument::ifa_savexml, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createprocessinginstruction((void*)&c_DOMDocument::i_createprocessinginstruction, (void*)&c_DOMDocument::ifa_createprocessinginstruction, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci___construct((void*)&c_DOMDocument::i___construct, (void*)&c_DOMDocument::ifa___construct, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_registernodeclass((void*)&c_DOMDocument::i_registernodeclass, (void*)&c_DOMDocument::ifa_registernodeclass, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_load((void*)&c_DOMDocument::i_load, (void*)&c_DOMDocument::ifa_load, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createattributens((void*)&c_DOMDocument::i_createattributens, (void*)&c_DOMDocument::ifa_createattributens, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createelement((void*)&c_DOMDocument::i_createelement, (void*)&c_DOMDocument::ifa_createelement, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createelementns((void*)&c_DOMDocument::i_createelementns, (void*)&c_DOMDocument::ifa_createelementns, 3, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_importnode((void*)&c_DOMDocument::i_importnode, (void*)&c_DOMDocument::ifa_importnode, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_relaxngvalidatesource((void*)&c_DOMDocument::i_relaxngvalidatesource, (void*)&c_DOMDocument::ifa_relaxngvalidatesource, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createtextnode((void*)&c_DOMDocument::i_createtextnode, (void*)&c_DOMDocument::ifa_createtextnode, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_savehtml((void*)&c_DOMDocument::i_savehtml, (void*)&c_DOMDocument::ifa_savehtml, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_loadxml((void*)&c_DOMDocument::i_loadxml, (void*)&c_DOMDocument::ifa_loadxml, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_save((void*)&c_DOMDocument::i_save, (void*)&c_DOMDocument::ifa_save, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createattribute((void*)&c_DOMDocument::i_createattribute, (void*)&c_DOMDocument::ifa_createattribute, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_xinclude((void*)&c_DOMDocument::i_xinclude, (void*)&c_DOMDocument::ifa_xinclude, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci___get((void*)&c_DOMDocument::i___get, (void*)&c_DOMDocument::ifa___get, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_loadhtmlfile((void*)&c_DOMDocument::i_loadhtmlfile, (void*)&c_DOMDocument::ifa_loadhtmlfile, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_savehtmlfile((void*)&c_DOMDocument::i_savehtmlfile, (void*)&c_DOMDocument::ifa_savehtmlfile, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_getelementbyid((void*)&c_DOMDocument::i_getelementbyid, (void*)&c_DOMDocument::ifa_getelementbyid, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createcomment((void*)&c_DOMDocument::i_createcomment, (void*)&c_DOMDocument::ifa_createcomment, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_normalizedocument((void*)&c_DOMDocument::i_normalizedocument, (void*)&c_DOMDocument::ifa_normalizedocument, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createdocumentfragment((void*)&c_DOMDocument::i_createdocumentfragment, (void*)&c_DOMDocument::ifa_createdocumentfragment, 0, 0, 0x0000000000000000LL);
Variant c_DOMDocument::i_getelementsbytagname(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getelementsbytagname(arg0));
  }
}
Variant c_DOMDocument::i_createcdatasection(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_createcdatasection(arg0));
  }
}
Variant c_DOMDocument::i_validate(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("validate", 0, 1);
  return (self->t_validate());
}
Variant c_DOMDocument::i_getelementsbytagnamens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getelementsbytagnamens(arg0, arg1));
  }
}
Variant c_DOMDocument::i_schemavalidatesource(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_schemavalidatesource(arg0));
  }
}
Variant c_DOMDocument::i_relaxngvalidate(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_relaxngvalidate(arg0));
  }
}
Variant c_DOMDocument::i_loadhtml(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_loadhtml(arg0));
  }
}
Variant c_DOMDocument::i_createentityreference(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_createentityreference(arg0));
  }
}
Variant c_DOMDocument::i_schemavalidate(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_schemavalidate(arg0));
  }
}
Variant c_DOMDocument::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMDocument::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMDocument::i_savexml(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_savexml());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_savexml(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_savexml(arg0, arg1));
  }
}
Variant c_DOMDocument::i_createprocessinginstruction(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_createprocessinginstruction(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_createprocessinginstruction(arg0, arg1));
  }
}
Variant c_DOMDocument::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t___construct(), null);
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_DOMDocument::i_registernodeclass(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_registernodeclass(arg0, arg1));
  }
}
Variant c_DOMDocument::i_load(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_load(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_load(arg0, arg1));
  }
}
Variant c_DOMDocument::i_createattributens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_createattributens(arg0, arg1));
  }
}
Variant c_DOMDocument::i_createelement(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_createelement(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_createelement(arg0, arg1));
  }
}
Variant c_DOMDocument::i_createelementns(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_createelementns(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_createelementns(arg0, arg1, arg2));
  }
}
Variant c_DOMDocument::i_importnode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_importnode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_importnode(arg0, arg1));
  }
}
Variant c_DOMDocument::i_relaxngvalidatesource(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_relaxngvalidatesource(arg0));
  }
}
Variant c_DOMDocument::i_createtextnode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_createtextnode(arg0));
  }
}
Variant c_DOMDocument::i_savehtml(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
  return (self->t_savehtml());
}
Variant c_DOMDocument::i_loadxml(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_loadxml(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_loadxml(arg0, arg1));
  }
}
Variant c_DOMDocument::i_save(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_save(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_save(arg0, arg1));
  }
}
Variant c_DOMDocument::i_createattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_createattribute(arg0));
  }
}
Variant c_DOMDocument::i_xinclude(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_xinclude());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_xinclude(arg0));
  }
}
Variant c_DOMDocument::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMDocument::i_loadhtmlfile(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_loadhtmlfile(arg0));
  }
}
Variant c_DOMDocument::i_savehtmlfile(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_savehtmlfile(arg0));
  }
}
Variant c_DOMDocument::i_getelementbyid(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getelementbyid(arg0));
  }
}
Variant c_DOMDocument::i_createcomment(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_createcomment(arg0));
  }
}
Variant c_DOMDocument::i_normalizedocument(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
  return (self->t_normalizedocument(), null);
}
Variant c_DOMDocument::i_createdocumentfragment(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
  return (self->t_createdocumentfragment());
}
Variant c_DOMDocument::ifa_getelementsbytagname(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
  return (self->t_getelementsbytagname(a0));
}
Variant c_DOMDocument::ifa_createcdatasection(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
  return (self->t_createcdatasection(a0));
}
Variant c_DOMDocument::ifa_validate(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("validate", 0, 1);
  return (self->t_validate());
}
Variant c_DOMDocument::ifa_getelementsbytagnamens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
  return (self->t_getelementsbytagnamens(a0, a1));
}
Variant c_DOMDocument::ifa_schemavalidatesource(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
  return (self->t_schemavalidatesource(a0));
}
Variant c_DOMDocument::ifa_relaxngvalidate(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
  return (self->t_relaxngvalidate(a0));
}
Variant c_DOMDocument::ifa_loadhtml(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
  return (self->t_loadhtml(a0));
}
Variant c_DOMDocument::ifa_createentityreference(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
  return (self->t_createentityreference(a0));
}
Variant c_DOMDocument::ifa_schemavalidate(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
  return (self->t_schemavalidate(a0));
}
Variant c_DOMDocument::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMDocument::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMDocument::ifa_savexml(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
  if (count <= 0) return (self->t_savexml());
  if (count == 1) return (self->t_savexml(a0));
  return (self->t_savexml(a0, a1));
}
Variant c_DOMDocument::ifa_createprocessinginstruction(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
  if (count <= 1) return (self->t_createprocessinginstruction(a0));
  return (self->t_createprocessinginstruction(a0, a1));
}
Variant c_DOMDocument::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
  if (count <= 0) return (self->t___construct(), null);
  if (count == 1) return (self->t___construct(a0), null);
  return (self->t___construct(a0, a1), null);
}
Variant c_DOMDocument::ifa_registernodeclass(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
  return (self->t_registernodeclass(a0, a1));
}
Variant c_DOMDocument::ifa_load(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
  if (count <= 1) return (self->t_load(a0));
  return (self->t_load(a0, a1));
}
Variant c_DOMDocument::ifa_createattributens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
  return (self->t_createattributens(a0, a1));
}
Variant c_DOMDocument::ifa_createelement(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
  if (count <= 1) return (self->t_createelement(a0));
  return (self->t_createelement(a0, a1));
}
Variant c_DOMDocument::ifa_createelementns(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
  if (count <= 2) return (self->t_createelementns(a0, a1));
  return (self->t_createelementns(a0, a1, a2));
}
Variant c_DOMDocument::ifa_importnode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
  if (count <= 1) return (self->t_importnode(a0));
  return (self->t_importnode(a0, a1));
}
Variant c_DOMDocument::ifa_relaxngvalidatesource(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
  return (self->t_relaxngvalidatesource(a0));
}
Variant c_DOMDocument::ifa_createtextnode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
  return (self->t_createtextnode(a0));
}
Variant c_DOMDocument::ifa_savehtml(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
  return (self->t_savehtml());
}
Variant c_DOMDocument::ifa_loadxml(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
  if (count <= 1) return (self->t_loadxml(a0));
  return (self->t_loadxml(a0, a1));
}
Variant c_DOMDocument::ifa_save(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
  if (count <= 1) return (self->t_save(a0));
  return (self->t_save(a0, a1));
}
Variant c_DOMDocument::ifa_createattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
  return (self->t_createattribute(a0));
}
Variant c_DOMDocument::ifa_xinclude(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
  if (count <= 0) return (self->t_xinclude());
  return (self->t_xinclude(a0));
}
Variant c_DOMDocument::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
Variant c_DOMDocument::ifa_loadhtmlfile(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
  return (self->t_loadhtmlfile(a0));
}
Variant c_DOMDocument::ifa_savehtmlfile(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
  return (self->t_savehtmlfile(a0));
}
Variant c_DOMDocument::ifa_getelementbyid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
  return (self->t_getelementbyid(a0));
}
Variant c_DOMDocument::ifa_createcomment(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
  return (self->t_createcomment(a0));
}
Variant c_DOMDocument::ifa_normalizedocument(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
  return (self->t_normalizedocument(), null);
}
Variant c_DOMDocument::ifa_createdocumentfragment(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
  return (self->t_createdocumentfragment());
}
bool c_DOMDocument::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 127) {
    case 5:
      HASH_GUARD_LITSTR(0x515FE7746601E385LL, NAMSTR(s_sys_ss6601e385, "getElementById")) {
        mcp.ci = &c_DOMDocument::ci_getelementbyid;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x142A28F8CE4A4E8ALL, NAMSTR(s_sys_ss31b5b176, "xinclude")) {
        mcp.ci = &c_DOMDocument::ci_xinclude;
        return true;
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x0D128C363EBF7F0DLL, NAMSTR(s_sys_ss3ebf7f0d, "createCDATASection")) {
        mcp.ci = &c_DOMDocument::ci_createcdatasection;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMDocument::ci___get;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x69C6F7D584EC5011LL, NAMSTR(s_sys_ss7b13afef, "schemaValidateSource")) {
        mcp.ci = &c_DOMDocument::ci_schemavalidatesource;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x04F8F7CEA46D0514LL, NAMSTR(s_sys_ss5b92faec, "save")) {
        mcp.ci = &c_DOMDocument::ci_save;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMDocument::ci___set;
        return true;
      }
      HASH_GUARD_LITSTR(0x2FC58024A75AEB15LL, NAMSTR(s_sys_ss58a514eb, "createAttributens")) {
        mcp.ci = &c_DOMDocument::ci_createattributens;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x1A78385D7CD10A1CLL, NAMSTR(s_sys_ss7cd10a1c, "relaxNGValidate")) {
        mcp.ci = &c_DOMDocument::ci_relaxngvalidate;
        return true;
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x1B0F4D437C8404A2LL, NAMSTR(s_sys_ss7c8404a2, "loadHTML")) {
        mcp.ci = &c_DOMDocument::ci_loadhtml;
        return true;
      }
      HASH_GUARD_LITSTR(0x4C40B0F935B39FA2LL, NAMSTR(s_sys_ss35b39fa2, "createElement")) {
        mcp.ci = &c_DOMDocument::ci_createelement;
        return true;
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x1304C35F6E006FACLL, NAMSTR(s_sys_ss6e006fac, "relaxNGValidateSource")) {
        mcp.ci = &c_DOMDocument::ci_relaxngvalidatesource;
        return true;
      }
      HASH_GUARD_LITSTR(0x2BFDE9CF0FE9A82CLL, NAMSTR(s_sys_ss0fe9a82c, "createAttribute")) {
        mcp.ci = &c_DOMDocument::ci_createattribute;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x4A6C6D9AB88CD42FLL, NAMSTR(s_sys_ss47732bd1, "importNode")) {
        mcp.ci = &c_DOMDocument::ci_importnode;
        return true;
      }
      HASH_GUARD_LITSTR(0x5FE94CA513F14AAFLL, NAMSTR(s_sys_ss13f14aaf, "loadHTMLFile")) {
        mcp.ci = &c_DOMDocument::ci_loadhtmlfile;
        return true;
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x20E2B2FD2B7AE431LL, NAMSTR(s_sys_ss2b7ae431, "loadXML")) {
        mcp.ci = &c_DOMDocument::ci_loadxml;
        return true;
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x7A9C4709CAD09832LL, NAMSTR(s_sys_ss352f67ce, "createEntityReference")) {
        mcp.ci = &c_DOMDocument::ci_createentityreference;
        return true;
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x1CA408E02262F737LL, NAMSTR(s_sys_ss2262f737, "validate")) {
        mcp.ci = &c_DOMDocument::ci_validate;
        return true;
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x29C79E90C6FCC0C7LL, NAMSTR(s_sys_ss39033f39, "createComment")) {
        mcp.ci = &c_DOMDocument::ci_createcomment;
        return true;
      }
      break;
    case 72:
      HASH_GUARD_LITSTR(0x7EB8C68BABDC5648LL, NAMSTR(s_sys_ss5423a9b8, "schemaValidate")) {
        mcp.ci = &c_DOMDocument::ci_schemavalidate;
        return true;
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss13546c36, "getElementsByTagName")) {
        mcp.ci = &c_DOMDocument::ci_getelementsbytagname;
        return true;
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss35b7e836, "getElementsByTagNameNS")) {
        mcp.ci = &c_DOMDocument::ci_getelementsbytagnamens;
        return true;
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x35C0FF513ED3054DLL, NAMSTR(s_sys_ss3ed3054d, "saveHTMLFile")) {
        mcp.ci = &c_DOMDocument::ci_savehtmlfile;
        return true;
      }
      break;
    case 83:
      HASH_GUARD_LITSTR(0x21F3F1C9058310D3LL, NAMSTR(s_sys_ss058310d3, "saveHTML")) {
        mcp.ci = &c_DOMDocument::ci_savehtml;
        return true;
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMDocument::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x79B7A5774A0943DFLL, NAMSTR(s_sys_ss4a0943df, "load")) {
        mcp.ci = &c_DOMDocument::ci_load;
        return true;
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x26D66F56DDDC32E5LL, NAMSTR(s_sys_ss2223cd1b, "saveXML")) {
        mcp.ci = &c_DOMDocument::ci_savexml;
        return true;
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x0AC931EAB2FE3D6ALL, NAMSTR(s_sys_ss4d01c296, "normalizeDocument")) {
        mcp.ci = &c_DOMDocument::ci_normalizedocument;
        return true;
      }
      break;
    case 107:
      HASH_GUARD_LITSTR(0x05EA36F416B7EBEBLL, NAMSTR(s_sys_ss16b7ebeb, "createElementNS")) {
        mcp.ci = &c_DOMDocument::ci_createelementns;
        return true;
      }
      break;
    case 109:
      HASH_GUARD_LITSTR(0x2A99431FC6E7BA6DLL, NAMSTR(s_sys_ss39184593, "createProcessingInstruction")) {
        mcp.ci = &c_DOMDocument::ci_createprocessinginstruction;
        return true;
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMDocument::ci___destruct;
        return true;
      }
      break;
    case 117:
      HASH_GUARD_LITSTR(0x615771958E1EB375LL, NAMSTR(s_sys_ss71e14c8b, "registerNodeClass")) {
        mcp.ci = &c_DOMDocument::ci_registernodeclass;
        return true;
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x44FD8C24F4EA46F8LL, NAMSTR(s_sys_ss0b15b908, "createDocumentFragment")) {
        mcp.ci = &c_DOMDocument::ci_createdocumentfragment;
        return true;
      }
      break;
    case 123:
      HASH_GUARD_LITSTR(0x6056A5BB9855D7FBLL, NAMSTR(s_sys_ss67aa2805, "createTextNode")) {
        mcp.ci = &c_DOMDocument::ci_createtextnode;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMDocument::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 127) {
    case 5:
      HASH_GUARD_LITSTR(0x515FE7746601E385LL, NAMSTR(s_sys_ss6601e385, "getElementById")) {
        mcp.ci = &c_DOMDocument::ci_getelementbyid;
        mcp.obj = this;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x142A28F8CE4A4E8ALL, NAMSTR(s_sys_ss31b5b176, "xinclude")) {
        mcp.ci = &c_DOMDocument::ci_xinclude;
        mcp.obj = this;
        return true;
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x0D128C363EBF7F0DLL, NAMSTR(s_sys_ss3ebf7f0d, "createCDATASection")) {
        mcp.ci = &c_DOMDocument::ci_createcdatasection;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMDocument::ci___get;
        mcp.obj = this;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x69C6F7D584EC5011LL, NAMSTR(s_sys_ss7b13afef, "schemaValidateSource")) {
        mcp.ci = &c_DOMDocument::ci_schemavalidatesource;
        mcp.obj = this;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x04F8F7CEA46D0514LL, NAMSTR(s_sys_ss5b92faec, "save")) {
        mcp.ci = &c_DOMDocument::ci_save;
        mcp.obj = this;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMDocument::ci___set;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x2FC58024A75AEB15LL, NAMSTR(s_sys_ss58a514eb, "createAttributens")) {
        mcp.ci = &c_DOMDocument::ci_createattributens;
        mcp.obj = this;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x1A78385D7CD10A1CLL, NAMSTR(s_sys_ss7cd10a1c, "relaxNGValidate")) {
        mcp.ci = &c_DOMDocument::ci_relaxngvalidate;
        mcp.obj = this;
        return true;
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x1B0F4D437C8404A2LL, NAMSTR(s_sys_ss7c8404a2, "loadHTML")) {
        mcp.ci = &c_DOMDocument::ci_loadhtml;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x4C40B0F935B39FA2LL, NAMSTR(s_sys_ss35b39fa2, "createElement")) {
        mcp.ci = &c_DOMDocument::ci_createelement;
        mcp.obj = this;
        return true;
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x1304C35F6E006FACLL, NAMSTR(s_sys_ss6e006fac, "relaxNGValidateSource")) {
        mcp.ci = &c_DOMDocument::ci_relaxngvalidatesource;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x2BFDE9CF0FE9A82CLL, NAMSTR(s_sys_ss0fe9a82c, "createAttribute")) {
        mcp.ci = &c_DOMDocument::ci_createattribute;
        mcp.obj = this;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x4A6C6D9AB88CD42FLL, NAMSTR(s_sys_ss47732bd1, "importNode")) {
        mcp.ci = &c_DOMDocument::ci_importnode;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x5FE94CA513F14AAFLL, NAMSTR(s_sys_ss13f14aaf, "loadHTMLFile")) {
        mcp.ci = &c_DOMDocument::ci_loadhtmlfile;
        mcp.obj = this;
        return true;
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x20E2B2FD2B7AE431LL, NAMSTR(s_sys_ss2b7ae431, "loadXML")) {
        mcp.ci = &c_DOMDocument::ci_loadxml;
        mcp.obj = this;
        return true;
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x7A9C4709CAD09832LL, NAMSTR(s_sys_ss352f67ce, "createEntityReference")) {
        mcp.ci = &c_DOMDocument::ci_createentityreference;
        mcp.obj = this;
        return true;
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x1CA408E02262F737LL, NAMSTR(s_sys_ss2262f737, "validate")) {
        mcp.ci = &c_DOMDocument::ci_validate;
        mcp.obj = this;
        return true;
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x29C79E90C6FCC0C7LL, NAMSTR(s_sys_ss39033f39, "createComment")) {
        mcp.ci = &c_DOMDocument::ci_createcomment;
        mcp.obj = this;
        return true;
      }
      break;
    case 72:
      HASH_GUARD_LITSTR(0x7EB8C68BABDC5648LL, NAMSTR(s_sys_ss5423a9b8, "schemaValidate")) {
        mcp.ci = &c_DOMDocument::ci_schemavalidate;
        mcp.obj = this;
        return true;
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss13546c36, "getElementsByTagName")) {
        mcp.ci = &c_DOMDocument::ci_getelementsbytagname;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss35b7e836, "getElementsByTagNameNS")) {
        mcp.ci = &c_DOMDocument::ci_getelementsbytagnamens;
        mcp.obj = this;
        return true;
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x35C0FF513ED3054DLL, NAMSTR(s_sys_ss3ed3054d, "saveHTMLFile")) {
        mcp.ci = &c_DOMDocument::ci_savehtmlfile;
        mcp.obj = this;
        return true;
      }
      break;
    case 83:
      HASH_GUARD_LITSTR(0x21F3F1C9058310D3LL, NAMSTR(s_sys_ss058310d3, "saveHTML")) {
        mcp.ci = &c_DOMDocument::ci_savehtml;
        mcp.obj = this;
        return true;
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMDocument::ci___construct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x79B7A5774A0943DFLL, NAMSTR(s_sys_ss4a0943df, "load")) {
        mcp.ci = &c_DOMDocument::ci_load;
        mcp.obj = this;
        return true;
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x26D66F56DDDC32E5LL, NAMSTR(s_sys_ss2223cd1b, "saveXML")) {
        mcp.ci = &c_DOMDocument::ci_savexml;
        mcp.obj = this;
        return true;
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x0AC931EAB2FE3D6ALL, NAMSTR(s_sys_ss4d01c296, "normalizeDocument")) {
        mcp.ci = &c_DOMDocument::ci_normalizedocument;
        mcp.obj = this;
        return true;
      }
      break;
    case 107:
      HASH_GUARD_LITSTR(0x05EA36F416B7EBEBLL, NAMSTR(s_sys_ss16b7ebeb, "createElementNS")) {
        mcp.ci = &c_DOMDocument::ci_createelementns;
        mcp.obj = this;
        return true;
      }
      break;
    case 109:
      HASH_GUARD_LITSTR(0x2A99431FC6E7BA6DLL, NAMSTR(s_sys_ss39184593, "createProcessingInstruction")) {
        mcp.ci = &c_DOMDocument::ci_createprocessinginstruction;
        mcp.obj = this;
        return true;
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMDocument::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 117:
      HASH_GUARD_LITSTR(0x615771958E1EB375LL, NAMSTR(s_sys_ss71e14c8b, "registerNodeClass")) {
        mcp.ci = &c_DOMDocument::ci_registernodeclass;
        mcp.obj = this;
        return true;
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x44FD8C24F4EA46F8LL, NAMSTR(s_sys_ss0b15b908, "createDocumentFragment")) {
        mcp.ci = &c_DOMDocument::ci_createdocumentfragment;
        mcp.obj = this;
        return true;
      }
      break;
    case 123:
      HASH_GUARD_LITSTR(0x6056A5BB9855D7FBLL, NAMSTR(s_sys_ss67aa2805, "createTextNode")) {
        mcp.ci = &c_DOMDocument::ci_createtextnode;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_get_call_info(mcp, hash);
}
c_DOMDocument *c_DOMDocument::create(String a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_DOMDocument::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("__construct", 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      if (count == 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_DOMDocument::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_DOMDocument::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMDocument::ci___construct;
  mcp.obj = this;
}
void c_DOMDocument::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
struct ObjectStaticCallbacks cw_DOMDocument = {
  c_DOMDocument::os_getInit,
  c_DOMDocument::os_get,
  c_DOMDocument::os_lval,
  c_DOMDocument::os_invoke,
  c_DOMDocument::os_constant,
  c_DOMDocument::os_get_call_info
};
Object co_LibXMLError(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_LibXMLError)())->dynCreate(params, init));
}
Object coo_LibXMLError() {
  Object r(NEW(c_LibXMLError)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_LibXMLError
Variant c_LibXMLError::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_LibXMLError
Variant c_LibXMLError::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_LibXMLError
Variant &c_LibXMLError::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_LibXMLError
void c_LibXMLError::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_LibXMLError
void c_LibXMLError::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_LibXMLError
Variant * c_LibXMLError::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_LibXMLError
Variant * c_LibXMLError::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_LibXMLError
Variant * c_LibXMLError::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_LibXMLError
Variant c_LibXMLError::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_LibXMLError
IMPLEMENT_CLASS(LibXMLError)
void c_LibXMLError::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_LibXMLError::cloneImpl() {
  c_LibXMLError *obj = NEW(c_LibXMLError)();
  cloneSet(obj);
  return obj;
}
void c_LibXMLError::cloneSet(c_LibXMLError *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_LibXMLError::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_LibXMLError::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_LibXMLError::ci___destruct((void*)&c_LibXMLError::i___destruct, (void*)&c_LibXMLError::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_LibXMLError::ci___construct((void*)&c_LibXMLError::i___construct, (void*)&c_LibXMLError::ifa___construct, 0, 0, 0x0000000000000000LL);
Variant c_LibXMLError::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_LibXMLError *self = NULL;
  p_LibXMLError pobj;
  if (mcp.obj) {
    self = static_cast<c_LibXMLError*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_LibXMLError::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_LibXMLError *self = NULL;
  p_LibXMLError pobj;
  if (mcp.obj) {
    self = static_cast<c_LibXMLError*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_LibXMLError::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_LibXMLError *self = NULL;
  p_LibXMLError pobj;
  if (mcp.obj) {
    self = static_cast<c_LibXMLError*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_LibXMLError::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_LibXMLError *self = NULL;
  p_LibXMLError pobj;
  if (mcp.obj) {
    self = static_cast<c_LibXMLError*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
bool c_LibXMLError::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_LibXMLError::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_LibXMLError::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_LibXMLError::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_LibXMLError::ci___destruct;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_LibXMLError::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_get_call_info(mcp, hash);
}
c_LibXMLError *c_LibXMLError::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_LibXMLError::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_LibXMLError::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_LibXMLError::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_LibXMLError::ci___construct;
  mcp.obj = this;
}
void c_LibXMLError::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_LibXMLError = {
  c_LibXMLError::os_getInit,
  c_LibXMLError::os_get,
  c_LibXMLError::os_lval,
  c_LibXMLError::os_invoke,
  c_LibXMLError::os_constant,
  c_LibXMLError::os_get_call_info
};
Object co_SoapFault(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SoapFault)())->dynCreate(params, init));
}
Object coo_SoapFault() {
  Object r(NEW(c_SoapFault)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapFault
Variant c_SoapFault::os_getInit(CStrRef s) {
  return c_Exception::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapFault
Variant c_SoapFault::os_get(CStrRef s) {
  return c_Exception::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapFault
Variant &c_SoapFault::os_lval(CStrRef s) {
  return c_Exception::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapFault
void c_SoapFault::o_getArray(Array &props) const {
  c_Exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapFault
void c_SoapFault::o_setArray(CArrRef props) {
  c_Exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SoapFault
Variant * c_SoapFault::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapFault
Variant * c_SoapFault::o_realPropPublic(CStrRef s, int flags) const {
  return c_Exception::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapFault
Variant * c_SoapFault::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapFault
Variant c_SoapFault::os_constant(const char *s) {
  return c_Exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapFault
IMPLEMENT_CLASS(SoapFault)
void c_SoapFault::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SoapFault::cloneImpl() {
  c_SoapFault *obj = NEW(c_SoapFault)();
  cloneSet(obj);
  return obj;
}
void c_SoapFault::cloneSet(c_SoapFault *clone) {
  c_Exception::cloneSet(clone);
}
Variant c_SoapFault::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed_1, "__tostring")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        else return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
  return c_Exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SoapFault::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_Exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SoapFault::ci___tostring((void*)&c_SoapFault::i___tostring, (void*)&c_SoapFault::ifa___tostring, 0, 0, 0x0000000000000000LL);
CallInfo c_SoapFault::ci___destruct((void*)&c_SoapFault::i___destruct, (void*)&c_SoapFault::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_SoapFault::ci___construct((void*)&c_SoapFault::i___construct, (void*)&c_SoapFault::ifa___construct, 6, 0, 0x0000000000000000LL);
Variant c_SoapFault::i___tostring(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapFault *self = NULL;
  p_SoapFault pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapFault*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
  return (self->t___tostring());
}
Variant c_SoapFault::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapFault *self = NULL;
  p_SoapFault pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapFault*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapFault::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapFault *self = NULL;
  p_SoapFault pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapFault*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t___construct(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t___construct(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t___construct(arg0, arg1, arg2, arg3), null);
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (self->t___construct(arg0, arg1, arg2, arg3, arg4), null);
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1, arg2, arg3, arg4, arg5), null);
  }
}
Variant c_SoapFault::ifa___tostring(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapFault *self = NULL;
  p_SoapFault pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapFault*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
  return (self->t___tostring());
}
Variant c_SoapFault::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapFault *self = NULL;
  p_SoapFault pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapFault*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapFault::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapFault *self = NULL;
  p_SoapFault pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapFault*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
  if (count <= 2) return (self->t___construct(a0, a1), null);
  if (count == 3) return (self->t___construct(a0, a1, a2), null);
  if (count == 4) return (self->t___construct(a0, a1, a2, a3), null);
  if (count == 5) return (self->t___construct(a0, a1, a2, a3, a4), null);
  return (self->t___construct(a0, a1, a2, a3, a4, a5), null);
}
bool c_SoapFault::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed_1, "__tostring")) {
        mcp.ci = &c_SoapFault::ci___tostring;
        return true;
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SoapFault::ci___destruct;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SoapFault::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_Exception::os_get_call_info(mcp, hash);
}
bool c_SoapFault::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed_1, "__tostring")) {
        mcp.ci = &c_SoapFault::ci___tostring;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_SoapFault::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_SoapFault::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_Exception::o_get_call_info(mcp, hash);
}
c_SoapFault *c_SoapFault::create(Variant a0, String a1, String a2, Variant a3, String a4, Variant a5) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4, a5);
  return this;
}
ObjectData *c_SoapFault::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      if (count <= 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 5) {
        (t___construct(arg0, arg1, arg2, arg3, arg4));
        break;
      }
      CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
    } while (false);
  }
  return this;
}
void c_SoapFault::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) {
      (t___construct(arg0, arg1, arg2, arg3, arg4));
      break;
    }
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
  } while (false);
}
void c_SoapFault::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SoapFault::ci___construct;
  mcp.obj = this;
}
void c_SoapFault::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else if (count == 5) (t___construct(a0, a1, a2, a3, a4), null);
  else (t___construct(a0, a1, a2, a3, a4, a5), null);
}
struct ObjectStaticCallbacks cw_SoapFault = {
  c_SoapFault::os_getInit,
  c_SoapFault::os_get,
  c_SoapFault::os_lval,
  c_SoapFault::os_invoke,
  c_SoapFault::os_constant,
  c_SoapFault::os_get_call_info
};
Object co_DOMElement(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMElement)())->dynCreate(params, init));
}
Object coo_DOMElement() {
  Object r(NEW(c_DOMElement)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMElement
Variant c_DOMElement::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMElement
Variant c_DOMElement::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMElement
Variant &c_DOMElement::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMElement
void c_DOMElement::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMElement
void c_DOMElement::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMElement
Variant * c_DOMElement::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMElement
Variant * c_DOMElement::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMElement
Variant * c_DOMElement::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMElement
Variant c_DOMElement::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMElement
IMPLEMENT_CLASS(DOMElement)
void c_DOMElement::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMElement::cloneImpl() {
  c_DOMElement *obj = NEW(c_DOMElement)();
  cloneSet(obj);
  return obj;
}
void c_DOMElement::cloneSet(c_DOMElement *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMElement::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 10:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss13546c36, "getElementsByTagName")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss35b7e836, "getElementsByTagNameNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagnamens(a0, a1));
      }
      HASH_GUARD_LITSTR(0x29D272CBBC0CDA4ALL, NAMSTR(s_sys_ss43f325b6, "setIDAttributeNode")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattributenode(a0, a1));
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a_1, "setAttribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x710986B01E1A0890LL, NAMSTR(s_sys_ss1e1a0890, "removeAttributeNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattributens(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x31426AC6A851EE11LL, NAMSTR(s_sys_ss57ae11ef, "setIDAttributeNS")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattributens(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x482E3873306253D1LL, NAMSTR(s_sys_ss306253d1, "setAttributeNodeNS")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributenodens(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5EF7C3A45311D955LL, NAMSTR(s_sys_ss5311d955, "hasAttributeNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributens(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x6F83EC29E110D616LL, NAMSTR(s_sys_ss1eef29ea, "setIDAttribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattribute(a0, a1));
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x62A40E71FAF19157LL, NAMSTR(s_sys_ss050e6ea9, "setAttributeNS")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributens(a0, a1, a2));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x640FA60DDC80EC18LL, NAMSTR(s_sys_ss237f13e8, "getAttributeNodeNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributenodens(a0, a1));
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x34E103E06D3F0899LL, NAMSTR(s_sys_ss6d3f0899, "getAttributeNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributens(a0, a1));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x606827EF5CF34C5CLL, NAMSTR(s_sys_ss5cf34c5c, "setAttributeNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributenode(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else return (t___construct(a0, a1, a2), null);
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28_1, "getAttribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x1BFDB4272EA150EALL, NAMSTR(s_sys_ss2ea150ea, "removeAttributeNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattributenode(a0));
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x6471DF8BB944FFECLL, NAMSTR(s_sys_ss46bb0014, "hasAttribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x47B96C0FC62E1E2FLL, NAMSTR(s_sys_ss39d1e1d1, "removeAttribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattribute(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x343DF562BB5AB1FELL, NAMSTR(s_sys_ss44a54e02, "getAttributeNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributenode(a0));
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMElement::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMElement::ci_getelementsbytagname((void*)&c_DOMElement::i_getelementsbytagname, (void*)&c_DOMElement::ifa_getelementsbytagname, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_setidattributens((void*)&c_DOMElement::i_setidattributens, (void*)&c_DOMElement::ifa_setidattributens, 3, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_getattribute((void*)&c_DOMElement::i_getattribute, (void*)&c_DOMElement::ifa_getattribute, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_getelementsbytagnamens((void*)&c_DOMElement::i_getelementsbytagnamens, (void*)&c_DOMElement::ifa_getelementsbytagnamens, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_getattributenodens((void*)&c_DOMElement::i_getattributenodens, (void*)&c_DOMElement::ifa_getattributenodens, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci___destruct((void*)&c_DOMElement::i___destruct, (void*)&c_DOMElement::ifa___destruct, 0, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci___set((void*)&c_DOMElement::i___set, (void*)&c_DOMElement::ifa___set, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci___construct((void*)&c_DOMElement::i___construct, (void*)&c_DOMElement::ifa___construct, 3, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_hasattribute((void*)&c_DOMElement::i_hasattribute, (void*)&c_DOMElement::ifa_hasattribute, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_hasattributens((void*)&c_DOMElement::i_hasattributens, (void*)&c_DOMElement::ifa_hasattributens, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_setattributenodens((void*)&c_DOMElement::i_setattributenodens, (void*)&c_DOMElement::ifa_setattributenodens, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_setattributens((void*)&c_DOMElement::i_setattributens, (void*)&c_DOMElement::ifa_setattributens, 3, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_getattributens((void*)&c_DOMElement::i_getattributens, (void*)&c_DOMElement::ifa_getattributens, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_removeattributens((void*)&c_DOMElement::i_removeattributens, (void*)&c_DOMElement::ifa_removeattributens, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_getattributenode((void*)&c_DOMElement::i_getattributenode, (void*)&c_DOMElement::ifa_getattributenode, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_setidattribute((void*)&c_DOMElement::i_setidattribute, (void*)&c_DOMElement::ifa_setidattribute, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_setidattributenode((void*)&c_DOMElement::i_setidattributenode, (void*)&c_DOMElement::ifa_setidattributenode, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_setattribute((void*)&c_DOMElement::i_setattribute, (void*)&c_DOMElement::ifa_setattribute, 2, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_removeattributenode((void*)&c_DOMElement::i_removeattributenode, (void*)&c_DOMElement::ifa_removeattributenode, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci___get((void*)&c_DOMElement::i___get, (void*)&c_DOMElement::ifa___get, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_removeattribute((void*)&c_DOMElement::i_removeattribute, (void*)&c_DOMElement::ifa_removeattribute, 1, 0, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_setattributenode((void*)&c_DOMElement::i_setattributenode, (void*)&c_DOMElement::ifa_setattributenode, 1, 0, 0x0000000000000000LL);
Variant c_DOMElement::i_getelementsbytagname(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getelementsbytagname(arg0));
  }
}
Variant c_DOMElement::i_setidattributens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setidattributens(arg0, arg1, arg2));
  }
}
Variant c_DOMElement::i_getattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getattribute(arg0));
  }
}
Variant c_DOMElement::i_getelementsbytagnamens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getelementsbytagnamens(arg0, arg1));
  }
}
Variant c_DOMElement::i_getattributenodens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getattributenodens(arg0, arg1));
  }
}
Variant c_DOMElement::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMElement::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMElement::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t___construct(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1, arg2), null);
  }
}
Variant c_DOMElement::i_hasattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_hasattribute(arg0));
  }
}
Variant c_DOMElement::i_hasattributens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_hasattributens(arg0, arg1));
  }
}
Variant c_DOMElement::i_setattributenodens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setattributenodens(arg0));
  }
}
Variant c_DOMElement::i_setattributens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setattributens(arg0, arg1, arg2));
  }
}
Variant c_DOMElement::i_getattributens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getattributens(arg0, arg1));
  }
}
Variant c_DOMElement::i_removeattributens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_removeattributens(arg0, arg1));
  }
}
Variant c_DOMElement::i_getattributenode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getattributenode(arg0));
  }
}
Variant c_DOMElement::i_setidattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setidattribute(arg0, arg1));
  }
}
Variant c_DOMElement::i_setidattributenode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setidattributenode(arg0, arg1));
  }
}
Variant c_DOMElement::i_setattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setattribute(arg0, arg1));
  }
}
Variant c_DOMElement::i_removeattributenode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_removeattributenode(arg0));
  }
}
Variant c_DOMElement::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMElement::i_removeattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_removeattribute(arg0));
  }
}
Variant c_DOMElement::i_setattributenode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setattributenode(arg0));
  }
}
Variant c_DOMElement::ifa_getelementsbytagname(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
  return (self->t_getelementsbytagname(a0));
}
Variant c_DOMElement::ifa_setidattributens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
  return (self->t_setidattributens(a0, a1, a2));
}
Variant c_DOMElement::ifa_getattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
  return (self->t_getattribute(a0));
}
Variant c_DOMElement::ifa_getelementsbytagnamens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
  return (self->t_getelementsbytagnamens(a0, a1));
}
Variant c_DOMElement::ifa_getattributenodens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
  return (self->t_getattributenodens(a0, a1));
}
Variant c_DOMElement::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMElement::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMElement::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
  if (count <= 1) return (self->t___construct(a0), null);
  if (count == 2) return (self->t___construct(a0, a1), null);
  return (self->t___construct(a0, a1, a2), null);
}
Variant c_DOMElement::ifa_hasattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
  return (self->t_hasattribute(a0));
}
Variant c_DOMElement::ifa_hasattributens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
  return (self->t_hasattributens(a0, a1));
}
Variant c_DOMElement::ifa_setattributenodens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
  return (self->t_setattributenodens(a0));
}
Variant c_DOMElement::ifa_setattributens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
  return (self->t_setattributens(a0, a1, a2));
}
Variant c_DOMElement::ifa_getattributens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
  return (self->t_getattributens(a0, a1));
}
Variant c_DOMElement::ifa_removeattributens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
  return (self->t_removeattributens(a0, a1));
}
Variant c_DOMElement::ifa_getattributenode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
  return (self->t_getattributenode(a0));
}
Variant c_DOMElement::ifa_setidattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
  return (self->t_setidattribute(a0, a1));
}
Variant c_DOMElement::ifa_setidattributenode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
  return (self->t_setidattributenode(a0, a1));
}
Variant c_DOMElement::ifa_setattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
  return (self->t_setattribute(a0, a1));
}
Variant c_DOMElement::ifa_removeattributenode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
  return (self->t_removeattributenode(a0));
}
Variant c_DOMElement::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
Variant c_DOMElement::ifa_removeattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
  return (self->t_removeattribute(a0));
}
Variant c_DOMElement::ifa_setattributenode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
  return (self->t_setattributenode(a0));
}
bool c_DOMElement::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 10:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss13546c36, "getElementsByTagName")) {
        mcp.ci = &c_DOMElement::ci_getelementsbytagname;
        return true;
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss35b7e836, "getElementsByTagNameNS")) {
        mcp.ci = &c_DOMElement::ci_getelementsbytagnamens;
        return true;
      }
      HASH_GUARD_LITSTR(0x29D272CBBC0CDA4ALL, NAMSTR(s_sys_ss43f325b6, "setIDAttributeNode")) {
        mcp.ci = &c_DOMElement::ci_setidattributenode;
        return true;
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a_1, "setAttribute")) {
        mcp.ci = &c_DOMElement::ci_setattribute;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMElement::ci___get;
        return true;
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x710986B01E1A0890LL, NAMSTR(s_sys_ss1e1a0890, "removeAttributeNS")) {
        mcp.ci = &c_DOMElement::ci_removeattributens;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x31426AC6A851EE11LL, NAMSTR(s_sys_ss57ae11ef, "setIDAttributeNS")) {
        mcp.ci = &c_DOMElement::ci_setidattributens;
        return true;
      }
      HASH_GUARD_LITSTR(0x482E3873306253D1LL, NAMSTR(s_sys_ss306253d1, "setAttributeNodeNS")) {
        mcp.ci = &c_DOMElement::ci_setattributenodens;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMElement::ci___set;
        return true;
      }
      HASH_GUARD_LITSTR(0x5EF7C3A45311D955LL, NAMSTR(s_sys_ss5311d955, "hasAttributeNS")) {
        mcp.ci = &c_DOMElement::ci_hasattributens;
        return true;
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x6F83EC29E110D616LL, NAMSTR(s_sys_ss1eef29ea, "setIDAttribute")) {
        mcp.ci = &c_DOMElement::ci_setidattribute;
        return true;
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x62A40E71FAF19157LL, NAMSTR(s_sys_ss050e6ea9, "setAttributeNS")) {
        mcp.ci = &c_DOMElement::ci_setattributens;
        return true;
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x640FA60DDC80EC18LL, NAMSTR(s_sys_ss237f13e8, "getAttributeNodeNS")) {
        mcp.ci = &c_DOMElement::ci_getattributenodens;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x34E103E06D3F0899LL, NAMSTR(s_sys_ss6d3f0899, "getAttributeNS")) {
        mcp.ci = &c_DOMElement::ci_getattributens;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x606827EF5CF34C5CLL, NAMSTR(s_sys_ss5cf34c5c, "setAttributeNode")) {
        mcp.ci = &c_DOMElement::ci_setattributenode;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMElement::ci___construct;
        return true;
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28_1, "getAttribute")) {
        mcp.ci = &c_DOMElement::ci_getattribute;
        return true;
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x1BFDB4272EA150EALL, NAMSTR(s_sys_ss2ea150ea, "removeAttributeNode")) {
        mcp.ci = &c_DOMElement::ci_removeattributenode;
        return true;
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x6471DF8BB944FFECLL, NAMSTR(s_sys_ss46bb0014, "hasAttribute")) {
        mcp.ci = &c_DOMElement::ci_hasattribute;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x47B96C0FC62E1E2FLL, NAMSTR(s_sys_ss39d1e1d1, "removeAttribute")) {
        mcp.ci = &c_DOMElement::ci_removeattribute;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMElement::ci___destruct;
        return true;
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x343DF562BB5AB1FELL, NAMSTR(s_sys_ss44a54e02, "getAttributeNode")) {
        mcp.ci = &c_DOMElement::ci_getattributenode;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMElement::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 10:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss13546c36, "getElementsByTagName")) {
        mcp.ci = &c_DOMElement::ci_getelementsbytagname;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss35b7e836, "getElementsByTagNameNS")) {
        mcp.ci = &c_DOMElement::ci_getelementsbytagnamens;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x29D272CBBC0CDA4ALL, NAMSTR(s_sys_ss43f325b6, "setIDAttributeNode")) {
        mcp.ci = &c_DOMElement::ci_setidattributenode;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a_1, "setAttribute")) {
        mcp.ci = &c_DOMElement::ci_setattribute;
        mcp.obj = this;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        mcp.ci = &c_DOMElement::ci___get;
        mcp.obj = this;
        return true;
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x710986B01E1A0890LL, NAMSTR(s_sys_ss1e1a0890, "removeAttributeNS")) {
        mcp.ci = &c_DOMElement::ci_removeattributens;
        mcp.obj = this;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x31426AC6A851EE11LL, NAMSTR(s_sys_ss57ae11ef, "setIDAttributeNS")) {
        mcp.ci = &c_DOMElement::ci_setidattributens;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x482E3873306253D1LL, NAMSTR(s_sys_ss306253d1, "setAttributeNodeNS")) {
        mcp.ci = &c_DOMElement::ci_setattributenodens;
        mcp.obj = this;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        mcp.ci = &c_DOMElement::ci___set;
        mcp.obj = this;
        return true;
      }
      HASH_GUARD_LITSTR(0x5EF7C3A45311D955LL, NAMSTR(s_sys_ss5311d955, "hasAttributeNS")) {
        mcp.ci = &c_DOMElement::ci_hasattributens;
        mcp.obj = this;
        return true;
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x6F83EC29E110D616LL, NAMSTR(s_sys_ss1eef29ea, "setIDAttribute")) {
        mcp.ci = &c_DOMElement::ci_setidattribute;
        mcp.obj = this;
        return true;
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x62A40E71FAF19157LL, NAMSTR(s_sys_ss050e6ea9, "setAttributeNS")) {
        mcp.ci = &c_DOMElement::ci_setattributens;
        mcp.obj = this;
        return true;
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x640FA60DDC80EC18LL, NAMSTR(s_sys_ss237f13e8, "getAttributeNodeNS")) {
        mcp.ci = &c_DOMElement::ci_getattributenodens;
        mcp.obj = this;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x34E103E06D3F0899LL, NAMSTR(s_sys_ss6d3f0899, "getAttributeNS")) {
        mcp.ci = &c_DOMElement::ci_getattributens;
        mcp.obj = this;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x606827EF5CF34C5CLL, NAMSTR(s_sys_ss5cf34c5c, "setAttributeNode")) {
        mcp.ci = &c_DOMElement::ci_setattributenode;
        mcp.obj = this;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        mcp.ci = &c_DOMElement::ci___construct;
        mcp.obj = this;
        return true;
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28_1, "getAttribute")) {
        mcp.ci = &c_DOMElement::ci_getattribute;
        mcp.obj = this;
        return true;
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x1BFDB4272EA150EALL, NAMSTR(s_sys_ss2ea150ea, "removeAttributeNode")) {
        mcp.ci = &c_DOMElement::ci_removeattributenode;
        mcp.obj = this;
        return true;
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x6471DF8BB944FFECLL, NAMSTR(s_sys_ss46bb0014, "hasAttribute")) {
        mcp.ci = &c_DOMElement::ci_hasattribute;
        mcp.obj = this;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x47B96C0FC62E1E2FLL, NAMSTR(s_sys_ss39d1e1d1, "removeAttribute")) {
        mcp.ci = &c_DOMElement::ci_removeattribute;
        mcp.obj = this;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        mcp.ci = &c_DOMElement::ci___destruct;
        mcp.obj = this;
        return true;
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x343DF562BB5AB1FELL, NAMSTR(s_sys_ss44a54e02, "getAttributeNode")) {
        mcp.ci = &c_DOMElement::ci_getattributenode;
        mcp.obj = this;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_get_call_info(mcp, hash);
}
c_DOMElement *c_DOMElement::create(String a0, String a1, String a2) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2);
  return this;
}
ObjectData *c_DOMElement::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 3) throw_wrong_arguments("__construct", count, 1, 3, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1, arg2));
    } while (false);
  }
  return this;
}
void c_DOMElement::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) throw_wrong_arguments("__construct", count, 1, 3, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2));
  } while (false);
}
void c_DOMElement::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMElement::ci___construct;
  mcp.obj = this;
}
void c_DOMElement::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) throw_wrong_arguments("__construct", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else (t___construct(a0, a1, a2), null);
}
struct ObjectStaticCallbacks cw_DOMElement = {
  c_DOMElement::os_getInit,
  c_DOMElement::os_get,
  c_DOMElement::os_lval,
  c_DOMElement::os_invoke,
  c_DOMElement::os_constant,
  c_DOMElement::os_get_call_info
};
Variant get_builtin_class_var_init(const char *s, const char *var) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 8:
      HASH_GET_CLASS_VAR_INIT(0x4DA860E5647C3908LL, ImageSprite);
      break;
    case 9:
      HASH_GET_CLASS_VAR_INIT(0x21EF70351574EC09LL, ReflectionFunction);
      break;
    case 11:
      HASH_GET_CLASS_VAR_INIT(0x4365BE9E5A85E60BLL, DOMNotation);
      HASH_GET_CLASS_VAR_INIT(0x69EDCA1CC29CFE0BLL, ErrorException);
      break;
    case 18:
      HASH_GET_CLASS_VAR_INIT(0x78B42582709BAF12LL, DebuggerProxy);
      break;
    case 19:
      HASH_GET_CLASS_VAR_INIT(0x6A76B9AABB7CC713LL, SimpleXMLElement);
      break;
    case 21:
      HASH_GET_CLASS_VAR_INIT(0x32E5C767255D2515LL, SoapFault);
      break;
    case 26:
      HASH_GET_CLASS_VAR_INIT(0x5CBA5B52C68B501ALL, DOMEntityReference);
      break;
    case 29:
      HASH_GET_CLASS_VAR_INIT(0x35A44A5E6AE2E71DLL, ReflectionClass);
      break;
    case 30:
      HASH_GET_CLASS_VAR_INIT(0x3DB8FB455A602A1ELL, DateTime);
      break;
    case 43:
      HASH_GET_CLASS_VAR_INIT(0x7E66D362EAB5BF2BLL, SimpleXMLElementIterator);
      break;
    case 49:
      HASH_GET_CLASS_VAR_INIT(0x7A394042E7488231LL, FilterIterator);
      break;
    case 50:
      HASH_GET_CLASS_VAR_INIT(0x365899865E2EAA32LL, RecursiveIteratorIterator);
      break;
    case 53:
      HASH_GET_CLASS_VAR_INIT(0x7909270014376235LL, SoapVar);
      break;
    case 55:
      HASH_GET_CLASS_VAR_INIT(0x7FF7A8442616EF37LL, DOMNodeIterator);
      break;
    case 56:
      HASH_GET_CLASS_VAR_INIT(0x672AD818DDE95538LL, ReflectionException);
      break;
    case 61:
      HASH_GET_CLASS_VAR_INIT(0x4C6991D3CF5CA03DLL, Collator);
      break;
    case 62:
      HASH_GET_CLASS_VAR_INIT(0x49FC1A1F7B878C3ELL, SoapServer);
      break;
    case 65:
      HASH_GET_CLASS_VAR_INIT(0x227C70ED5B143841LL, OutOfBoundsException);
      break;
    case 68:
      HASH_GET_CLASS_VAR_INIT(0x4253D8488B734244LL, PDOStatement);
      break;
    case 70:
      HASH_GET_CLASS_VAR_INIT(0x196F76C9C527B946LL, DOMNamedNodeMap);
      HASH_GET_CLASS_VAR_INIT(0x66282FC8E4EF4E46LL, BadFunctionCallException);
      break;
    case 73:
      HASH_GET_CLASS_VAR_INIT(0x5AA2EE582E0D3849LL, UnexpectedValueException);
      break;
    case 75:
      HASH_GET_CLASS_VAR_INIT(0x4860DC2F9B0E6D4BLL, LogicException);
      break;
    case 77:
      HASH_GET_CLASS_VAR_INIT(0x164F490DAC49174DLL, DOMText);
      break;
    case 78:
      HASH_GET_CLASS_VAR_INIT(0x308D1D59986A3D4ELL, SoapHeader);
      break;
    case 79:
      HASH_GET_CLASS_VAR_INIT(0x5BA243B9FBA7A64FLL, SplObjectStorage);
      break;
    case 80:
      HASH_GET_CLASS_VAR_INIT(0x52EA111229F87A50LL, Normalizer);
      break;
    case 83:
      HASH_GET_CLASS_VAR_INIT(0x02239AA5D64B1453LL, DOMCharacterData);
      HASH_GET_CLASS_VAR_INIT(0x6AF83706F76A9D53LL, RangeException);
      break;
    case 94:
      HASH_GET_CLASS_VAR_INIT(0x7754323897E8A15ELL, DirectoryIterator);
      break;
    case 97:
      HASH_GET_CLASS_VAR_INIT(0x70EBB2CC1FBF9761LL, DOMDocumentType);
      break;
    case 98:
      HASH_GET_CLASS_VAR_INIT(0x70747A09B3523662LL, DOMNode);
      break;
    case 99:
      HASH_GET_CLASS_VAR_INIT(0x7D1235273F521A63LL, DebuggerClient);
      break;
    case 101:
      HASH_GET_CLASS_VAR_INIT(0x2FF1EF6EBB3DA065LL, XMLWriter);
      break;
    case 104:
      HASH_GET_CLASS_VAR_INIT(0x7E07B9C27FE59D68LL, DOMComment);
      HASH_GET_CLASS_VAR_INIT(0x17A40D895C55D968LL, SoapParam);
      break;
    case 106:
      HASH_GET_CLASS_VAR_INIT(0x6A5B99D5B1A4566ALL, DOMException);
      break;
    case 107:
      HASH_GET_CLASS_VAR_INIT(0x3CAE91CFA2AAD16BLL, LengthException);
      break;
    case 115:
      HASH_GET_CLASS_VAR_INIT(0x3D5870E53BF89873LL, ArrayIterator);
      HASH_GET_CLASS_VAR_INIT(0x0B61E0BFCFA06573LL, ReflectionExtension);
      break;
    case 117:
      HASH_GET_CLASS_VAR_INIT(0x085A4F6FD393D475LL, InvalidArgumentException);
      break;
    case 122:
      HASH_GET_CLASS_VAR_INIT(0x41A9F7D81254DD7ALL, ReflectionObject);
      break;
    case 125:
      HASH_GET_CLASS_VAR_INIT(0x7AD161197633B87DLL, DOMDocumentFragment);
      HASH_GET_CLASS_VAR_INIT(0x2E899D2A2572EF7DLL, SQLite3Result);
      break;
    case 128:
      HASH_GET_CLASS_VAR_INIT(0x59B3EFD1CD987F80LL, DOMProcessingInstruction);
      break;
    case 130:
      HASH_GET_CLASS_VAR_INIT(0x33BD46E935281082LL, ReflectionFunctionAbstract);
      break;
    case 131:
      HASH_GET_CLASS_VAR_INIT(0x24DE53FD7D3E8383LL, DateTimeZone);
      break;
    case 132:
      HASH_GET_CLASS_VAR_INIT(0x70D4A29DE6A7BA84LL, DomainException);
      break;
    case 143:
      HASH_GET_CLASS_VAR_INIT(0x34C95AF311506C8FLL, Directory);
      break;
    case 144:
      HASH_GET_CLASS_VAR_INIT(0x06335FF83CDEA590LL, BadMethodCallException);
      break;
    case 147:
      HASH_GET_CLASS_VAR_INIT(0x2E7081C468A05993LL, ReflectionParameter);
      break;
    case 148:
      HASH_GET_CLASS_VAR_INIT(0x6FFDF8DF15CABE94LL, DOMCDATASection);
      HASH_GET_CLASS_VAR_INIT(0x6576EACCCE24D694LL, __PHP_Incomplete_Class);
      HASH_GET_CLASS_VAR_INIT(0x47D93E6F80B66A94LL, Exception);
      break;
    case 167:
      HASH_GET_CLASS_VAR_INIT(0x71089C29FE923FA7LL, SplFileInfo);
      break;
    case 168:
      HASH_GET_CLASS_VAR_INIT(0x7D46DB2E09C6DBA8LL, DOMXPath);
      break;
    case 169:
      HASH_GET_CLASS_VAR_INIT(0x1D35C3EFD00E11A9LL, SQLite3);
      break;
    case 170:
      HASH_GET_CLASS_VAR_INIT(0x67E31D42F2DFE4AALL, Locale);
      break;
    case 173:
      HASH_GET_CLASS_VAR_INIT(0x0A34015F67C804ADLL, PDO);
      break;
    case 175:
      HASH_GET_CLASS_VAR_INIT(0x2E650138BA043AAFLL, DOMDocument);
      break;
    case 176:
      HASH_GET_CLASS_VAR_INIT(0x43BBC8F6F28E44B0LL, ReflectionMethod);
      break;
    case 177:
      HASH_GET_CLASS_VAR_INIT(0x6DD772FA3B20B8B1LL, DOMNodeList);
      break;
    case 189:
      HASH_GET_CLASS_VAR_INIT(0x5D8785ACD19F77BDLL, PDOException);
      break;
    case 195:
      HASH_GET_CLASS_VAR_INIT(0x40B3C44077F5DDC3LL, DOMElement);
      break;
    case 200:
      HASH_GET_CLASS_VAR_INIT(0x2E363D51549781C8LL, AppendIterator);
      break;
    case 203:
      HASH_GET_CLASS_VAR_INIT(0x253AC17234FC8CCBLL, LibXMLError);
      break;
    case 208:
      HASH_GET_CLASS_VAR_INIT(0x3C122DF8859C72D0LL, Memcache);
      break;
    case 210:
      HASH_GET_CLASS_VAR_INIT(0x52E5CC58B841AED2LL, SQLite3Stmt);
      HASH_GET_CLASS_VAR_INIT(0x297ECCC7A259EDD2LL, SplFileObject);
      break;
    case 212:
      HASH_GET_CLASS_VAR_INIT(0x5E623FEAF7B068D4LL, UnderflowException);
      break;
    case 216:
      HASH_GET_CLASS_VAR_INIT(0x464D3427431A6ED8LL, RecursiveDirectoryIterator);
      break;
    case 217:
      HASH_GET_CLASS_VAR_INIT(0x0E4CCE95F6A727D9LL, OverflowException);
      break;
    case 218:
      HASH_GET_CLASS_VAR_INIT(0x7A52EBE538182BDALL, SoapClient);
      break;
    case 220:
      HASH_GET_CLASS_VAR_INIT(0x1078CB3118A8B3DCLL, RuntimeException);
      break;
    case 228:
      HASH_GET_CLASS_VAR_INIT(0x75AA2571BDB659E4LL, ReflectionProperty);
      break;
    case 244:
      HASH_GET_CLASS_VAR_INIT(0x297174231D4912F4LL, DOMAttr);
      break;
    case 247:
      HASH_GET_CLASS_VAR_INIT(0x3D69936178BA13F7LL, stdClass);
      break;
    case 252:
      HASH_GET_CLASS_VAR_INIT(0x622D4DF07E2A01FCLL, OutOfRangeException);
      break;
    case 253:
      HASH_GET_CLASS_VAR_INIT(0x74419B70A46387FDLL, DOMImplementation);
      break;
    case 255:
      HASH_GET_CLASS_VAR_INIT(0x624835B2D74B86FFLL, DOMEntity);
      break;
    default:
      break;
  }
  return throw_missing_class(s);
}
Object create_builtin_object_only(const char *s, ObjectData* root /* = NULL*/) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 8:
      HASH_CREATE_OBJECT_ONLY(0x4DA860E5647C3908LL, ImageSprite);
      break;
    case 9:
      HASH_CREATE_OBJECT_ONLY(0x21EF70351574EC09LL, ReflectionFunction);
      break;
    case 11:
      HASH_CREATE_OBJECT_ONLY(0x4365BE9E5A85E60BLL, DOMNotation);
      HASH_CREATE_OBJECT_ONLY(0x69EDCA1CC29CFE0BLL, ErrorException);
      break;
    case 18:
      HASH_CREATE_OBJECT_ONLY(0x78B42582709BAF12LL, DebuggerProxy);
      break;
    case 19:
      HASH_CREATE_OBJECT_ONLY(0x6A76B9AABB7CC713LL, SimpleXMLElement);
      break;
    case 21:
      HASH_CREATE_OBJECT_ONLY(0x32E5C767255D2515LL, SoapFault);
      break;
    case 26:
      HASH_CREATE_OBJECT_ONLY(0x5CBA5B52C68B501ALL, DOMEntityReference);
      break;
    case 29:
      HASH_CREATE_OBJECT_ONLY(0x35A44A5E6AE2E71DLL, ReflectionClass);
      break;
    case 30:
      HASH_CREATE_OBJECT_ONLY(0x3DB8FB455A602A1ELL, DateTime);
      break;
    case 43:
      HASH_CREATE_OBJECT_ONLY(0x7E66D362EAB5BF2BLL, SimpleXMLElementIterator);
      break;
    case 49:
      HASH_CREATE_OBJECT_ONLY(0x7A394042E7488231LL, FilterIterator);
      break;
    case 50:
      HASH_CREATE_OBJECT_ONLY(0x365899865E2EAA32LL, RecursiveIteratorIterator);
      break;
    case 53:
      HASH_CREATE_OBJECT_ONLY(0x7909270014376235LL, SoapVar);
      break;
    case 55:
      HASH_CREATE_OBJECT_ONLY(0x7FF7A8442616EF37LL, DOMNodeIterator);
      break;
    case 56:
      HASH_CREATE_OBJECT_ONLY(0x672AD818DDE95538LL, ReflectionException);
      break;
    case 61:
      HASH_CREATE_OBJECT_ONLY(0x4C6991D3CF5CA03DLL, Collator);
      break;
    case 62:
      HASH_CREATE_OBJECT_ONLY(0x49FC1A1F7B878C3ELL, SoapServer);
      break;
    case 65:
      HASH_CREATE_OBJECT_ONLY(0x227C70ED5B143841LL, OutOfBoundsException);
      break;
    case 68:
      HASH_CREATE_OBJECT_ONLY(0x4253D8488B734244LL, PDOStatement);
      break;
    case 70:
      HASH_CREATE_OBJECT_ONLY(0x196F76C9C527B946LL, DOMNamedNodeMap);
      HASH_CREATE_OBJECT_ONLY(0x66282FC8E4EF4E46LL, BadFunctionCallException);
      break;
    case 73:
      HASH_CREATE_OBJECT_ONLY(0x5AA2EE582E0D3849LL, UnexpectedValueException);
      break;
    case 75:
      HASH_CREATE_OBJECT_ONLY(0x4860DC2F9B0E6D4BLL, LogicException);
      break;
    case 77:
      HASH_CREATE_OBJECT_ONLY(0x164F490DAC49174DLL, DOMText);
      break;
    case 78:
      HASH_CREATE_OBJECT_ONLY(0x308D1D59986A3D4ELL, SoapHeader);
      break;
    case 79:
      HASH_CREATE_OBJECT_ONLY(0x5BA243B9FBA7A64FLL, SplObjectStorage);
      break;
    case 80:
      HASH_CREATE_OBJECT_ONLY(0x52EA111229F87A50LL, Normalizer);
      break;
    case 83:
      HASH_CREATE_OBJECT_ONLY(0x02239AA5D64B1453LL, DOMCharacterData);
      HASH_CREATE_OBJECT_ONLY(0x6AF83706F76A9D53LL, RangeException);
      break;
    case 94:
      HASH_CREATE_OBJECT_ONLY(0x7754323897E8A15ELL, DirectoryIterator);
      break;
    case 97:
      HASH_CREATE_OBJECT_ONLY(0x70EBB2CC1FBF9761LL, DOMDocumentType);
      break;
    case 98:
      HASH_CREATE_OBJECT_ONLY(0x70747A09B3523662LL, DOMNode);
      break;
    case 99:
      HASH_CREATE_OBJECT_ONLY(0x7D1235273F521A63LL, DebuggerClient);
      break;
    case 101:
      HASH_CREATE_OBJECT_ONLY(0x2FF1EF6EBB3DA065LL, XMLWriter);
      break;
    case 104:
      HASH_CREATE_OBJECT_ONLY(0x7E07B9C27FE59D68LL, DOMComment);
      HASH_CREATE_OBJECT_ONLY(0x17A40D895C55D968LL, SoapParam);
      break;
    case 106:
      HASH_CREATE_OBJECT_ONLY(0x6A5B99D5B1A4566ALL, DOMException);
      break;
    case 107:
      HASH_CREATE_OBJECT_ONLY(0x3CAE91CFA2AAD16BLL, LengthException);
      break;
    case 115:
      HASH_CREATE_OBJECT_ONLY(0x3D5870E53BF89873LL, ArrayIterator);
      HASH_CREATE_OBJECT_ONLY(0x0B61E0BFCFA06573LL, ReflectionExtension);
      break;
    case 117:
      HASH_CREATE_OBJECT_ONLY(0x085A4F6FD393D475LL, InvalidArgumentException);
      break;
    case 122:
      HASH_CREATE_OBJECT_ONLY(0x41A9F7D81254DD7ALL, ReflectionObject);
      break;
    case 125:
      HASH_CREATE_OBJECT_ONLY(0x7AD161197633B87DLL, DOMDocumentFragment);
      HASH_CREATE_OBJECT_ONLY(0x2E899D2A2572EF7DLL, SQLite3Result);
      break;
    case 128:
      HASH_CREATE_OBJECT_ONLY(0x59B3EFD1CD987F80LL, DOMProcessingInstruction);
      break;
    case 130:
      HASH_CREATE_OBJECT_ONLY(0x33BD46E935281082LL, ReflectionFunctionAbstract);
      break;
    case 131:
      HASH_CREATE_OBJECT_ONLY(0x24DE53FD7D3E8383LL, DateTimeZone);
      break;
    case 132:
      HASH_CREATE_OBJECT_ONLY(0x70D4A29DE6A7BA84LL, DomainException);
      break;
    case 143:
      HASH_CREATE_OBJECT_ONLY(0x34C95AF311506C8FLL, Directory);
      break;
    case 144:
      HASH_CREATE_OBJECT_ONLY(0x06335FF83CDEA590LL, BadMethodCallException);
      break;
    case 147:
      HASH_CREATE_OBJECT_ONLY(0x2E7081C468A05993LL, ReflectionParameter);
      break;
    case 148:
      HASH_CREATE_OBJECT_ONLY(0x6FFDF8DF15CABE94LL, DOMCDATASection);
      HASH_CREATE_OBJECT_ONLY(0x6576EACCCE24D694LL, __PHP_Incomplete_Class);
      HASH_CREATE_OBJECT_ONLY(0x47D93E6F80B66A94LL, Exception);
      break;
    case 167:
      HASH_CREATE_OBJECT_ONLY(0x71089C29FE923FA7LL, SplFileInfo);
      break;
    case 168:
      HASH_CREATE_OBJECT_ONLY(0x7D46DB2E09C6DBA8LL, DOMXPath);
      break;
    case 169:
      HASH_CREATE_OBJECT_ONLY(0x1D35C3EFD00E11A9LL, SQLite3);
      break;
    case 170:
      HASH_CREATE_OBJECT_ONLY(0x67E31D42F2DFE4AALL, Locale);
      break;
    case 173:
      HASH_CREATE_OBJECT_ONLY(0x0A34015F67C804ADLL, PDO);
      break;
    case 175:
      HASH_CREATE_OBJECT_ONLY(0x2E650138BA043AAFLL, DOMDocument);
      break;
    case 176:
      HASH_CREATE_OBJECT_ONLY(0x43BBC8F6F28E44B0LL, ReflectionMethod);
      break;
    case 177:
      HASH_CREATE_OBJECT_ONLY(0x6DD772FA3B20B8B1LL, DOMNodeList);
      break;
    case 189:
      HASH_CREATE_OBJECT_ONLY(0x5D8785ACD19F77BDLL, PDOException);
      break;
    case 195:
      HASH_CREATE_OBJECT_ONLY(0x40B3C44077F5DDC3LL, DOMElement);
      break;
    case 200:
      HASH_CREATE_OBJECT_ONLY(0x2E363D51549781C8LL, AppendIterator);
      break;
    case 203:
      HASH_CREATE_OBJECT_ONLY(0x253AC17234FC8CCBLL, LibXMLError);
      break;
    case 208:
      HASH_CREATE_OBJECT_ONLY(0x3C122DF8859C72D0LL, Memcache);
      break;
    case 210:
      HASH_CREATE_OBJECT_ONLY(0x52E5CC58B841AED2LL, SQLite3Stmt);
      HASH_CREATE_OBJECT_ONLY(0x297ECCC7A259EDD2LL, SplFileObject);
      break;
    case 212:
      HASH_CREATE_OBJECT_ONLY(0x5E623FEAF7B068D4LL, UnderflowException);
      break;
    case 216:
      HASH_CREATE_OBJECT_ONLY(0x464D3427431A6ED8LL, RecursiveDirectoryIterator);
      break;
    case 217:
      HASH_CREATE_OBJECT_ONLY(0x0E4CCE95F6A727D9LL, OverflowException);
      break;
    case 218:
      HASH_CREATE_OBJECT_ONLY(0x7A52EBE538182BDALL, SoapClient);
      break;
    case 220:
      HASH_CREATE_OBJECT_ONLY(0x1078CB3118A8B3DCLL, RuntimeException);
      break;
    case 228:
      HASH_CREATE_OBJECT_ONLY(0x75AA2571BDB659E4LL, ReflectionProperty);
      break;
    case 244:
      HASH_CREATE_OBJECT_ONLY(0x297174231D4912F4LL, DOMAttr);
      break;
    case 247:
      HASH_CREATE_OBJECT_ONLY(0x3D69936178BA13F7LL, stdClass);
      break;
    case 252:
      HASH_CREATE_OBJECT_ONLY(0x622D4DF07E2A01FCLL, OutOfRangeException);
      break;
    case 253:
      HASH_CREATE_OBJECT_ONLY(0x74419B70A46387FDLL, DOMImplementation);
      break;
    case 255:
      HASH_CREATE_OBJECT_ONLY(0x624835B2D74B86FFLL, DOMEntity);
      break;
    default:
      break;
  }
  return throw_missing_class(s);
}
bool get_call_info_static_method_builtin(MethodCallPackage &mcp) {
  const char *s __attribute__((__unused__)) (mcp.rootObj.getCStr());
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 8:
      HASH_CALL_INFO_STATIC_METHOD(0x4DA860E5647C3908LL, ImageSprite);
      break;
    case 9:
      HASH_CALL_INFO_STATIC_METHOD(0x21EF70351574EC09LL, ReflectionFunction);
      break;
    case 11:
      HASH_CALL_INFO_STATIC_METHOD(0x4365BE9E5A85E60BLL, DOMNotation);
      HASH_CALL_INFO_STATIC_METHOD(0x69EDCA1CC29CFE0BLL, ErrorException);
      break;
    case 18:
      HASH_CALL_INFO_STATIC_METHOD(0x78B42582709BAF12LL, DebuggerProxy);
      break;
    case 19:
      HASH_CALL_INFO_STATIC_METHOD(0x6A76B9AABB7CC713LL, SimpleXMLElement);
      break;
    case 21:
      HASH_CALL_INFO_STATIC_METHOD(0x32E5C767255D2515LL, SoapFault);
      break;
    case 26:
      HASH_CALL_INFO_STATIC_METHOD(0x5CBA5B52C68B501ALL, DOMEntityReference);
      break;
    case 29:
      HASH_CALL_INFO_STATIC_METHOD(0x35A44A5E6AE2E71DLL, ReflectionClass);
      break;
    case 30:
      HASH_CALL_INFO_STATIC_METHOD(0x3DB8FB455A602A1ELL, DateTime);
      break;
    case 43:
      HASH_CALL_INFO_STATIC_METHOD(0x7E66D362EAB5BF2BLL, SimpleXMLElementIterator);
      break;
    case 49:
      HASH_CALL_INFO_STATIC_METHOD(0x7A394042E7488231LL, FilterIterator);
      break;
    case 50:
      HASH_CALL_INFO_STATIC_METHOD(0x365899865E2EAA32LL, RecursiveIteratorIterator);
      break;
    case 53:
      HASH_CALL_INFO_STATIC_METHOD(0x7909270014376235LL, SoapVar);
      break;
    case 55:
      HASH_CALL_INFO_STATIC_METHOD(0x7FF7A8442616EF37LL, DOMNodeIterator);
      break;
    case 56:
      HASH_CALL_INFO_STATIC_METHOD(0x672AD818DDE95538LL, ReflectionException);
      break;
    case 61:
      HASH_CALL_INFO_STATIC_METHOD(0x4C6991D3CF5CA03DLL, Collator);
      break;
    case 62:
      HASH_CALL_INFO_STATIC_METHOD(0x49FC1A1F7B878C3ELL, SoapServer);
      break;
    case 65:
      HASH_CALL_INFO_STATIC_METHOD(0x227C70ED5B143841LL, OutOfBoundsException);
      break;
    case 68:
      HASH_CALL_INFO_STATIC_METHOD(0x4253D8488B734244LL, PDOStatement);
      break;
    case 70:
      HASH_CALL_INFO_STATIC_METHOD(0x196F76C9C527B946LL, DOMNamedNodeMap);
      HASH_CALL_INFO_STATIC_METHOD(0x66282FC8E4EF4E46LL, BadFunctionCallException);
      break;
    case 73:
      HASH_CALL_INFO_STATIC_METHOD(0x5AA2EE582E0D3849LL, UnexpectedValueException);
      break;
    case 75:
      HASH_CALL_INFO_STATIC_METHOD(0x4860DC2F9B0E6D4BLL, LogicException);
      break;
    case 77:
      HASH_CALL_INFO_STATIC_METHOD(0x164F490DAC49174DLL, DOMText);
      break;
    case 78:
      HASH_CALL_INFO_STATIC_METHOD(0x308D1D59986A3D4ELL, SoapHeader);
      break;
    case 79:
      HASH_CALL_INFO_STATIC_METHOD(0x5BA243B9FBA7A64FLL, SplObjectStorage);
      break;
    case 80:
      HASH_CALL_INFO_STATIC_METHOD(0x52EA111229F87A50LL, Normalizer);
      break;
    case 83:
      HASH_CALL_INFO_STATIC_METHOD(0x02239AA5D64B1453LL, DOMCharacterData);
      HASH_CALL_INFO_STATIC_METHOD(0x6AF83706F76A9D53LL, RangeException);
      break;
    case 94:
      HASH_CALL_INFO_STATIC_METHOD(0x7754323897E8A15ELL, DirectoryIterator);
      break;
    case 97:
      HASH_CALL_INFO_STATIC_METHOD(0x70EBB2CC1FBF9761LL, DOMDocumentType);
      break;
    case 98:
      HASH_CALL_INFO_STATIC_METHOD(0x70747A09B3523662LL, DOMNode);
      break;
    case 99:
      HASH_CALL_INFO_STATIC_METHOD(0x7D1235273F521A63LL, DebuggerClient);
      break;
    case 101:
      HASH_CALL_INFO_STATIC_METHOD(0x2FF1EF6EBB3DA065LL, XMLWriter);
      break;
    case 104:
      HASH_CALL_INFO_STATIC_METHOD(0x7E07B9C27FE59D68LL, DOMComment);
      HASH_CALL_INFO_STATIC_METHOD(0x17A40D895C55D968LL, SoapParam);
      break;
    case 106:
      HASH_CALL_INFO_STATIC_METHOD(0x6A5B99D5B1A4566ALL, DOMException);
      break;
    case 107:
      HASH_CALL_INFO_STATIC_METHOD(0x3CAE91CFA2AAD16BLL, LengthException);
      break;
    case 115:
      HASH_CALL_INFO_STATIC_METHOD(0x3D5870E53BF89873LL, ArrayIterator);
      HASH_CALL_INFO_STATIC_METHOD(0x0B61E0BFCFA06573LL, ReflectionExtension);
      break;
    case 117:
      HASH_CALL_INFO_STATIC_METHOD(0x085A4F6FD393D475LL, InvalidArgumentException);
      break;
    case 122:
      HASH_CALL_INFO_STATIC_METHOD(0x41A9F7D81254DD7ALL, ReflectionObject);
      break;
    case 125:
      HASH_CALL_INFO_STATIC_METHOD(0x7AD161197633B87DLL, DOMDocumentFragment);
      HASH_CALL_INFO_STATIC_METHOD(0x2E899D2A2572EF7DLL, SQLite3Result);
      break;
    case 128:
      HASH_CALL_INFO_STATIC_METHOD(0x59B3EFD1CD987F80LL, DOMProcessingInstruction);
      break;
    case 130:
      HASH_CALL_INFO_STATIC_METHOD(0x33BD46E935281082LL, ReflectionFunctionAbstract);
      break;
    case 131:
      HASH_CALL_INFO_STATIC_METHOD(0x24DE53FD7D3E8383LL, DateTimeZone);
      break;
    case 132:
      HASH_CALL_INFO_STATIC_METHOD(0x70D4A29DE6A7BA84LL, DomainException);
      break;
    case 143:
      HASH_CALL_INFO_STATIC_METHOD(0x34C95AF311506C8FLL, Directory);
      break;
    case 144:
      HASH_CALL_INFO_STATIC_METHOD(0x06335FF83CDEA590LL, BadMethodCallException);
      break;
    case 147:
      HASH_CALL_INFO_STATIC_METHOD(0x2E7081C468A05993LL, ReflectionParameter);
      break;
    case 148:
      HASH_CALL_INFO_STATIC_METHOD(0x6FFDF8DF15CABE94LL, DOMCDATASection);
      HASH_CALL_INFO_STATIC_METHOD(0x6576EACCCE24D694LL, __PHP_Incomplete_Class);
      HASH_CALL_INFO_STATIC_METHOD(0x47D93E6F80B66A94LL, Exception);
      break;
    case 167:
      HASH_CALL_INFO_STATIC_METHOD(0x71089C29FE923FA7LL, SplFileInfo);
      break;
    case 168:
      HASH_CALL_INFO_STATIC_METHOD(0x7D46DB2E09C6DBA8LL, DOMXPath);
      break;
    case 169:
      HASH_CALL_INFO_STATIC_METHOD(0x1D35C3EFD00E11A9LL, SQLite3);
      break;
    case 170:
      HASH_CALL_INFO_STATIC_METHOD(0x67E31D42F2DFE4AALL, Locale);
      break;
    case 173:
      HASH_CALL_INFO_STATIC_METHOD(0x0A34015F67C804ADLL, PDO);
      break;
    case 175:
      HASH_CALL_INFO_STATIC_METHOD(0x2E650138BA043AAFLL, DOMDocument);
      break;
    case 176:
      HASH_CALL_INFO_STATIC_METHOD(0x43BBC8F6F28E44B0LL, ReflectionMethod);
      break;
    case 177:
      HASH_CALL_INFO_STATIC_METHOD(0x6DD772FA3B20B8B1LL, DOMNodeList);
      break;
    case 189:
      HASH_CALL_INFO_STATIC_METHOD(0x5D8785ACD19F77BDLL, PDOException);
      break;
    case 195:
      HASH_CALL_INFO_STATIC_METHOD(0x40B3C44077F5DDC3LL, DOMElement);
      break;
    case 200:
      HASH_CALL_INFO_STATIC_METHOD(0x2E363D51549781C8LL, AppendIterator);
      break;
    case 203:
      HASH_CALL_INFO_STATIC_METHOD(0x253AC17234FC8CCBLL, LibXMLError);
      break;
    case 208:
      HASH_CALL_INFO_STATIC_METHOD(0x3C122DF8859C72D0LL, Memcache);
      break;
    case 210:
      HASH_CALL_INFO_STATIC_METHOD(0x52E5CC58B841AED2LL, SQLite3Stmt);
      HASH_CALL_INFO_STATIC_METHOD(0x297ECCC7A259EDD2LL, SplFileObject);
      break;
    case 212:
      HASH_CALL_INFO_STATIC_METHOD(0x5E623FEAF7B068D4LL, UnderflowException);
      break;
    case 216:
      HASH_CALL_INFO_STATIC_METHOD(0x464D3427431A6ED8LL, RecursiveDirectoryIterator);
      break;
    case 217:
      HASH_CALL_INFO_STATIC_METHOD(0x0E4CCE95F6A727D9LL, OverflowException);
      break;
    case 218:
      HASH_CALL_INFO_STATIC_METHOD(0x7A52EBE538182BDALL, SoapClient);
      break;
    case 220:
      HASH_CALL_INFO_STATIC_METHOD(0x1078CB3118A8B3DCLL, RuntimeException);
      break;
    case 228:
      HASH_CALL_INFO_STATIC_METHOD(0x75AA2571BDB659E4LL, ReflectionProperty);
      break;
    case 244:
      HASH_CALL_INFO_STATIC_METHOD(0x297174231D4912F4LL, DOMAttr);
      break;
    case 247:
      HASH_CALL_INFO_STATIC_METHOD(0x3D69936178BA13F7LL, stdClass);
      break;
    case 252:
      HASH_CALL_INFO_STATIC_METHOD(0x622D4DF07E2A01FCLL, OutOfRangeException);
      break;
    case 253:
      HASH_CALL_INFO_STATIC_METHOD(0x74419B70A46387FDLL, DOMImplementation);
      break;
    case 255:
      HASH_CALL_INFO_STATIC_METHOD(0x624835B2D74B86FFLL, DOMEntity);
      break;
    default:
      break;
  }
  mcp.fail();
  return false;
}
bool get_call_info_static_method_with_index_builtin(MethodCallPackage &mcp, MethodIndex mi) {
  return get_call_info_static_method_builtin(mcp);
}
const ObjectStaticCallbacks * get_builtin_object_static_callbacks(const char *s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 8:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4DA860E5647C3908LL, ImageSprite);
      break;
    case 9:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x21EF70351574EC09LL, ReflectionFunction);
      break;
    case 11:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4365BE9E5A85E60BLL, DOMNotation);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x69EDCA1CC29CFE0BLL, ErrorException);
      break;
    case 18:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x78B42582709BAF12LL, DebuggerProxy);
      break;
    case 19:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6A76B9AABB7CC713LL, SimpleXMLElement);
      break;
    case 21:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x32E5C767255D2515LL, SoapFault);
      break;
    case 26:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5CBA5B52C68B501ALL, DOMEntityReference);
      break;
    case 29:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x35A44A5E6AE2E71DLL, ReflectionClass);
      break;
    case 30:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3DB8FB455A602A1ELL, DateTime);
      break;
    case 43:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7E66D362EAB5BF2BLL, SimpleXMLElementIterator);
      break;
    case 49:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7A394042E7488231LL, FilterIterator);
      break;
    case 50:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x365899865E2EAA32LL, RecursiveIteratorIterator);
      break;
    case 53:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7909270014376235LL, SoapVar);
      break;
    case 55:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7FF7A8442616EF37LL, DOMNodeIterator);
      break;
    case 56:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x672AD818DDE95538LL, ReflectionException);
      break;
    case 61:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4C6991D3CF5CA03DLL, Collator);
      break;
    case 62:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x49FC1A1F7B878C3ELL, SoapServer);
      break;
    case 65:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x227C70ED5B143841LL, OutOfBoundsException);
      break;
    case 68:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4253D8488B734244LL, PDOStatement);
      break;
    case 70:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x196F76C9C527B946LL, DOMNamedNodeMap);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x66282FC8E4EF4E46LL, BadFunctionCallException);
      break;
    case 73:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5AA2EE582E0D3849LL, UnexpectedValueException);
      break;
    case 75:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4860DC2F9B0E6D4BLL, LogicException);
      break;
    case 77:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x164F490DAC49174DLL, DOMText);
      break;
    case 78:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x308D1D59986A3D4ELL, SoapHeader);
      break;
    case 79:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5BA243B9FBA7A64FLL, SplObjectStorage);
      break;
    case 80:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x52EA111229F87A50LL, Normalizer);
      break;
    case 83:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x02239AA5D64B1453LL, DOMCharacterData);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6AF83706F76A9D53LL, RangeException);
      break;
    case 94:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7754323897E8A15ELL, DirectoryIterator);
      break;
    case 97:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x70EBB2CC1FBF9761LL, DOMDocumentType);
      break;
    case 98:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x70747A09B3523662LL, DOMNode);
      break;
    case 99:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7D1235273F521A63LL, DebuggerClient);
      break;
    case 101:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2FF1EF6EBB3DA065LL, XMLWriter);
      break;
    case 104:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7E07B9C27FE59D68LL, DOMComment);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x17A40D895C55D968LL, SoapParam);
      break;
    case 106:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6A5B99D5B1A4566ALL, DOMException);
      break;
    case 107:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3CAE91CFA2AAD16BLL, LengthException);
      break;
    case 115:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3D5870E53BF89873LL, ArrayIterator);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x0B61E0BFCFA06573LL, ReflectionExtension);
      break;
    case 117:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x085A4F6FD393D475LL, InvalidArgumentException);
      break;
    case 122:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x41A9F7D81254DD7ALL, ReflectionObject);
      break;
    case 125:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7AD161197633B87DLL, DOMDocumentFragment);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E899D2A2572EF7DLL, SQLite3Result);
      break;
    case 128:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x59B3EFD1CD987F80LL, DOMProcessingInstruction);
      break;
    case 130:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x33BD46E935281082LL, ReflectionFunctionAbstract);
      break;
    case 131:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x24DE53FD7D3E8383LL, DateTimeZone);
      break;
    case 132:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x70D4A29DE6A7BA84LL, DomainException);
      break;
    case 143:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x34C95AF311506C8FLL, Directory);
      break;
    case 144:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x06335FF83CDEA590LL, BadMethodCallException);
      break;
    case 147:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E7081C468A05993LL, ReflectionParameter);
      break;
    case 148:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6FFDF8DF15CABE94LL, DOMCDATASection);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6576EACCCE24D694LL, __PHP_Incomplete_Class);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x47D93E6F80B66A94LL, Exception);
      break;
    case 167:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x71089C29FE923FA7LL, SplFileInfo);
      break;
    case 168:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7D46DB2E09C6DBA8LL, DOMXPath);
      break;
    case 169:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x1D35C3EFD00E11A9LL, SQLite3);
      break;
    case 170:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x67E31D42F2DFE4AALL, Locale);
      break;
    case 173:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x0A34015F67C804ADLL, PDO);
      break;
    case 175:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E650138BA043AAFLL, DOMDocument);
      break;
    case 176:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x43BBC8F6F28E44B0LL, ReflectionMethod);
      break;
    case 177:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6DD772FA3B20B8B1LL, DOMNodeList);
      break;
    case 189:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5D8785ACD19F77BDLL, PDOException);
      break;
    case 195:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x40B3C44077F5DDC3LL, DOMElement);
      break;
    case 200:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E363D51549781C8LL, AppendIterator);
      break;
    case 203:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x253AC17234FC8CCBLL, LibXMLError);
      break;
    case 208:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3C122DF8859C72D0LL, Memcache);
      break;
    case 210:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x52E5CC58B841AED2LL, SQLite3Stmt);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x297ECCC7A259EDD2LL, SplFileObject);
      break;
    case 212:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5E623FEAF7B068D4LL, UnderflowException);
      break;
    case 216:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x464D3427431A6ED8LL, RecursiveDirectoryIterator);
      break;
    case 217:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x0E4CCE95F6A727D9LL, OverflowException);
      break;
    case 218:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7A52EBE538182BDALL, SoapClient);
      break;
    case 220:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x1078CB3118A8B3DCLL, RuntimeException);
      break;
    case 228:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x75AA2571BDB659E4LL, ReflectionProperty);
      break;
    case 244:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x297174231D4912F4LL, DOMAttr);
      break;
    case 247:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3D69936178BA13F7LL, stdClass);
      break;
    case 252:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x622D4DF07E2A01FCLL, OutOfRangeException);
      break;
    case 253:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x74419B70A46387FDLL, DOMImplementation);
      break;
    case 255:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x624835B2D74B86FFLL, DOMEntity);
      break;
    default:
      break;
  }
  return NULL;
}
Variant get_builtin_static_property(const char *s, const char *prop) {
  {
    const ObjectStaticCallbacks * cwo = get_builtin_object_static_callbacks(s);
    if (cwo) return cwo->os_get(prop);
  }
  return null;
}
Variant *get_builtin_static_property_lv(const char *s, const char *prop) {
  {
    const ObjectStaticCallbacks * cwo = get_builtin_object_static_callbacks(s);
    if (cwo) return &cwo->os_lval(prop);
  }
  return NULL;
}
Variant get_builtin_class_constant(const char *s, const char *constant, bool fatal /* = true */) {
  {
    const ObjectStaticCallbacks * cwo = get_builtin_object_static_callbacks(s);
    if (cwo) return cwo->os_constant(constant);
  }
  if (fatal) {
    raise_error("Couldn't find constant %s::%s", s, constant);
  } else {
    raise_warning("Couldn't find constant %s::%s", s, constant);
  }
  return null;
}

///////////////////////////////////////////////////////////////////////////////
}
