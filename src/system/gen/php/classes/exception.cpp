/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010 Facebook, Inc. (http://www.facebook.com)          |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
// @generated by HipHop Compiler

#include <php/classes/exception.h>
#include <runtime/ext/ext.h>
#include <runtime/eval/eval.h>

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////

/* preface starts */
/* preface finishes */
/* SRC: classes/exception.php line 103 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_unexpectedvalueexception
Variant c_unexpectedvalueexception::os_getInit(const char *s, int64 hash) {
  return c_runtimeexception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_unexpectedvalueexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_unexpectedvalueexception
Variant c_unexpectedvalueexception::os_get(const char *s, int64 hash) {
  return c_runtimeexception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_unexpectedvalueexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_unexpectedvalueexception
Variant &c_unexpectedvalueexception::os_lval(const char *s, int64 hash) {
  return c_runtimeexception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_unexpectedvalueexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_unexpectedvalueexception
void c_unexpectedvalueexception::o_getArray(Array &props) const {
  c_runtimeexception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_unexpectedvalueexception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_unexpectedvalueexception
void c_unexpectedvalueexception::o_setArray(CArrRef props) {
  c_runtimeexception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_unexpectedvalueexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_unexpectedvalueexception
Variant c_unexpectedvalueexception::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_unexpectedvalueexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_unexpectedvalueexception
Variant c_unexpectedvalueexception::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_runtimeexception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_unexpectedvalueexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_unexpectedvalueexception
Variant c_unexpectedvalueexception::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_unexpectedvalueexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_unexpectedvalueexception
bool c_unexpectedvalueexception::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_unexpectedvalueexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_unexpectedvalueexception
bool c_unexpectedvalueexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_runtimeexception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_unexpectedvalueexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_unexpectedvalueexception
bool c_unexpectedvalueexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_unexpectedvalueexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_unexpectedvalueexception
Variant c_unexpectedvalueexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_unexpectedvalueexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_unexpectedvalueexception
Variant c_unexpectedvalueexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_runtimeexception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_unexpectedvalueexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_unexpectedvalueexception
Variant c_unexpectedvalueexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_unexpectedvalueexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_unexpectedvalueexception
Variant& c_unexpectedvalueexception::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_unexpectedvalueexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_unexpectedvalueexception
Variant& c_unexpectedvalueexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_runtimeexception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_unexpectedvalueexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_unexpectedvalueexception
Variant& c_unexpectedvalueexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_unexpectedvalueexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_unexpectedvalueexception
Variant c_unexpectedvalueexception::os_constant(const char *s) {
  return c_runtimeexception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_unexpectedvalueexception
IMPLEMENT_CLASS(unexpectedvalueexception)
ObjectData *c_unexpectedvalueexception::cloneImpl() {
  c_unexpectedvalueexception *obj = NEW(c_unexpectedvalueexception)();
  cloneSet(obj);
  return obj;
}
void c_unexpectedvalueexception::cloneSet(c_unexpectedvalueexception *clone) {
  c_runtimeexception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_unexpectedvalueexception
Variant c_unexpectedvalueexception::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_unexpectedvalueexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_unexpectedvalueexception
Variant c_unexpectedvalueexception::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_unexpectedvalueexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_unexpectedvalueexception
Variant c_unexpectedvalueexception::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_unexpectedvalueexception
Variant c_unexpectedvalueexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_runtimeexception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_unexpectedvalueexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_runtimeexception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_unexpectedvalueexception = {
  c_unexpectedvalueexception::os_getInit,
  c_unexpectedvalueexception::os_get,
  c_unexpectedvalueexception::os_lval,
  c_unexpectedvalueexception::os_invoke,
  c_unexpectedvalueexception::os_constant,
};
void c_unexpectedvalueexception::init() {
  c_runtimeexception::init();
}
/* SRC: classes/exception.php line 100 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_overflowexception
Variant c_overflowexception::os_getInit(const char *s, int64 hash) {
  return c_runtimeexception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_overflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_overflowexception
Variant c_overflowexception::os_get(const char *s, int64 hash) {
  return c_runtimeexception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_overflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_overflowexception
Variant &c_overflowexception::os_lval(const char *s, int64 hash) {
  return c_runtimeexception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_overflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_overflowexception
void c_overflowexception::o_getArray(Array &props) const {
  c_runtimeexception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_overflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_overflowexception
void c_overflowexception::o_setArray(CArrRef props) {
  c_runtimeexception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_overflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_overflowexception
Variant c_overflowexception::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_overflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_overflowexception
Variant c_overflowexception::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_runtimeexception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_overflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_overflowexception
Variant c_overflowexception::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_overflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_overflowexception
bool c_overflowexception::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_overflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_overflowexception
bool c_overflowexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_runtimeexception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_overflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_overflowexception
bool c_overflowexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_overflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_overflowexception
Variant c_overflowexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_overflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_overflowexception
Variant c_overflowexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_runtimeexception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_overflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_overflowexception
Variant c_overflowexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_overflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_overflowexception
Variant& c_overflowexception::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_overflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_overflowexception
Variant& c_overflowexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_runtimeexception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_overflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_overflowexception
Variant& c_overflowexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_overflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_overflowexception
Variant c_overflowexception::os_constant(const char *s) {
  return c_runtimeexception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_overflowexception
IMPLEMENT_CLASS(overflowexception)
ObjectData *c_overflowexception::cloneImpl() {
  c_overflowexception *obj = NEW(c_overflowexception)();
  cloneSet(obj);
  return obj;
}
void c_overflowexception::cloneSet(c_overflowexception *clone) {
  c_runtimeexception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_overflowexception
Variant c_overflowexception::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_overflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_overflowexception
Variant c_overflowexception::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_overflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_overflowexception
Variant c_overflowexception::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_overflowexception
Variant c_overflowexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_runtimeexception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_overflowexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_runtimeexception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_overflowexception = {
  c_overflowexception::os_getInit,
  c_overflowexception::os_get,
  c_overflowexception::os_lval,
  c_overflowexception::os_invoke,
  c_overflowexception::os_constant,
};
void c_overflowexception::init() {
  c_runtimeexception::init();
}
/* SRC: classes/exception.php line 99 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_outofboundsexception
Variant c_outofboundsexception::os_getInit(const char *s, int64 hash) {
  return c_runtimeexception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_outofboundsexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_outofboundsexception
Variant c_outofboundsexception::os_get(const char *s, int64 hash) {
  return c_runtimeexception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_outofboundsexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_outofboundsexception
Variant &c_outofboundsexception::os_lval(const char *s, int64 hash) {
  return c_runtimeexception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_outofboundsexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_outofboundsexception
void c_outofboundsexception::o_getArray(Array &props) const {
  c_runtimeexception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_outofboundsexception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_outofboundsexception
void c_outofboundsexception::o_setArray(CArrRef props) {
  c_runtimeexception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_outofboundsexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_outofboundsexception
Variant c_outofboundsexception::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_outofboundsexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_outofboundsexception
Variant c_outofboundsexception::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_runtimeexception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_outofboundsexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_outofboundsexception
Variant c_outofboundsexception::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_outofboundsexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_outofboundsexception
bool c_outofboundsexception::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_outofboundsexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_outofboundsexception
bool c_outofboundsexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_runtimeexception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_outofboundsexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_outofboundsexception
bool c_outofboundsexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_outofboundsexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_outofboundsexception
Variant c_outofboundsexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_outofboundsexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_outofboundsexception
Variant c_outofboundsexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_runtimeexception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_outofboundsexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_outofboundsexception
Variant c_outofboundsexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_outofboundsexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_outofboundsexception
Variant& c_outofboundsexception::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_outofboundsexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_outofboundsexception
Variant& c_outofboundsexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_runtimeexception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_outofboundsexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_outofboundsexception
Variant& c_outofboundsexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_outofboundsexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_outofboundsexception
Variant c_outofboundsexception::os_constant(const char *s) {
  return c_runtimeexception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_outofboundsexception
IMPLEMENT_CLASS(outofboundsexception)
ObjectData *c_outofboundsexception::cloneImpl() {
  c_outofboundsexception *obj = NEW(c_outofboundsexception)();
  cloneSet(obj);
  return obj;
}
void c_outofboundsexception::cloneSet(c_outofboundsexception *clone) {
  c_runtimeexception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_outofboundsexception
Variant c_outofboundsexception::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_outofboundsexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_outofboundsexception
Variant c_outofboundsexception::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_outofboundsexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_outofboundsexception
Variant c_outofboundsexception::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_outofboundsexception
Variant c_outofboundsexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_runtimeexception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_outofboundsexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_runtimeexception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_outofboundsexception = {
  c_outofboundsexception::os_getInit,
  c_outofboundsexception::os_get,
  c_outofboundsexception::os_lval,
  c_outofboundsexception::os_invoke,
  c_outofboundsexception::os_constant,
};
void c_outofboundsexception::init() {
  c_runtimeexception::init();
}
/* SRC: classes/exception.php line 91 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_logicexception
Variant c_logicexception::os_getInit(const char *s, int64 hash) {
  return c_exception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_logicexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_logicexception
Variant c_logicexception::os_get(const char *s, int64 hash) {
  return c_exception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_logicexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_logicexception
Variant &c_logicexception::os_lval(const char *s, int64 hash) {
  return c_exception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_logicexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_logicexception
void c_logicexception::o_getArray(Array &props) const {
  c_exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_logicexception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_logicexception
void c_logicexception::o_setArray(CArrRef props) {
  c_exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_logicexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_logicexception
Variant c_logicexception::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_logicexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_logicexception
Variant c_logicexception::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_exception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_logicexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_logicexception
Variant c_logicexception::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_logicexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_logicexception
bool c_logicexception::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_logicexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_logicexception
bool c_logicexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_exception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_logicexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_logicexception
bool c_logicexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_logicexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_logicexception
Variant c_logicexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_logicexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_logicexception
Variant c_logicexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_exception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_logicexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_logicexception
Variant c_logicexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_logicexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_logicexception
Variant& c_logicexception::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_logicexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_logicexception
Variant& c_logicexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_exception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_logicexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_logicexception
Variant& c_logicexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_logicexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_logicexception
Variant c_logicexception::os_constant(const char *s) {
  return c_exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_logicexception
IMPLEMENT_CLASS(logicexception)
ObjectData *c_logicexception::cloneImpl() {
  c_logicexception *obj = NEW(c_logicexception)();
  cloneSet(obj);
  return obj;
}
void c_logicexception::cloneSet(c_logicexception *clone) {
  c_exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_logicexception
Variant c_logicexception::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_logicexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_logicexception
Variant c_logicexception::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_logicexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_logicexception
Variant c_logicexception::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_logicexception
Variant c_logicexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_logicexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_logicexception = {
  c_logicexception::os_getInit,
  c_logicexception::os_get,
  c_logicexception::os_lval,
  c_logicexception::os_invoke,
  c_logicexception::os_constant,
};
void c_logicexception::init() {
  c_exception::init();
}
/* SRC: classes/exception.php line 101 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_rangeexception
Variant c_rangeexception::os_getInit(const char *s, int64 hash) {
  return c_runtimeexception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_rangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_rangeexception
Variant c_rangeexception::os_get(const char *s, int64 hash) {
  return c_runtimeexception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_rangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_rangeexception
Variant &c_rangeexception::os_lval(const char *s, int64 hash) {
  return c_runtimeexception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_rangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_rangeexception
void c_rangeexception::o_getArray(Array &props) const {
  c_runtimeexception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_rangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_rangeexception
void c_rangeexception::o_setArray(CArrRef props) {
  c_runtimeexception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_rangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_rangeexception
Variant c_rangeexception::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_rangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_rangeexception
Variant c_rangeexception::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_runtimeexception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_rangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_rangeexception
Variant c_rangeexception::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_rangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_rangeexception
bool c_rangeexception::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_rangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_rangeexception
bool c_rangeexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_runtimeexception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_rangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_rangeexception
bool c_rangeexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_rangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_rangeexception
Variant c_rangeexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_rangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_rangeexception
Variant c_rangeexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_runtimeexception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_rangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_rangeexception
Variant c_rangeexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_rangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_rangeexception
Variant& c_rangeexception::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_rangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_rangeexception
Variant& c_rangeexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_runtimeexception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_rangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_rangeexception
Variant& c_rangeexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_rangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_rangeexception
Variant c_rangeexception::os_constant(const char *s) {
  return c_runtimeexception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_rangeexception
IMPLEMENT_CLASS(rangeexception)
ObjectData *c_rangeexception::cloneImpl() {
  c_rangeexception *obj = NEW(c_rangeexception)();
  cloneSet(obj);
  return obj;
}
void c_rangeexception::cloneSet(c_rangeexception *clone) {
  c_runtimeexception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_rangeexception
Variant c_rangeexception::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_rangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_rangeexception
Variant c_rangeexception::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_rangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_rangeexception
Variant c_rangeexception::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_rangeexception
Variant c_rangeexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_runtimeexception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_rangeexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_runtimeexception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_rangeexception = {
  c_rangeexception::os_getInit,
  c_rangeexception::os_get,
  c_rangeexception::os_lval,
  c_rangeexception::os_invoke,
  c_rangeexception::os_constant,
};
void c_rangeexception::init() {
  c_runtimeexception::init();
}
/* SRC: classes/exception.php line 95 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_invalidargumentexception
Variant c_invalidargumentexception::os_getInit(const char *s, int64 hash) {
  return c_logicexception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_invalidargumentexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_invalidargumentexception
Variant c_invalidargumentexception::os_get(const char *s, int64 hash) {
  return c_logicexception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_invalidargumentexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_invalidargumentexception
Variant &c_invalidargumentexception::os_lval(const char *s, int64 hash) {
  return c_logicexception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_invalidargumentexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_invalidargumentexception
void c_invalidargumentexception::o_getArray(Array &props) const {
  c_logicexception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_invalidargumentexception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_invalidargumentexception
void c_invalidargumentexception::o_setArray(CArrRef props) {
  c_logicexception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_invalidargumentexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_invalidargumentexception
Variant c_invalidargumentexception::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_invalidargumentexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_invalidargumentexception
Variant c_invalidargumentexception::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_logicexception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_invalidargumentexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_invalidargumentexception
Variant c_invalidargumentexception::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_invalidargumentexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_invalidargumentexception
bool c_invalidargumentexception::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_invalidargumentexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_invalidargumentexception
bool c_invalidargumentexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_logicexception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_invalidargumentexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_invalidargumentexception
bool c_invalidargumentexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_invalidargumentexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_invalidargumentexception
Variant c_invalidargumentexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_invalidargumentexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_invalidargumentexception
Variant c_invalidargumentexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_logicexception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_invalidargumentexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_invalidargumentexception
Variant c_invalidargumentexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_invalidargumentexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_invalidargumentexception
Variant& c_invalidargumentexception::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_invalidargumentexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_invalidargumentexception
Variant& c_invalidargumentexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_logicexception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_invalidargumentexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_invalidargumentexception
Variant& c_invalidargumentexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_invalidargumentexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_invalidargumentexception
Variant c_invalidargumentexception::os_constant(const char *s) {
  return c_logicexception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_invalidargumentexception
IMPLEMENT_CLASS(invalidargumentexception)
ObjectData *c_invalidargumentexception::cloneImpl() {
  c_invalidargumentexception *obj = NEW(c_invalidargumentexception)();
  cloneSet(obj);
  return obj;
}
void c_invalidargumentexception::cloneSet(c_invalidargumentexception *clone) {
  c_logicexception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_invalidargumentexception
Variant c_invalidargumentexception::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_invalidargumentexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_invalidargumentexception
Variant c_invalidargumentexception::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_invalidargumentexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_invalidargumentexception
Variant c_invalidargumentexception::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_invalidargumentexception
Variant c_invalidargumentexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_logicexception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_invalidargumentexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_logicexception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_invalidargumentexception = {
  c_invalidargumentexception::os_getInit,
  c_invalidargumentexception::os_get,
  c_invalidargumentexception::os_lval,
  c_invalidargumentexception::os_invoke,
  c_invalidargumentexception::os_constant,
};
void c_invalidargumentexception::init() {
  c_logicexception::init();
}
/* SRC: classes/exception.php line 102 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_underflowexception
Variant c_underflowexception::os_getInit(const char *s, int64 hash) {
  return c_runtimeexception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_underflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_underflowexception
Variant c_underflowexception::os_get(const char *s, int64 hash) {
  return c_runtimeexception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_underflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_underflowexception
Variant &c_underflowexception::os_lval(const char *s, int64 hash) {
  return c_runtimeexception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_underflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_underflowexception
void c_underflowexception::o_getArray(Array &props) const {
  c_runtimeexception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_underflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_underflowexception
void c_underflowexception::o_setArray(CArrRef props) {
  c_runtimeexception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_underflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_underflowexception
Variant c_underflowexception::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_underflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_underflowexception
Variant c_underflowexception::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_runtimeexception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_underflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_underflowexception
Variant c_underflowexception::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_underflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_underflowexception
bool c_underflowexception::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_underflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_underflowexception
bool c_underflowexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_runtimeexception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_underflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_underflowexception
bool c_underflowexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_underflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_underflowexception
Variant c_underflowexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_underflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_underflowexception
Variant c_underflowexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_runtimeexception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_underflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_underflowexception
Variant c_underflowexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_underflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_underflowexception
Variant& c_underflowexception::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_underflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_underflowexception
Variant& c_underflowexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_runtimeexception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_underflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_underflowexception
Variant& c_underflowexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_underflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_underflowexception
Variant c_underflowexception::os_constant(const char *s) {
  return c_runtimeexception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_underflowexception
IMPLEMENT_CLASS(underflowexception)
ObjectData *c_underflowexception::cloneImpl() {
  c_underflowexception *obj = NEW(c_underflowexception)();
  cloneSet(obj);
  return obj;
}
void c_underflowexception::cloneSet(c_underflowexception *clone) {
  c_runtimeexception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_underflowexception
Variant c_underflowexception::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_underflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_underflowexception
Variant c_underflowexception::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_underflowexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_underflowexception
Variant c_underflowexception::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_underflowexception
Variant c_underflowexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_runtimeexception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_underflowexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_runtimeexception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_underflowexception = {
  c_underflowexception::os_getInit,
  c_underflowexception::os_get,
  c_underflowexception::os_lval,
  c_underflowexception::os_invoke,
  c_underflowexception::os_constant,
};
void c_underflowexception::init() {
  c_runtimeexception::init();
}
/* SRC: classes/exception.php line 97 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_outofrangeexception
Variant c_outofrangeexception::os_getInit(const char *s, int64 hash) {
  return c_logicexception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_outofrangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_outofrangeexception
Variant c_outofrangeexception::os_get(const char *s, int64 hash) {
  return c_logicexception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_outofrangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_outofrangeexception
Variant &c_outofrangeexception::os_lval(const char *s, int64 hash) {
  return c_logicexception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_outofrangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_outofrangeexception
void c_outofrangeexception::o_getArray(Array &props) const {
  c_logicexception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_outofrangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_outofrangeexception
void c_outofrangeexception::o_setArray(CArrRef props) {
  c_logicexception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_outofrangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_outofrangeexception
Variant c_outofrangeexception::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_outofrangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_outofrangeexception
Variant c_outofrangeexception::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_logicexception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_outofrangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_outofrangeexception
Variant c_outofrangeexception::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_outofrangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_outofrangeexception
bool c_outofrangeexception::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_outofrangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_outofrangeexception
bool c_outofrangeexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_logicexception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_outofrangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_outofrangeexception
bool c_outofrangeexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_outofrangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_outofrangeexception
Variant c_outofrangeexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_outofrangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_outofrangeexception
Variant c_outofrangeexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_logicexception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_outofrangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_outofrangeexception
Variant c_outofrangeexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_outofrangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_outofrangeexception
Variant& c_outofrangeexception::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_outofrangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_outofrangeexception
Variant& c_outofrangeexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_logicexception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_outofrangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_outofrangeexception
Variant& c_outofrangeexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_outofrangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_outofrangeexception
Variant c_outofrangeexception::os_constant(const char *s) {
  return c_logicexception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_outofrangeexception
IMPLEMENT_CLASS(outofrangeexception)
ObjectData *c_outofrangeexception::cloneImpl() {
  c_outofrangeexception *obj = NEW(c_outofrangeexception)();
  cloneSet(obj);
  return obj;
}
void c_outofrangeexception::cloneSet(c_outofrangeexception *clone) {
  c_logicexception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_outofrangeexception
Variant c_outofrangeexception::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_outofrangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_outofrangeexception
Variant c_outofrangeexception::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_outofrangeexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_outofrangeexception
Variant c_outofrangeexception::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_outofrangeexception
Variant c_outofrangeexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_logicexception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_outofrangeexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_logicexception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_outofrangeexception = {
  c_outofrangeexception::os_getInit,
  c_outofrangeexception::os_get,
  c_outofrangeexception::os_lval,
  c_outofrangeexception::os_invoke,
  c_outofrangeexception::os_constant,
};
void c_outofrangeexception::init() {
  c_logicexception::init();
}
/* SRC: classes/exception.php line 93 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_badmethodcallexception
Variant c_badmethodcallexception::os_getInit(const char *s, int64 hash) {
  return c_badfunctioncallexception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_badmethodcallexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_badmethodcallexception
Variant c_badmethodcallexception::os_get(const char *s, int64 hash) {
  return c_badfunctioncallexception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_badmethodcallexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_badmethodcallexception
Variant &c_badmethodcallexception::os_lval(const char *s, int64 hash) {
  return c_badfunctioncallexception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_badmethodcallexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_badmethodcallexception
void c_badmethodcallexception::o_getArray(Array &props) const {
  c_badfunctioncallexception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_badmethodcallexception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_badmethodcallexception
void c_badmethodcallexception::o_setArray(CArrRef props) {
  c_badfunctioncallexception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_badmethodcallexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_badmethodcallexception
Variant c_badmethodcallexception::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_badmethodcallexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_badmethodcallexception
Variant c_badmethodcallexception::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_badfunctioncallexception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_badmethodcallexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_badmethodcallexception
Variant c_badmethodcallexception::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_badmethodcallexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_badmethodcallexception
bool c_badmethodcallexception::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_badmethodcallexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_badmethodcallexception
bool c_badmethodcallexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_badfunctioncallexception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_badmethodcallexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_badmethodcallexception
bool c_badmethodcallexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_badmethodcallexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_badmethodcallexception
Variant c_badmethodcallexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_badmethodcallexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_badmethodcallexception
Variant c_badmethodcallexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_badfunctioncallexception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_badmethodcallexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_badmethodcallexception
Variant c_badmethodcallexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_badmethodcallexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_badmethodcallexception
Variant& c_badmethodcallexception::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_badmethodcallexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_badmethodcallexception
Variant& c_badmethodcallexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_badfunctioncallexception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_badmethodcallexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_badmethodcallexception
Variant& c_badmethodcallexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_badmethodcallexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_badmethodcallexception
Variant c_badmethodcallexception::os_constant(const char *s) {
  return c_badfunctioncallexception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_badmethodcallexception
IMPLEMENT_CLASS(badmethodcallexception)
ObjectData *c_badmethodcallexception::cloneImpl() {
  c_badmethodcallexception *obj = NEW(c_badmethodcallexception)();
  cloneSet(obj);
  return obj;
}
void c_badmethodcallexception::cloneSet(c_badmethodcallexception *clone) {
  c_badfunctioncallexception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_badmethodcallexception
Variant c_badmethodcallexception::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_badmethodcallexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_badmethodcallexception
Variant c_badmethodcallexception::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_badmethodcallexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_badmethodcallexception
Variant c_badmethodcallexception::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_badmethodcallexception
Variant c_badmethodcallexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_badfunctioncallexception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_badmethodcallexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_badfunctioncallexception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_badmethodcallexception = {
  c_badmethodcallexception::os_getInit,
  c_badmethodcallexception::os_get,
  c_badmethodcallexception::os_lval,
  c_badmethodcallexception::os_invoke,
  c_badmethodcallexception::os_constant,
};
void c_badmethodcallexception::init() {
  c_badfunctioncallexception::init();
}
/* SRC: classes/exception.php line 98 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_runtimeexception
Variant c_runtimeexception::os_getInit(const char *s, int64 hash) {
  return c_exception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_runtimeexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_runtimeexception
Variant c_runtimeexception::os_get(const char *s, int64 hash) {
  return c_exception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_runtimeexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_runtimeexception
Variant &c_runtimeexception::os_lval(const char *s, int64 hash) {
  return c_exception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_runtimeexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_runtimeexception
void c_runtimeexception::o_getArray(Array &props) const {
  c_exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_runtimeexception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_runtimeexception
void c_runtimeexception::o_setArray(CArrRef props) {
  c_exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_runtimeexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_runtimeexception
Variant c_runtimeexception::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_runtimeexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_runtimeexception
Variant c_runtimeexception::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_exception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_runtimeexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_runtimeexception
Variant c_runtimeexception::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_runtimeexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_runtimeexception
bool c_runtimeexception::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_runtimeexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_runtimeexception
bool c_runtimeexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_exception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_runtimeexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_runtimeexception
bool c_runtimeexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_runtimeexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_runtimeexception
Variant c_runtimeexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_runtimeexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_runtimeexception
Variant c_runtimeexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_exception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_runtimeexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_runtimeexception
Variant c_runtimeexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_runtimeexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_runtimeexception
Variant& c_runtimeexception::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_runtimeexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_runtimeexception
Variant& c_runtimeexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_exception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_runtimeexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_runtimeexception
Variant& c_runtimeexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_runtimeexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_runtimeexception
Variant c_runtimeexception::os_constant(const char *s) {
  return c_exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_runtimeexception
IMPLEMENT_CLASS(runtimeexception)
ObjectData *c_runtimeexception::cloneImpl() {
  c_runtimeexception *obj = NEW(c_runtimeexception)();
  cloneSet(obj);
  return obj;
}
void c_runtimeexception::cloneSet(c_runtimeexception *clone) {
  c_exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_runtimeexception
Variant c_runtimeexception::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_runtimeexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_runtimeexception
Variant c_runtimeexception::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_runtimeexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_runtimeexception
Variant c_runtimeexception::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_runtimeexception
Variant c_runtimeexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_runtimeexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_runtimeexception = {
  c_runtimeexception::os_getInit,
  c_runtimeexception::os_get,
  c_runtimeexception::os_lval,
  c_runtimeexception::os_invoke,
  c_runtimeexception::os_constant,
};
void c_runtimeexception::init() {
  c_exception::init();
}
/* SRC: classes/exception.php line 3 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_exception
Variant c_exception::os_getInit(const char *s, int64 hash) {
  DECLARE_SYSTEM_GLOBALS(g);
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 7:
      HASH_RETURN(0x3CCB986B2CF0A747LL, 
                  null, "trace");
      break;
    case 9:
      HASH_RETURN(0x58C72230857ACDB9LL, 
                  0LL, "code");
      break;
    case 10:
      HASH_RETURN(0x04AB35CACF8C8C9ALL, 
                  null, "line");
      break;
    case 11:
      HASH_RETURN(0x0247CDBB94C9D47BLL, 
                  "", "message");
      break;
    case 15:
      HASH_RETURN(0x7863294A8F33D14FLL, 
                  null, "file");
      break;
    default:
      break;
  }
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_exception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_exception
Variant c_exception::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_exception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_exception
Variant &c_exception::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_exception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_exception
void c_exception::o_getArray(Array &props) const {
  if (isInitialized(m_message)) props.set("message", m_message.isReferenced() ? ref(m_message) : m_message, 0x0247CDBB94C9D47BLL, true);
  if (isInitialized(m_code)) props.set("code", m_code.isReferenced() ? ref(m_code) : m_code, 0x58C72230857ACDB9LL, true);
  if (isInitialized(m_file)) props.set("file", m_file.isReferenced() ? ref(m_file) : m_file, 0x7863294A8F33D14FLL, true);
  if (isInitialized(m_line)) props.set("line", m_line.isReferenced() ? ref(m_line) : m_line, 0x04AB35CACF8C8C9ALL, true);
  if (isInitialized(m_trace)) props.set("trace", m_trace.isReferenced() ? ref(m_trace) : m_trace, 0x3CCB986B2CF0A747LL, true);
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_exception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_exception
void c_exception::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_exception
#ifndef OMIT_JUMP_TABLE_CLASS_get_exception
Variant c_exception::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_exception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_exception
Variant c_exception::o_getPublic(CStrRef s, int64 hash, bool error) {
  if (hash < 0) hash = StringData::Hash(s.get());
  switch (hash & 15) {
    case 7:
      HASH_RETURN_STRING(0x3CCB986B2CF0A747LL, m_trace,
                         "trace", 5);
      break;
    case 9:
      HASH_RETURN_STRING(0x58C72230857ACDB9LL, m_code,
                         "code", 4);
      break;
    case 10:
      HASH_RETURN_STRING(0x04AB35CACF8C8C9ALL, m_line,
                         "line", 4);
      break;
    case 11:
      HASH_RETURN_STRING(0x0247CDBB94C9D47BLL, m_message,
                         "message", 7);
      break;
    case 15:
      HASH_RETURN_STRING(0x7863294A8F33D14FLL, m_file,
                         "file", 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_exception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_exception
Variant c_exception::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_exception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_exception
bool c_exception::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_exception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_exception
bool c_exception::o_existsPublic(CStrRef s, int64 hash) const {
  if (hash < 0) hash = StringData::Hash(s.get());
  switch (hash & 15) {
    case 7:
      HASH_EXISTS_STRING(0x3CCB986B2CF0A747LL, "trace", 5);
      break;
    case 9:
      HASH_EXISTS_STRING(0x58C72230857ACDB9LL, "code", 4);
      break;
    case 10:
      HASH_EXISTS_STRING(0x04AB35CACF8C8C9ALL, "line", 4);
      break;
    case 11:
      HASH_EXISTS_STRING(0x0247CDBB94C9D47BLL, "message", 7);
      break;
    case 15:
      HASH_EXISTS_STRING(0x7863294A8F33D14FLL, "file", 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_exception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_exception
bool c_exception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_exception
#ifndef OMIT_JUMP_TABLE_CLASS_set_exception
Variant c_exception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_exception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_exception
Variant c_exception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  if (hash < 0) hash = StringData::Hash(s.get());
  switch (hash & 15) {
    case 7:
      HASH_SET_STRING(0x3CCB986B2CF0A747LL, m_trace,
                      "trace", 5);
      break;
    case 9:
      HASH_SET_STRING(0x58C72230857ACDB9LL, m_code,
                      "code", 4);
      break;
    case 10:
      HASH_SET_STRING(0x04AB35CACF8C8C9ALL, m_line,
                      "line", 4);
      break;
    case 11:
      HASH_SET_STRING(0x0247CDBB94C9D47BLL, m_message,
                      "message", 7);
      break;
    case 15:
      HASH_SET_STRING(0x7863294A8F33D14FLL, m_file,
                      "file", 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_exception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_exception
Variant c_exception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_exception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_exception
Variant& c_exception::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_exception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_exception
Variant& c_exception::o_lvalPublic(CStrRef s, int64 hash) {
  if (hash < 0) hash = StringData::Hash(s.get());
  switch (hash & 15) {
    case 7:
      HASH_RETURN_STRING(0x3CCB986B2CF0A747LL, m_trace,
                         "trace", 5);
      break;
    case 9:
      HASH_RETURN_STRING(0x58C72230857ACDB9LL, m_code,
                         "code", 4);
      break;
    case 10:
      HASH_RETURN_STRING(0x04AB35CACF8C8C9ALL, m_line,
                         "line", 4);
      break;
    case 11:
      HASH_RETURN_STRING(0x0247CDBB94C9D47BLL, m_message,
                         "message", 7);
      break;
    case 15:
      HASH_RETURN_STRING(0x7863294A8F33D14FLL, m_file,
                         "file", 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_exception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_exception
Variant& c_exception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_exception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_exception
Variant c_exception::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_exception
IMPLEMENT_CLASS(exception)
c_exception *c_exception::create(Variant v_message //  = ""
, Variant v_code //  = 0LL
) {
  CountableHelper h(this);
  init();
  t___construct(v_message, v_code);
  return this;
}
ObjectData *c_exception::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("Exception::__construct", 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      if (count == 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_exception::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("Exception::__construct", 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_exception::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("Exception::__construct", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
ObjectData *c_exception::cloneImpl() {
  c_exception *obj = NEW(c_exception)();
  cloneSet(obj);
  return obj;
}
void c_exception::cloneSet(c_exception *clone) {
  clone->m_message = m_message.isReferenced() ? ref(m_message) : m_message;
  clone->m_code = m_code.isReferenced() ? ref(m_code) : m_code;
  clone->m_file = m_file.isReferenced() ? ref(m_file) : m_file;
  clone->m_line = m_line.isReferenced() ? ref(m_line) : m_line;
  clone->m_trace = m_trace.isReferenced() ? ref(m_trace) : m_trace;
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_exception
Variant c_exception::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_exception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_exception
Variant c_exception::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_exception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_exception
Variant c_exception::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_exception
Variant c_exception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_exception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_exception = {
  c_exception::os_getInit,
  c_exception::os_get,
  c_exception::os_lval,
  c_exception::os_invoke,
  c_exception::os_constant,
};
void c_exception::init() {
  m_message = "";
  m_code = 0LL;
  m_file = null;
  m_line = null;
  m_trace = null;
  {CountableHelper h(this); t___init__();}
}
/* SRC: classes/exception.php line 16 */
void c_exception::t___init__() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::__init__);
  Variant v_top;
  Variant v_frame;

  {
    const Array &tmp1((x_debug_backtrace()));
    m_trace = tmp1;
  }
  LOOP_COUNTER(2);
  {
    while (!(empty(m_trace))) {
      LOOP_COUNTER_CHECK(2);
      {
        {
          Variant tmp3((m_trace.rvalAt(0LL, 0x77CFA1EEF01BCA90LL, true)));
          v_top = tmp3;
        }
        {
          bool tmp4;
          {
            bool tmp5 = (empty(v_top, "class", 0x2E3A246D1F74C210LL, true));
            if (!tmp5) {
              bool tmp6 = ((toBoolean(x_strcasecmp(toString(v_top.rvalAt("function", 0x7356F680A745A524LL, true, true)), "__init__")) && toBoolean(x_strcasecmp(toString(v_top.rvalAt("function", 0x7356F680A745A524LL, true, true)), "__construct"))));
              if (tmp6) {
                String tmp7((toString(v_top.rvalAt("function", 0x7356F680A745A524LL, true, true))));
                String tmp8((toString(v_top.rvalAt("class", 0x2E3A246D1F74C210LL, true, true))));
                tmp6 = (toBoolean(x_strcasecmp(tmp7, tmp8)));
              }
              tmp5 = (tmp6);
            }
            tmp4 = ((tmp5 || (toBoolean(x_strcasecmp(toString(v_top.rvalAt("class", 0x2E3A246D1F74C210LL, true, true)), "exception")) && !(x_is_subclass_of(v_top.rvalAt("class", 0x2E3A246D1F74C210LL, true, true), "exception")))));
          }
          if (tmp4) {
            {
              break;
            }
          }
        }
        {
          const Variant &tmp9((x_array_shift(ref(lval(m_trace)))));
          v_frame = tmp9;
        }
      }
    }
  }
  if (isset(v_frame, "file", 0x7863294A8F33D14FLL, true)) {
    {
      Variant tmp10((v_frame.rvalAt("file", 0x7863294A8F33D14FLL, true, true)));
      m_file = tmp10;
    }
  }
  if (isset(v_frame, "line", 0x04AB35CACF8C8C9ALL, true)) {
    {
      Variant tmp11((v_frame.rvalAt("line", 0x04AB35CACF8C8C9ALL, true, true)));
      m_line = tmp11;
    }
  }
} /* function */
/* SRC: classes/exception.php line 37 */
void c_exception::t___construct(Variant v_message //  = ""
, Variant v_code //  = 0LL
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::__construct);
  bool oldInCtor = gasInCtor(true);
  m_message = v_message;
  m_code = v_code;
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/exception.php line 43 */
Variant c_exception::t_getmessage() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::getMessage);
  return m_message;
} /* function */
/* SRC: classes/exception.php line 48 */
Variant c_exception::t_getcode() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::getCode);
  return m_code;
} /* function */
/* SRC: classes/exception.php line 53 */
Variant c_exception::t_getfile() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::getFile);
  return m_file;
} /* function */
/* SRC: classes/exception.php line 58 */
Variant c_exception::t_getline() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::getLine);
  return m_line;
} /* function */
/* SRC: classes/exception.php line 63 */
Variant c_exception::t_gettrace() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::getTrace);
  return m_trace;
} /* function */
/* SRC: classes/exception.php line 68 */
String c_exception::t_gettraceasstring() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::getTraceAsString);
  int64 v_i = 0;
  String v_s;
  Variant v_frame;

  v_i = 0LL;
  v_s = "";
  {
    LOOP_COUNTER(1);
    Variant map2 = t_gettrace();
    {
      StringBuffer tmp_sbuf_v_s(512);
      for (ArrayIterPtr iter3 = map2.begin(s_class_name); !iter3->end(); iter3->next()) {
        LOOP_COUNTER_CHECK(1);
        iter3->second(v_frame);
        {
          if (!(x_is_array(v_frame))) {
            continue;
          }
          {
            StringBuffer tmp4_buf;
            tmp4_buf.append("#", 1);
            tmp4_buf.append(toString(v_i));
            tmp4_buf.append(" ", 1);
            tmp4_buf.append(toString(v_frame.rvalAt("file", 0x7863294A8F33D14FLL, true, true)));
            tmp4_buf.append("(", 1);
            tmp4_buf.append(toString(v_frame.rvalAt("line", 0x04AB35CACF8C8C9ALL, true, true)));
            tmp4_buf.append("): ", 3);
            Variant tmp5;
            if (isset(v_frame, "class", 0x2E3A246D1F74C210LL, true)) {
              String tmp6((toString(v_frame.rvalAt("class", 0x2E3A246D1F74C210LL, true, true))));
              String tmp7((toString(v_frame.rvalAt("type", 0x7B5ABDA0E01EF853LL, true, true))));
              tmp5 = (concat(tmp6, tmp7));
            } else {
              tmp5 = ("");
            }
            tmp4_buf.append(toString(tmp5));
            tmp4_buf.append(toString(v_frame.rvalAt("function", 0x7356F680A745A524LL, true, true)));
            tmp4_buf.append("()\n", 3);
            CStrRef tmp4(tmp4_buf.detach());
            tmp_sbuf_v_s.add(tmp4);
          }
          v_i++;
        }
      }
      concat_assign(v_s, tmp_sbuf_v_s.detach());
    }
  }
  concat_assign(v_s, concat3("#", toString(v_i), " {main}"));
  return v_s;
} /* function */
/* SRC: classes/exception.php line 86 */
String c_exception::t___tostring() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::__toString);
  return toString(t_getmessage());
} /* function */
/* SRC: classes/exception.php line 105 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_errorexception
Variant c_errorexception::os_getInit(const char *s, int64 hash) {
  DECLARE_SYSTEM_GLOBALS(g);
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 1:
      HASH_RETURN(0x4FDAA620FA5F15F9LL, 
                  null, "severity");
      break;
    default:
      break;
  }
  return c_exception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_errorexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_errorexception
Variant c_errorexception::os_get(const char *s, int64 hash) {
  return c_exception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_errorexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_errorexception
Variant &c_errorexception::os_lval(const char *s, int64 hash) {
  return c_exception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_errorexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_errorexception
void c_errorexception::o_getArray(Array &props) const {
  if (isInitialized(m_severity)) props.set("severity", m_severity.isReferenced() ? ref(m_severity) : m_severity, 0x4FDAA620FA5F15F9LL, true);
  c_exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_errorexception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_errorexception
void c_errorexception::o_setArray(CArrRef props) {
  c_exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_errorexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_errorexception
Variant c_errorexception::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_errorexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_errorexception
Variant c_errorexception::o_getPublic(CStrRef s, int64 hash, bool error) {
  if (hash < 0) hash = StringData::Hash(s.get());
  switch (hash & 1) {
    case 1:
      HASH_RETURN_STRING(0x4FDAA620FA5F15F9LL, m_severity,
                         "severity", 8);
      break;
    default:
      break;
  }
  return c_exception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_errorexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_errorexception
Variant c_errorexception::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_errorexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_errorexception
bool c_errorexception::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_errorexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_errorexception
bool c_errorexception::o_existsPublic(CStrRef s, int64 hash) const {
  if (hash < 0) hash = StringData::Hash(s.get());
  switch (hash & 1) {
    case 1:
      HASH_EXISTS_STRING(0x4FDAA620FA5F15F9LL, "severity", 8);
      break;
    default:
      break;
  }
  return c_exception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_errorexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_errorexception
bool c_errorexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_errorexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_errorexception
Variant c_errorexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_errorexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_errorexception
Variant c_errorexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  if (hash < 0) hash = StringData::Hash(s.get());
  switch (hash & 1) {
    case 1:
      HASH_SET_STRING(0x4FDAA620FA5F15F9LL, m_severity,
                      "severity", 8);
      break;
    default:
      break;
  }
  return c_exception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_errorexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_errorexception
Variant c_errorexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_errorexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_errorexception
Variant& c_errorexception::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_errorexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_errorexception
Variant& c_errorexception::o_lvalPublic(CStrRef s, int64 hash) {
  if (hash < 0) hash = StringData::Hash(s.get());
  switch (hash & 1) {
    case 1:
      HASH_RETURN_STRING(0x4FDAA620FA5F15F9LL, m_severity,
                         "severity", 8);
      break;
    default:
      break;
  }
  return c_exception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_errorexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_errorexception
Variant& c_errorexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_errorexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_errorexception
Variant c_errorexception::os_constant(const char *s) {
  return c_exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_errorexception
IMPLEMENT_CLASS(errorexception)
c_errorexception *c_errorexception::create(Variant v_message //  = ""
, Variant v_code //  = 0LL
, Variant v_severity //  = 0LL
, Variant v_filename //  = null
, Variant v_lineno //  = null
) {
  CountableHelper h(this);
  init();
  t___construct(v_message, v_code, v_severity, v_filename, v_lineno);
  return this;
}
ObjectData *c_errorexception::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 5) throw_toomany_arguments("ErrorException::__construct", 5, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      if (count == 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1, arg2, arg3, arg4));
    } while (false);
  }
  return this;
}
void c_errorexception::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 5) throw_toomany_arguments("ErrorException::__construct", 5, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1, arg2, arg3, arg4));
  } while (false);
}
void c_errorexception::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 5) throw_toomany_arguments("ErrorException::__construct", 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else (t___construct(a0, a1, a2, a3, a4), null);
}
ObjectData *c_errorexception::cloneImpl() {
  c_errorexception *obj = NEW(c_errorexception)();
  cloneSet(obj);
  return obj;
}
void c_errorexception::cloneSet(c_errorexception *clone) {
  clone->m_severity = m_severity.isReferenced() ? ref(m_severity) : m_severity;
  c_exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_errorexception
Variant c_errorexception::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 5) return throw_toomany_arguments("errorexception::__construct", 5, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(params[0]), null);
        if (count == 2) return (t___construct(params[0], params[1]), null);
        if (count == 3) return (t___construct(params[0], params[1], params[2]), null);
        if (count == 4) return (t___construct(params[0], params[1], params[2], params[3]), null);
        return (t___construct(params[0], params[1], params[2], params[3], params[4]), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("errorexception::getseverity", 0, 1);
        return (t_getseverity());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 5) return throw_toomany_arguments("ErrorException::__construct", 5, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
        }
      }
      HASH_GUARD(0x4B378D0258AF461FLL, getseverity) {
        if (count > 0) return throw_toomany_arguments("ErrorException::getSeverity", 0, 1);
        return (t_getseverity());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_errorexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_errorexception
Variant c_errorexception::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 5) return throw_toomany_arguments("errorexception::__construct", 5, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("errorexception::getseverity", 0, 1);
        return (t_getseverity());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 5) return throw_toomany_arguments("ErrorException::__construct", 5, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        return (t___construct(a0, a1, a2, a3, a4), null);
      }
      HASH_GUARD(0x4B378D0258AF461FLL, getseverity) {
        if (count > 0) return throw_toomany_arguments("ErrorException::getSeverity", 0, 1);
        return (t_getseverity());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_errorexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_errorexception
Variant c_errorexception::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_errorexception
Variant c_errorexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 5) return throw_toomany_arguments("errorexception::__construct", 5, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorexception::getseverity", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getseverity());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 5) return throw_toomany_arguments("ErrorException::__construct", 5, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      HASH_GUARD(0x4B378D0258AF461FLL, getseverity) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ErrorException::getSeverity", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getseverity());
      }
      break;
    default:
      break;
  }
#endif
  return c_exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_errorexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_errorexception = {
  c_errorexception::os_getInit,
  c_errorexception::os_get,
  c_errorexception::os_lval,
  c_errorexception::os_invoke,
  c_errorexception::os_constant,
};
void c_errorexception::init() {
  c_exception::init();
  m_severity = null;
}
/* SRC: classes/exception.php line 107 */
void c_errorexception::t___construct(Variant v_message //  = ""
, Variant v_code //  = 0LL
, Variant v_severity //  = 0LL
, Variant v_filename //  = null
, Variant v_lineno //  = null
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ErrorException, ErrorException::__construct);
  bool oldInCtor = gasInCtor(true);
  c_exception::t___construct(v_message, v_code);
  m_severity = v_severity;
  if (!(x_is_null(v_filename))) {
    {
      m_file = v_filename;
    }
  }
  if (!(x_is_null(v_lineno))) {
    {
      m_line = v_lineno;
    }
  }
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/exception.php line 119 */
Variant c_errorexception::t_getseverity() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ErrorException, ErrorException::getSeverity);
  return m_severity;
} /* function */
/* SRC: classes/exception.php line 92 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_badfunctioncallexception
Variant c_badfunctioncallexception::os_getInit(const char *s, int64 hash) {
  return c_logicexception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_badfunctioncallexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_badfunctioncallexception
Variant c_badfunctioncallexception::os_get(const char *s, int64 hash) {
  return c_logicexception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_badfunctioncallexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_badfunctioncallexception
Variant &c_badfunctioncallexception::os_lval(const char *s, int64 hash) {
  return c_logicexception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_badfunctioncallexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_badfunctioncallexception
void c_badfunctioncallexception::o_getArray(Array &props) const {
  c_logicexception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_badfunctioncallexception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_badfunctioncallexception
void c_badfunctioncallexception::o_setArray(CArrRef props) {
  c_logicexception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_badfunctioncallexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_badfunctioncallexception
Variant c_badfunctioncallexception::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_badfunctioncallexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_badfunctioncallexception
Variant c_badfunctioncallexception::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_logicexception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_badfunctioncallexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_badfunctioncallexception
Variant c_badfunctioncallexception::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_badfunctioncallexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_badfunctioncallexception
bool c_badfunctioncallexception::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_badfunctioncallexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_badfunctioncallexception
bool c_badfunctioncallexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_logicexception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_badfunctioncallexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_badfunctioncallexception
bool c_badfunctioncallexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_badfunctioncallexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_badfunctioncallexception
Variant c_badfunctioncallexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_badfunctioncallexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_badfunctioncallexception
Variant c_badfunctioncallexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_logicexception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_badfunctioncallexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_badfunctioncallexception
Variant c_badfunctioncallexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_badfunctioncallexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_badfunctioncallexception
Variant& c_badfunctioncallexception::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_badfunctioncallexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_badfunctioncallexception
Variant& c_badfunctioncallexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_logicexception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_badfunctioncallexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_badfunctioncallexception
Variant& c_badfunctioncallexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_badfunctioncallexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_badfunctioncallexception
Variant c_badfunctioncallexception::os_constant(const char *s) {
  return c_logicexception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_badfunctioncallexception
IMPLEMENT_CLASS(badfunctioncallexception)
ObjectData *c_badfunctioncallexception::cloneImpl() {
  c_badfunctioncallexception *obj = NEW(c_badfunctioncallexception)();
  cloneSet(obj);
  return obj;
}
void c_badfunctioncallexception::cloneSet(c_badfunctioncallexception *clone) {
  c_logicexception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_badfunctioncallexception
Variant c_badfunctioncallexception::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_badfunctioncallexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_badfunctioncallexception
Variant c_badfunctioncallexception::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_badfunctioncallexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_badfunctioncallexception
Variant c_badfunctioncallexception::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_badfunctioncallexception
Variant c_badfunctioncallexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_logicexception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_badfunctioncallexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_logicexception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_badfunctioncallexception = {
  c_badfunctioncallexception::os_getInit,
  c_badfunctioncallexception::os_get,
  c_badfunctioncallexception::os_lval,
  c_badfunctioncallexception::os_invoke,
  c_badfunctioncallexception::os_constant,
};
void c_badfunctioncallexception::init() {
  c_logicexception::init();
}
/* SRC: classes/exception.php line 96 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_lengthexception
Variant c_lengthexception::os_getInit(const char *s, int64 hash) {
  return c_logicexception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_lengthexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_lengthexception
Variant c_lengthexception::os_get(const char *s, int64 hash) {
  return c_logicexception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_lengthexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_lengthexception
Variant &c_lengthexception::os_lval(const char *s, int64 hash) {
  return c_logicexception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_lengthexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_lengthexception
void c_lengthexception::o_getArray(Array &props) const {
  c_logicexception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_lengthexception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_lengthexception
void c_lengthexception::o_setArray(CArrRef props) {
  c_logicexception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_lengthexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_lengthexception
Variant c_lengthexception::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_lengthexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_lengthexception
Variant c_lengthexception::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_logicexception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_lengthexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_lengthexception
Variant c_lengthexception::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_lengthexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_lengthexception
bool c_lengthexception::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_lengthexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_lengthexception
bool c_lengthexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_logicexception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_lengthexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_lengthexception
bool c_lengthexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_lengthexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_lengthexception
Variant c_lengthexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_lengthexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_lengthexception
Variant c_lengthexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_logicexception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_lengthexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_lengthexception
Variant c_lengthexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_lengthexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_lengthexception
Variant& c_lengthexception::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_lengthexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_lengthexception
Variant& c_lengthexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_logicexception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_lengthexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_lengthexception
Variant& c_lengthexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_lengthexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_lengthexception
Variant c_lengthexception::os_constant(const char *s) {
  return c_logicexception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_lengthexception
IMPLEMENT_CLASS(lengthexception)
ObjectData *c_lengthexception::cloneImpl() {
  c_lengthexception *obj = NEW(c_lengthexception)();
  cloneSet(obj);
  return obj;
}
void c_lengthexception::cloneSet(c_lengthexception *clone) {
  c_logicexception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_lengthexception
Variant c_lengthexception::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_lengthexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_lengthexception
Variant c_lengthexception::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_lengthexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_lengthexception
Variant c_lengthexception::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_lengthexception
Variant c_lengthexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_logicexception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_lengthexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_logicexception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_lengthexception = {
  c_lengthexception::os_getInit,
  c_lengthexception::os_get,
  c_lengthexception::os_lval,
  c_lengthexception::os_invoke,
  c_lengthexception::os_constant,
};
void c_lengthexception::init() {
  c_logicexception::init();
}
/* SRC: classes/exception.php line 94 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domainexception
Variant c_domainexception::os_getInit(const char *s, int64 hash) {
  return c_logicexception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_domainexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_domainexception
Variant c_domainexception::os_get(const char *s, int64 hash) {
  return c_logicexception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_domainexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domainexception
Variant &c_domainexception::os_lval(const char *s, int64 hash) {
  return c_logicexception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_domainexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_domainexception
void c_domainexception::o_getArray(Array &props) const {
  c_logicexception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_domainexception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_domainexception
void c_domainexception::o_setArray(CArrRef props) {
  c_logicexception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_domainexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_domainexception
Variant c_domainexception::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_domainexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domainexception
Variant c_domainexception::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_logicexception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_domainexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domainexception
Variant c_domainexception::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domainexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_domainexception
bool c_domainexception::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_domainexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domainexception
bool c_domainexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_logicexception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_domainexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domainexception
bool c_domainexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domainexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_domainexception
Variant c_domainexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_domainexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domainexception
Variant c_domainexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_logicexception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_domainexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domainexception
Variant c_domainexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domainexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_domainexception
Variant& c_domainexception::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_domainexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domainexception
Variant& c_domainexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_logicexception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_domainexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domainexception
Variant& c_domainexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domainexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_domainexception
Variant c_domainexception::os_constant(const char *s) {
  return c_logicexception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_domainexception
IMPLEMENT_CLASS(domainexception)
ObjectData *c_domainexception::cloneImpl() {
  c_domainexception *obj = NEW(c_domainexception)();
  cloneSet(obj);
  return obj;
}
void c_domainexception::cloneSet(c_domainexception *clone) {
  c_logicexception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domainexception
Variant c_domainexception::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domainexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_domainexception
Variant c_domainexception::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_domainexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domainexception
Variant c_domainexception::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_domainexception
Variant c_domainexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x625661A755F425C0LL, __init__) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
#endif
  return c_logicexception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_domainexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_logicexception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_domainexception = {
  c_domainexception::os_getInit,
  c_domainexception::os_get,
  c_domainexception::os_lval,
  c_domainexception::os_invoke,
  c_domainexception::os_constant,
};
void c_domainexception::init() {
  c_logicexception::init();
}
Object co_unexpectedvalueexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_unexpectedvalueexception)())->dynCreate(params, init));
}
Object co_overflowexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_overflowexception)())->dynCreate(params, init));
}
Object co_outofboundsexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_outofboundsexception)())->dynCreate(params, init));
}
Object co_logicexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_logicexception)())->dynCreate(params, init));
}
Object co_rangeexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_rangeexception)())->dynCreate(params, init));
}
Object co_invalidargumentexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_invalidargumentexception)())->dynCreate(params, init));
}
Object co_underflowexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_underflowexception)())->dynCreate(params, init));
}
Object co_outofrangeexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_outofrangeexception)())->dynCreate(params, init));
}
Object co_badmethodcallexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_badmethodcallexception)())->dynCreate(params, init));
}
Object co_runtimeexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_runtimeexception)())->dynCreate(params, init));
}
Object co_exception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_exception)())->dynCreate(params, init));
}
Object co_errorexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_errorexception)())->dynCreate(params, init));
}
Object co_badfunctioncallexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_badfunctioncallexception)())->dynCreate(params, init));
}
Object co_lengthexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_lengthexception)())->dynCreate(params, init));
}
Object co_domainexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_domainexception)())->dynCreate(params, init));
}
Variant pm_php$classes$exception_php(bool incOnce /* = false */, LVariableTable* variables /* = NULL */) {
  {
    DECLARE_SYSTEM_GLOBALS(g);
    bool &alreadyRun = g->run_pm_php$classes$exception_php;
    if (alreadyRun) { if (incOnce) return true;}
    else alreadyRun = true;
    if (!variables) variables = g;
  }
  PSEUDOMAIN_INJECTION(run_init::classes/exception.php);
  DECLARE_SYSTEM_GLOBALS(g);
  LVariableTable *gVariables __attribute__((__unused__)) = get_variable_table();
  return true;
} /* function */

///////////////////////////////////////////////////////////////////////////////
}
