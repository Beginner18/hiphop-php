/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010- Facebook, Inc. (http://www.facebook.com)         |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
// @generated by HipHop Compiler

#include <php/classes/iterator.h>
#include <php/classes/iterator.fws.h>

// Dependencies
#include <php/classes/arrayaccess.h>
#include <php/classes/exception.h>
#include <runtime/ext/ext.h>
#include <runtime/eval/eval.h>
namespace hphp_impl_starter {}

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////

/* preface starts */
extern CallInfo ci_;
/* preface finishes */
/* SRC: classes/iterator.php line 329 */
const int64 q_ArrayIterator_STD_PROP_LIST = 1LL;
const int64 q_ArrayIterator_ARRAY_AS_PROPS = 2LL;
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ArrayIterator
Variant c_ArrayIterator::os_getInit(CStrRef s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = s->hash();
  switch (hash & 3) {
    case 1:
      HASH_RETURN_NAMSTR(0x7D2126D089B92EA5LL, NAMSTR(s_sys_ss7cb08d68, "arr"),
                         null, 3);
      break;
    case 3:
      HASH_RETURN_NAMSTR(0x7401482B86AFCBFBLL, NAMSTR(s_sys_ss28fae70d, "flags"),
                         null, 5);
      break;
    default:
      break;
  }
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ArrayIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_ArrayIterator
Variant c_ArrayIterator::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_ArrayIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ArrayIterator
Variant &c_ArrayIterator::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ArrayIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_ArrayIterator
Variant * c_ArrayIterator::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_ArrayIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ArrayIterator
Variant * c_ArrayIterator::o_realPropPublic(CStrRef s, int flags) const {
  int64 hash = s->hash();
  switch (hash & 3) {
    case 1:
      HASH_REALPROP_NAMSTR(0x7D2126D089B92EA5LL, NAMSTR(s_sys_ss7cb08d68, "arr"), 3, arr);
      break;
    case 3:
      HASH_REALPROP_NAMSTR(0x7401482B86AFCBFBLL, NAMSTR(s_sys_ss28fae70d, "flags"), 5, flags);
      break;
    default:
      break;
  }
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ArrayIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ArrayIterator
Variant * c_ArrayIterator::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ArrayIterator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_ArrayIterator
Variant c_ArrayIterator::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 3) {
    case 0:
      HASH_RETURN(0x7DE206EA225FC80CLL, q_ArrayIterator_STD_PROP_LIST, "STD_PROP_LIST");
      break;
    case 3:
      HASH_RETURN(0x3C29F8CAC8DB5B17LL, q_ArrayIterator_ARRAY_AS_PROPS, "ARRAY_AS_PROPS");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_ArrayIterator
IMPLEMENT_CLASS_NO_DEFAULT_SWEEP(ArrayIterator)
bool c_ArrayIterator::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 15) {
    case 1:
      HASH_INSTANCEOF(0x795F86375EE263D1LL, NAMSTR(s_sys_ss5b753b53, "Countable"));
      HASH_INSTANCEOF(0x66679538C5E6F0A1LL, NAMSTR(s_sys_ss22bfe43e, "Traversable"));
      break;
    case 3:
      HASH_INSTANCEOF(0x3D5870E53BF89873LL, NAMSTR(s_sys_ss993f2e69, "ArrayIterator"));
      HASH_INSTANCEOF(0x60C47E7FE145DC43LL, NAMSTR(s_sys_ssc1c38583, "SeekableIterator"));
      break;
    case 11:
      HASH_INSTANCEOF(0x3BDD11EABFCD6F0BLL, NAMSTR(s_sys_ss92306c9b, "ArrayAccess"));
      break;
    case 14:
      HASH_INSTANCEOF(0x0636A5F84AF9D29ELL, NAMSTR(s_sys_ssc64ebfff, "Iterator"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_ArrayIterator::cloneImpl() {
  ObjectData *obj = coo_ArrayIterator();
  c_ArrayIterator::cloneSet(obj);
  return obj;
}
void c_ArrayIterator::cloneSet(ObjectData *cl) {
  c_ArrayIterator *clone = static_cast<c_ArrayIterator*>(cl);
  ObjectData::cloneSet(clone);
  clone->m_arr.setWithRef(m_arr);
  clone->m_flags.setWithRef(m_flags);
}
CallInfo c_ArrayIterator::ci_getarraycopy((void*)&c_ArrayIterator::i_getarraycopy, (void*)&c_ArrayIterator::ifa_getarraycopy, 0, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_next((void*)&c_ArrayIterator::i_next, (void*)&c_ArrayIterator::ifa_next, 0, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_count((void*)&c_ArrayIterator::i_count, (void*)&c_ArrayIterator::ifa_count, 0, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_natsort((void*)&c_ArrayIterator::i_natsort, (void*)&c_ArrayIterator::ifa_natsort, 0, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_key((void*)&c_ArrayIterator::i_key, (void*)&c_ArrayIterator::ifa_key, 0, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_valid((void*)&c_ArrayIterator::i_valid, (void*)&c_ArrayIterator::ifa_valid, 0, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_append((void*)&c_ArrayIterator::i_append, (void*)&c_ArrayIterator::ifa_append, 1, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_setflags((void*)&c_ArrayIterator::i_setflags, (void*)&c_ArrayIterator::ifa_setflags, 1, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci___construct((void*)&c_ArrayIterator::i___construct, (void*)&c_ArrayIterator::ifa___construct, 2, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_offsetexists((void*)&c_ArrayIterator::i_offsetexists, (void*)&c_ArrayIterator::ifa_offsetexists, 1, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_uksort((void*)&c_ArrayIterator::i_uksort, (void*)&c_ArrayIterator::ifa_uksort, 1, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_offsetget((void*)&c_ArrayIterator::i_offsetget, (void*)&c_ArrayIterator::ifa_offsetget, 1, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_natcasesort((void*)&c_ArrayIterator::i_natcasesort, (void*)&c_ArrayIterator::ifa_natcasesort, 0, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_asort((void*)&c_ArrayIterator::i_asort, (void*)&c_ArrayIterator::ifa_asort, 0, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_offsetunset((void*)&c_ArrayIterator::i_offsetunset, (void*)&c_ArrayIterator::ifa_offsetunset, 1, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_seek((void*)&c_ArrayIterator::i_seek, (void*)&c_ArrayIterator::ifa_seek, 1, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_getflags((void*)&c_ArrayIterator::i_getflags, (void*)&c_ArrayIterator::ifa_getflags, 0, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_current((void*)&c_ArrayIterator::i_current, (void*)&c_ArrayIterator::ifa_current, 0, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_ksort((void*)&c_ArrayIterator::i_ksort, (void*)&c_ArrayIterator::ifa_ksort, 0, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_uasort((void*)&c_ArrayIterator::i_uasort, (void*)&c_ArrayIterator::ifa_uasort, 1, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_rewind((void*)&c_ArrayIterator::i_rewind, (void*)&c_ArrayIterator::ifa_rewind, 0, 4, 0x0000000000000000LL);
CallInfo c_ArrayIterator::ci_offsetset((void*)&c_ArrayIterator::i_offsetset, (void*)&c_ArrayIterator::ifa_offsetset, 2, 4, 0x0000000000000000LL);
Variant c_ArrayIterator::i_getarraycopy(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_getarraycopy, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::getArrayCopy", 0, 1);
  return (self->t_getarraycopy());
}
Variant c_ArrayIterator::i_next(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_next, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::next", 0, 1);
  return (self->t_next(), null);
}
Variant c_ArrayIterator::i_count(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_count, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::count", 0, 1);
  return (self->t_count());
}
Variant c_ArrayIterator::i_natsort(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_natsort, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::natsort", 0, 1);
  return (self->t_natsort(), null);
}
Variant c_ArrayIterator::i_key(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_key, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::key", 0, 1);
  return (self->t_key());
}
Variant c_ArrayIterator::i_valid(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_valid, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::valid", 0, 1);
  return (self->t_valid());
}
Variant c_ArrayIterator::i_append(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_append, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count != 1)) return throw_wrong_arguments("ArrayIterator::append", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_append(arg0), null);
  }
}
Variant c_ArrayIterator::i_setflags(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_setflags, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count != 1)) return throw_wrong_arguments("ArrayIterator::setFlags", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setflags(arg0), null);
  }
}
Variant c_ArrayIterator::i___construct(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i___construct, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count < 1 || count > 2)) return throw_wrong_arguments("ArrayIterator::__construct", count, 1, 2, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_ArrayIterator::i_offsetexists(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_offsetexists, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count != 1)) return throw_wrong_arguments("ArrayIterator::offsetExists", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_offsetexists(arg0));
  }
}
Variant c_ArrayIterator::i_uksort(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_uksort, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count != 1)) return throw_wrong_arguments("ArrayIterator::uksort", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_uksort(arg0), null);
  }
}
Variant c_ArrayIterator::i_offsetget(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_offsetget, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count != 1)) return throw_wrong_arguments("ArrayIterator::offsetGet", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_offsetget(arg0));
  }
}
Variant c_ArrayIterator::i_natcasesort(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_natcasesort, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::natcasesort", 0, 1);
  return (self->t_natcasesort(), null);
}
Variant c_ArrayIterator::i_asort(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_asort, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::asort", 0, 1);
  return (self->t_asort(), null);
}
Variant c_ArrayIterator::i_offsetunset(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_offsetunset, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count != 1)) return throw_wrong_arguments("ArrayIterator::offsetUnset", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_offsetunset(arg0));
  }
}
Variant c_ArrayIterator::i_seek(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_seek, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count != 1)) return throw_wrong_arguments("ArrayIterator::seek", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_seek(arg0), null);
  }
}
Variant c_ArrayIterator::i_getflags(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_getflags, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::getFlags", 0, 1);
  return (self->t_getflags());
}
Variant c_ArrayIterator::i_current(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_current, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::current", 0, 1);
  return (self->t_current());
}
Variant c_ArrayIterator::i_ksort(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_ksort, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::ksort", 0, 1);
  return (self->t_ksort(), null);
}
Variant c_ArrayIterator::i_uasort(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_uasort, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count != 1)) return throw_wrong_arguments("ArrayIterator::uasort", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_uasort(arg0), null);
  }
}
Variant c_ArrayIterator::i_rewind(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_rewind, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::rewind", 0, 1);
  return (self->t_rewind(), null);
}
Variant c_ArrayIterator::i_offsetset(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_offsetset, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count != 2)) return throw_wrong_arguments("ArrayIterator::offsetSet", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_offsetset(arg0, arg1));
  }
}
Variant c_ArrayIterator::ifa_getarraycopy(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_getarraycopy, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::getArrayCopy", 0, 1);
  return (self->t_getarraycopy());
}
Variant c_ArrayIterator::ifa_next(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_next, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::next", 0, 1);
  return (self->t_next(), null);
}
Variant c_ArrayIterator::ifa_count(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_count, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::count", 0, 1);
  return (self->t_count());
}
Variant c_ArrayIterator::ifa_natsort(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_natsort, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::natsort", 0, 1);
  return (self->t_natsort(), null);
}
Variant c_ArrayIterator::ifa_key(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_key, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::key", 0, 1);
  return (self->t_key());
}
Variant c_ArrayIterator::ifa_valid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_valid, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::valid", 0, 1);
  return (self->t_valid());
}
Variant c_ArrayIterator::ifa_append(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_append, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count != 1)) return throw_wrong_arguments("ArrayIterator::append", count, 1, 1, 1);
  CVarRef arg0(a0);
  return (self->t_append(arg0), null);
}
Variant c_ArrayIterator::ifa_setflags(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_setflags, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count != 1)) return throw_wrong_arguments("ArrayIterator::setFlags", count, 1, 1, 1);
  CVarRef arg0(a0);
  return (self->t_setflags(arg0), null);
}
Variant c_ArrayIterator::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa___construct, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count < 1 || count > 2)) return throw_wrong_arguments("ArrayIterator::__construct", count, 1, 2, 2);
  CVarRef arg0(a0);
  if (count <= 1) return (self->t___construct(arg0), null);
  CVarRef arg1(a1);
  return (self->t___construct(arg0, arg1), null);
}
Variant c_ArrayIterator::ifa_offsetexists(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_offsetexists, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count != 1)) return throw_wrong_arguments("ArrayIterator::offsetExists", count, 1, 1, 1);
  CVarRef arg0(a0);
  return (self->t_offsetexists(arg0));
}
Variant c_ArrayIterator::ifa_uksort(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_uksort, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count != 1)) return throw_wrong_arguments("ArrayIterator::uksort", count, 1, 1, 1);
  CVarRef arg0(a0);
  return (self->t_uksort(arg0), null);
}
Variant c_ArrayIterator::ifa_offsetget(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_offsetget, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count != 1)) return throw_wrong_arguments("ArrayIterator::offsetGet", count, 1, 1, 1);
  CVarRef arg0(a0);
  return (self->t_offsetget(arg0));
}
Variant c_ArrayIterator::ifa_natcasesort(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_natcasesort, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::natcasesort", 0, 1);
  return (self->t_natcasesort(), null);
}
Variant c_ArrayIterator::ifa_asort(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_asort, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::asort", 0, 1);
  return (self->t_asort(), null);
}
Variant c_ArrayIterator::ifa_offsetunset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_offsetunset, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count != 1)) return throw_wrong_arguments("ArrayIterator::offsetUnset", count, 1, 1, 1);
  CVarRef arg0(a0);
  return (self->t_offsetunset(arg0));
}
Variant c_ArrayIterator::ifa_seek(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_seek, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count != 1)) return throw_wrong_arguments("ArrayIterator::seek", count, 1, 1, 1);
  CVarRef arg0(a0);
  return (self->t_seek(arg0), null);
}
Variant c_ArrayIterator::ifa_getflags(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_getflags, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::getFlags", 0, 1);
  return (self->t_getflags());
}
Variant c_ArrayIterator::ifa_current(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_current, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::current", 0, 1);
  return (self->t_current());
}
Variant c_ArrayIterator::ifa_ksort(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_ksort, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::ksort", 0, 1);
  return (self->t_ksort(), null);
}
Variant c_ArrayIterator::ifa_uasort(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_uasort, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count != 1)) return throw_wrong_arguments("ArrayIterator::uasort", count, 1, 1, 1);
  CVarRef arg0(a0);
  return (self->t_uasort(arg0), null);
}
Variant c_ArrayIterator::ifa_rewind(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_rewind, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("ArrayIterator::rewind", 0, 1);
  return (self->t_rewind(), null);
}
Variant c_ArrayIterator::ifa_offsetset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_offsetset, coo_ArrayIterator);
  }
  c_ArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_ArrayIterator*>(mcp.obj));
  if (UNLIKELY(count != 2)) return throw_wrong_arguments("ArrayIterator::offsetSet", count, 2, 2, 1);
  CVarRef arg0(a0);
  CVarRef arg1(a1);
  return (self->t_offsetset(arg0, arg1));
}
const MethodCallInfoTable c_ArrayIterator::s_call_info_table[] = {
  { 0x3E6BCFB9742FC700LL, 1, 12, "offsetExists", &c_ArrayIterator::ci_offsetexists },
  { 0x4DEE4A472DC69EC2LL, 1, 6, "append", &c_ArrayIterator::ci_append },
  { 0x6413CB5154808C44LL, 1, 5, "valid", &c_ArrayIterator::ci_valid },
  { 0x4842AF70A71BE6C4LL, 0, 6, "uksort", &c_ArrayIterator::ci_uksort },
  { 0x234F6A0A486E8646LL, 1, 11, "natcasesort", &c_ArrayIterator::ci_natcasesort },
  { 0x2FC3A6941D522E0ALL, 1, 8, "setFlags", &c_ArrayIterator::ci_setflags },
  { 0x5CEFA5A265104D10LL, 1, 5, "count", &c_ArrayIterator::ci_count },
  { 0x56EDB60C824E8C51LL, 1, 3, "key", &c_ArrayIterator::ci_key },
  { 0x61D11ECEF4404498LL, 1, 9, "offsetGet", &c_ArrayIterator::ci_offsetget },
  { 0x70448A629A74FB18LL, 0, 5, "ksort", &c_ArrayIterator::ci_ksort },
  { 0x5B3A4A72846B21DCLL, 1, 7, "current", &c_ArrayIterator::ci_current },
  { 0x0D31D0AC229C615FLL, 1, 11, "__construct", &c_ArrayIterator::ci___construct },
  { 0x6FACBD7F02B6FD60LL, 1, 6, "uasort", &c_ArrayIterator::ci_uasort },
  { 0x0E210679B2DFD461LL, 1, 12, "getArrayCopy", &c_ArrayIterator::ci_getarraycopy },
  { 0x27E7DBA875AD17E1LL, 0, 8, "getFlags", &c_ArrayIterator::ci_getflags },
  { 0x7EF5445C77054C67LL, 1, 4, "seek", &c_ArrayIterator::ci_seek },
  { 0x1670096FDE27AF6ALL, 1, 6, "rewind", &c_ArrayIterator::ci_rewind },
  { 0x790B7C44A3442BEELL, 1, 5, "asort", &c_ArrayIterator::ci_asort },
  { 0x7DB9D839ACE0DEB3LL, 1, 7, "natsort", &c_ArrayIterator::ci_natsort },
  { 0x3C6D50F3BB8102B8LL, 1, 4, "next", &c_ArrayIterator::ci_next },
  { 0x0957F693A48AF738LL, 0, 9, "offsetSet", &c_ArrayIterator::ci_offsetset },
  { 0x08329980E6369ABALL, 1, 11, "offsetUnset", &c_ArrayIterator::ci_offsetunset },
  { 0, 1, 0, 0 }
};
const int c_ArrayIterator::s_call_info_index[] = {
  63,
  0,-1,1,-1,2,-1,4,-1,
  -1,-1,5,-1,-1,-1,-1,-1,
  6,7,-1,-1,-1,-1,-1,-1,
  8,-1,-1,-1,10,-1,-1,11,
  12,13,-1,-1,-1,-1,-1,15,
  -1,-1,16,-1,-1,-1,17,-1,
  -1,-1,-1,18,-1,-1,-1,-1,
  19,-1,21,-1,-1,-1,-1,-1,

};
c_ArrayIterator *c_ArrayIterator::create(CVarRef v_array, CVarRef v_flags //  = NAMVAR(s_sys_svif01bca90, 0LL)
) {
  CountableHelper h(this);
  init();
  t___construct(v_array, v_flags);
  return this;
}
void c_ArrayIterator::dynConstruct(CArrRef params) {
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count < 1 || count > 2)) throw_wrong_arguments("ArrayIterator::__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_ArrayIterator::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_ArrayIterator::ci___construct;
  mcp.obj = this;
}
ObjectStaticCallbacks cw_ArrayIterator = {
  c_ArrayIterator::os_getInit,
  c_ArrayIterator::os_get,
  c_ArrayIterator::os_lval,
  c_ArrayIterator::os_invoke,
  c_ArrayIterator::os_constant,
  (ObjectData*(*)(ObjectData*))coo_ArrayIterator,
  c_ArrayIterator::s_call_info_table,c_ArrayIterator::s_call_info_index,
  &c_ArrayIterator::s_class_name,
  0
};
/* SRC: classes/iterator.php line 336 */
void c_ArrayIterator::t___construct(Variant v_array, Variant v_flags //  = 0LL
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::__construct);
  bool oldInCtor = gasInCtor(true);
  m_arr.assignVal(v_array);
  m_flags.assignVal(v_flags);
  x_reset(ref(m_arr));
  gasInCtor(oldInCtor);
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 353 */
void c_ArrayIterator::t_append(CVarRef v_value) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::append);
  m_arr.append((v_value));
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 366 */
void c_ArrayIterator::t_asort() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::asort);
  x_asort(ref(m_arr), toInt32(m_flags));
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 380 */
int c_ArrayIterator::t_count() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::count);
  return x_count(m_arr);
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 392 */
Variant c_ArrayIterator::t_current() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::current);
  return x_current(ref(m_arr));
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 406 */
Variant c_ArrayIterator::t_getarraycopy() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::getArrayCopy);
  return m_arr;
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 419 */
Variant c_ArrayIterator::t_getflags() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::getFlags);
  return m_flags;
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 431 */
Variant c_ArrayIterator::t_key() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::key);
  return x_key(ref(m_arr));
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 444 */
void c_ArrayIterator::t_ksort() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::ksort);
  x_ksort(ref(m_arr), toInt32(m_flags));
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 458 */
void c_ArrayIterator::t_natcasesort() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::natcasesort);
  x_natcasesort(ref(m_arr));
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 472 */
void c_ArrayIterator::t_natsort() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::natsort);
  x_natsort(ref(m_arr));
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 484 */
void c_ArrayIterator::t_next() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::next);
  x_next(ref(m_arr));
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 499 */
bool c_ArrayIterator::t_offsetexists(CVarRef v_index) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::offsetExists);
  {
    return isset(m_arr, v_index);
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 514 */
Variant c_ArrayIterator::t_offsetget(Variant v_index) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::offsetGet);
  return m_arr.rvalAt(v_index, AccessFlags::Error);
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 514 */
Variant &c_ArrayIterator::___offsetget_lval(Variant v_index) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::offsetGet);
  Variant &v = get_system_globals()->__lvalProxy;
  v = t_offsetget(v_index);
  return v;
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 530 */
Variant c_ArrayIterator::t_offsetset(CVarRef v_index, CVarRef v_newval) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::offsetSet);
  m_arr.set(v_index, (v_newval));
  return null;
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 545 */
Variant c_ArrayIterator::t_offsetunset(CVarRef v_index) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::offsetUnset);
  m_arr.weakRemove(v_index);
  return null;
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 557 */
void c_ArrayIterator::t_rewind() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::rewind);
  x_reset(ref(m_arr));
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 570 */
void c_ArrayIterator::t_seek(CVarRef v_position) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::seek);
  int64 v_i = 0;

  x_reset(ref(m_arr));
  {
    LOOP_COUNTER(1);
    for (v_i = 0LL; (less(v_i, v_position)); v_i++) {
      LOOP_COUNTER_CHECK(1);
      {
        {
          bool tmp0;
          {
            bool tmp1((toBoolean(x_next(ref(m_arr)))));
            tmp0 = (!(tmp1));
          }
          if (tmp0) {
            {
              break;
            }
          }
        }
      }
    }
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 593 */
void c_ArrayIterator::t_setflags(CVarRef v_flags) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::setFlags);
  m_flags.assignVal(v_flags);
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 610 */
void c_ArrayIterator::t_uasort(CVarRef v_cmp_function) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::uasort);
  x_uasort(ref(m_arr), v_cmp_function);
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 627 */
void c_ArrayIterator::t_uksort(CVarRef v_cmp_function) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::uksort);
  x_uksort(ref(m_arr), v_cmp_function);
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 639 */
bool c_ArrayIterator::t_valid() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ArrayIterator, ArrayIterator::valid);
  {
    const Variant &tmp0((x_key(ref(m_arr))));
    bool tmp1((x_is_null(tmp0)));
    return !(tmp1);
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 796 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_AppendIterator
Variant c_AppendIterator::os_getInit(CStrRef s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = s->hash();
  switch (hash & 1) {
    case 1:
      HASH_RETURN_NAMSTR(0x60EA38C41F14FF71LL, NAMSTR(s_sys_ssd4af8244, "iterators"),
                         null, 9);
      break;
    default:
      break;
  }
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_AppendIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_AppendIterator
Variant c_AppendIterator::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_AppendIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_AppendIterator
Variant &c_AppendIterator::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_AppendIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_AppendIterator
Variant * c_AppendIterator::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  CStrRef s = context.isNull() ? FrameInjection::GetClassName(false) : context;
  int64 hash = s->hash();
  switch (hash & 1) {
    case 0:
      HASH_GUARD_STRING(0x2E363D51549781C8LL, AppendIterator) { return o_realPropPrivate(prop, flags); }
      break;
    default:
      break;
  }
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_AppendIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_AppendIterator
Variant * c_AppendIterator::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_AppendIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_AppendIterator
Variant * c_AppendIterator::o_realPropPrivate(CStrRef s, int flags) const {
  int64 hash = s->hash();
  switch (hash & 1) {
    case 1:
      HASH_REALPROP_NAMSTR(0x60EA38C41F14FF71LL, NAMSTR(s_sys_ssd4af8244, "iterators"), 9, iterators);
      break;
    default:
      break;
  }
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_AppendIterator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_AppendIterator
Variant c_AppendIterator::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_AppendIterator
IMPLEMENT_CLASS_NO_DEFAULT_SWEEP(AppendIterator)
bool c_AppendIterator::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 7) {
    case 0:
      HASH_INSTANCEOF(0x2E363D51549781C8LL, NAMSTR(s_sys_ss0fad9ac4, "AppendIterator"));
      break;
    case 1:
      HASH_INSTANCEOF(0x66679538C5E6F0A1LL, NAMSTR(s_sys_ss22bfe43e, "Traversable"));
      break;
    case 5:
      HASH_INSTANCEOF(0x39CA0210AC8E528DLL, NAMSTR(s_sys_ss299bd55e, "OuterIterator"));
      break;
    case 6:
      HASH_INSTANCEOF(0x0636A5F84AF9D29ELL, NAMSTR(s_sys_ssc64ebfff, "Iterator"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_AppendIterator::cloneImpl() {
  ObjectData *obj = coo_AppendIterator();
  c_AppendIterator::cloneSet(obj);
  return obj;
}
void c_AppendIterator::cloneSet(ObjectData *cl) {
  c_AppendIterator *clone = static_cast<c_AppendIterator*>(cl);
  ObjectData::cloneSet(clone);
  clone->m_iterators.setWithRef(m_iterators);
}
Variant c_AppendIterator::doCall(Variant v_name, Variant v_arguments, bool fatal) {
  return t___call(v_name, !v_arguments.isNull() ? v_arguments : Variant(Array::Create()));
}
CallInfo c_AppendIterator::ci_next((void*)&c_AppendIterator::i_next, (void*)&c_AppendIterator::ifa_next, 0, 4, 0x0000000000000000LL);
CallInfo c_AppendIterator::ci_key((void*)&c_AppendIterator::i_key, (void*)&c_AppendIterator::ifa_key, 0, 4, 0x0000000000000000LL);
CallInfo c_AppendIterator::ci_valid((void*)&c_AppendIterator::i_valid, (void*)&c_AppendIterator::ifa_valid, 0, 4, 0x0000000000000000LL);
CallInfo c_AppendIterator::ci_getinneriterator((void*)&c_AppendIterator::i_getinneriterator, (void*)&c_AppendIterator::ifa_getinneriterator, 0, 4, 0x0000000000000000LL);
CallInfo c_AppendIterator::ci_append((void*)&c_AppendIterator::i_append, (void*)&c_AppendIterator::ifa_append, 1, 4, 0x0000000000000000LL);
CallInfo c_AppendIterator::ci___construct((void*)&c_AppendIterator::i___construct, (void*)&c_AppendIterator::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_AppendIterator::ci_current((void*)&c_AppendIterator::i_current, (void*)&c_AppendIterator::ifa_current, 0, 4, 0x0000000000000000LL);
CallInfo c_AppendIterator::ci___call((void*)&c_AppendIterator::i___call, (void*)&c_AppendIterator::ifa___call, 2, 4, 0x0000000000000000LL);
CallInfo c_AppendIterator::ci_rewind((void*)&c_AppendIterator::i_rewind, (void*)&c_AppendIterator::ifa_rewind, 0, 4, 0x0000000000000000LL);
Variant c_AppendIterator::i_next(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_next, coo_AppendIterator);
  }
  c_AppendIterator *self ATTRIBUTE_UNUSED (static_cast<c_AppendIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("AppendIterator::next", 0, 1);
  return (self->t_next(), null);
}
Variant c_AppendIterator::i_key(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_key, coo_AppendIterator);
  }
  c_AppendIterator *self ATTRIBUTE_UNUSED (static_cast<c_AppendIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("AppendIterator::key", 0, 1);
  return (self->t_key());
}
Variant c_AppendIterator::i_valid(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_valid, coo_AppendIterator);
  }
  c_AppendIterator *self ATTRIBUTE_UNUSED (static_cast<c_AppendIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("AppendIterator::valid", 0, 1);
  return (self->t_valid());
}
Variant c_AppendIterator::i_getinneriterator(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_getinneriterator, coo_AppendIterator);
  }
  c_AppendIterator *self ATTRIBUTE_UNUSED (static_cast<c_AppendIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("AppendIterator::getInnerIterator", 0, 1);
  return (self->t_getinneriterator());
}
Variant c_AppendIterator::i_append(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_append, coo_AppendIterator);
  }
  c_AppendIterator *self ATTRIBUTE_UNUSED (static_cast<c_AppendIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count < 1)) return throw_missing_typed_argument("AppendIterator::append", "iterator", 1);
  if (UNLIKELY(count > 1)) return throw_toomany_arguments("AppendIterator::append", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_append(arg0), null);
  }
}
Variant c_AppendIterator::i___construct(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i___construct, coo_AppendIterator);
  }
  c_AppendIterator *self ATTRIBUTE_UNUSED (static_cast<c_AppendIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("AppendIterator::__construct", 0, 2);
  return (self->t___construct(), null);
}
Variant c_AppendIterator::i_current(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_current, coo_AppendIterator);
  }
  c_AppendIterator *self ATTRIBUTE_UNUSED (static_cast<c_AppendIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("AppendIterator::current", 0, 1);
  return (self->t_current());
}
Variant c_AppendIterator::i___call(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i___call, coo_AppendIterator);
  }
  c_AppendIterator *self ATTRIBUTE_UNUSED (static_cast<c_AppendIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count != 2)) return throw_wrong_arguments("AppendIterator::__call", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___call(arg0, arg1));
  }
}
Variant c_AppendIterator::i_rewind(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_rewind, coo_AppendIterator);
  }
  c_AppendIterator *self ATTRIBUTE_UNUSED (static_cast<c_AppendIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("AppendIterator::rewind", 0, 1);
  return (self->t_rewind(), null);
}
Variant c_AppendIterator::ifa_next(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_next, coo_AppendIterator);
  }
  c_AppendIterator *self ATTRIBUTE_UNUSED (static_cast<c_AppendIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("AppendIterator::next", 0, 1);
  return (self->t_next(), null);
}
Variant c_AppendIterator::ifa_key(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_key, coo_AppendIterator);
  }
  c_AppendIterator *self ATTRIBUTE_UNUSED (static_cast<c_AppendIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("AppendIterator::key", 0, 1);
  return (self->t_key());
}
Variant c_AppendIterator::ifa_valid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_valid, coo_AppendIterator);
  }
  c_AppendIterator *self ATTRIBUTE_UNUSED (static_cast<c_AppendIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("AppendIterator::valid", 0, 1);
  return (self->t_valid());
}
Variant c_AppendIterator::ifa_getinneriterator(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_getinneriterator, coo_AppendIterator);
  }
  c_AppendIterator *self ATTRIBUTE_UNUSED (static_cast<c_AppendIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("AppendIterator::getInnerIterator", 0, 1);
  return (self->t_getinneriterator());
}
Variant c_AppendIterator::ifa_append(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_append, coo_AppendIterator);
  }
  c_AppendIterator *self ATTRIBUTE_UNUSED (static_cast<c_AppendIterator*>(mcp.obj));
  if (UNLIKELY(count < 1)) return throw_missing_typed_argument("AppendIterator::append", "iterator", 1);
  if (UNLIKELY(count > 1)) return throw_toomany_arguments("AppendIterator::append", 1, 1);
  CVarRef arg0(a0);
  return (self->t_append(arg0), null);
}
Variant c_AppendIterator::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa___construct, coo_AppendIterator);
  }
  c_AppendIterator *self ATTRIBUTE_UNUSED (static_cast<c_AppendIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("AppendIterator::__construct", 0, 2);
  return (self->t___construct(), null);
}
Variant c_AppendIterator::ifa_current(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_current, coo_AppendIterator);
  }
  c_AppendIterator *self ATTRIBUTE_UNUSED (static_cast<c_AppendIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("AppendIterator::current", 0, 1);
  return (self->t_current());
}
Variant c_AppendIterator::ifa___call(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa___call, coo_AppendIterator);
  }
  c_AppendIterator *self ATTRIBUTE_UNUSED (static_cast<c_AppendIterator*>(mcp.obj));
  if (UNLIKELY(count != 2)) return throw_wrong_arguments("AppendIterator::__call", count, 2, 2, 1);
  CVarRef arg0(a0);
  CVarRef arg1(a1);
  return (self->t___call(arg0, arg1));
}
Variant c_AppendIterator::ifa_rewind(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_rewind, coo_AppendIterator);
  }
  c_AppendIterator *self ATTRIBUTE_UNUSED (static_cast<c_AppendIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("AppendIterator::rewind", 0, 1);
  return (self->t_rewind(), null);
}
const MethodCallInfoTable c_AppendIterator::s_call_info_table[] = {
  { 0x4DEE4A472DC69EC2LL, 1, 6, "append", &c_AppendIterator::ci_append },
  { 0x6413CB5154808C44LL, 1, 5, "valid", &c_AppendIterator::ci_valid },
  { 0x3106F858B09C7424LL, 0, 16, "getInnerIterator", &c_AppendIterator::ci_getinneriterator },
  { 0x1670096FDE27AF6ALL, 1, 6, "rewind", &c_AppendIterator::ci_rewind },
  { 0x5D73364F53CEEB6CLL, 1, 6, "__call", &c_AppendIterator::ci___call },
  { 0x56EDB60C824E8C51LL, 1, 3, "key", &c_AppendIterator::ci_key },
  { 0x3C6D50F3BB8102B8LL, 1, 4, "next", &c_AppendIterator::ci_next },
  { 0x5B3A4A72846B21DCLL, 1, 7, "current", &c_AppendIterator::ci_current },
  { 0x0D31D0AC229C615FLL, 1, 11, "__construct", &c_AppendIterator::ci___construct },
  { 0, 1, 0, 0 }
};
const int c_AppendIterator::s_call_info_index[] = {
  31,
  -1,-1,0,-1,1,-1,-1,-1,
  -1,-1,3,-1,4,-1,-1,-1,
  -1,5,-1,-1,-1,-1,-1,-1,
  6,-1,-1,-1,7,-1,-1,8,

};
c_AppendIterator *c_AppendIterator::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
void c_AppendIterator::dynConstruct(CArrRef params) {
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) throw_toomany_arguments("AppendIterator::__construct", 0, 2);
  (t___construct());
}
void c_AppendIterator::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_AppendIterator::ci___construct;
  mcp.obj = this;
}
ObjectStaticCallbacks cw_AppendIterator = {
  c_AppendIterator::os_getInit,
  c_AppendIterator::os_get,
  c_AppendIterator::os_lval,
  c_AppendIterator::os_invoke,
  c_AppendIterator::os_constant,
  (ObjectData*(*)(ObjectData*))coo_AppendIterator,
  c_AppendIterator::s_call_info_table,c_AppendIterator::s_call_info_index,
  &c_AppendIterator::s_class_name,
  0
};
/* SRC: classes/iterator.php line 799 */
void c_AppendIterator::t___construct() {
  INSTANCE_METHOD_INJECTION_BUILTIN(AppendIterator, AppendIterator::__construct);
  bool oldInCtor = gasInCtor(true);
  {
    const p_ArrayIterator &tmp0((p_ArrayIterator(((c_ArrayIterator*)coo_ArrayIterator())->create(s_sys_sa00000000))));
    m_iterators = tmp0;
  }
  gasInCtor(oldInCtor);
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 814 */
void c_AppendIterator::t_append(CVarRef v_it) {
  INSTANCE_METHOD_INJECTION_BUILTIN(AppendIterator, AppendIterator::append);
  if(!v_it.instanceof(NAMSTR(s_sys_ss2fd353cc, "iterator"))) {
    throw_unexpected_argument_type(1,"AppendIterator::append()","iterator",v_it);
    return;
  }
  {
    MethodCallPackage mcp0;
    CVarRef obj0 = m_iterators;
    mcp0.methodCall((obj0), NAMSTR(s_sys_ssba65d5ee, "append"), 0x4DEE4A472DC69EC2LL);
    const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
    (mcp0.bindClass(fi)->getMeth1Args())(mcp0, 1, v_it);
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 828 */
Variant c_AppendIterator::t_getinneriterator() {
  INSTANCE_METHOD_INJECTION_BUILTIN(AppendIterator, AppendIterator::getInnerIterator);
  {
    MethodCallPackage mcp0;
    CVarRef obj0 = m_iterators;
    mcp0.methodCall((obj0), NAMSTR(s_sys_ssb3a5c1b3, "current"), 0x5B3A4A72846B21DCLL);
    const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
    return wrap_variant((mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0));
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 842 */
void c_AppendIterator::t_rewind() {
  INSTANCE_METHOD_INJECTION_BUILTIN(AppendIterator, AppendIterator::rewind);
  {
    MethodCallPackage mcp0;
    CVarRef obj0 = m_iterators;
    mcp0.methodCall((obj0), NAMSTR(s_sys_ss941ca25f, "rewind"), 0x1670096FDE27AF6ALL);
    const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
    (mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0);
  }
  {
    bool tmp0;
    {
      MethodCallPackage mcp1;
      CVarRef obj1 = m_iterators;
      mcp1.methodCall((obj1), NAMSTR(s_sys_ss9943cbf4, "valid"), 0x6413CB5154808C44LL);
      const CallInfo *cit1 ATTRIBUTE_UNUSED = mcp1.ci;
      tmp0 = (toBoolean((mcp1.bindClass(fi)->getMeth0Args())(mcp1, 0)));
    }
    if (tmp0) {
      {
        {
          MethodCallPackage mcp1;
          mcp1.methodCall((GET_THIS_VALID()), NAMSTR(s_sys_ss37eff1c8, "getInnerIterator"), 0x3106F858B09C7424LL);
          const CallInfo *cit1 ATTRIBUTE_UNUSED = mcp1.ci;
          MethodCallPackage mcp0;
          CVarRef obj0 = (mcp1.bindClass(fi)->getMeth0Args())(mcp1, 0);
          mcp0.methodCall((obj0), NAMSTR(s_sys_ss941ca25f, "rewind"), 0x1670096FDE27AF6ALL);
          const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
          (mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0);
        }
      }
    }
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 858 */
bool c_AppendIterator::t_valid() {
  INSTANCE_METHOD_INJECTION_BUILTIN(AppendIterator, AppendIterator::valid);
  {
    MethodCallPackage mcp0;
    CVarRef obj0 = m_iterators;
    mcp0.methodCall((obj0), NAMSTR(s_sys_ss9943cbf4, "valid"), 0x6413CB5154808C44LL);
    const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
    bool tmp1 = (toBoolean((mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0)));
    if (tmp1) {
      MethodCallPackage mcp3;
      mcp3.methodCall((GET_THIS_VALID()), NAMSTR(s_sys_ss37eff1c8, "getInnerIterator"), 0x3106F858B09C7424LL);
      const CallInfo *cit3 ATTRIBUTE_UNUSED = mcp3.ci;
      MethodCallPackage mcp2;
      CVarRef obj2 = (mcp3.bindClass(fi)->getMeth0Args())(mcp3, 0);
      mcp2.methodCall((obj2), NAMSTR(s_sys_ss9943cbf4, "valid"), 0x6413CB5154808C44LL);
      const CallInfo *cit2 ATTRIBUTE_UNUSED = mcp2.ci;
      tmp1 = (toBoolean((mcp2.bindClass(fi)->getMeth0Args())(mcp2, 0)));
    }
    return tmp1;
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 871 */
Variant c_AppendIterator::t_current() {
  INSTANCE_METHOD_INJECTION_BUILTIN(AppendIterator, AppendIterator::current);
  {
    MethodCallPackage mcp0;
    CVarRef obj0 = m_iterators;
    mcp0.methodCall((obj0), NAMSTR(s_sys_ss9943cbf4, "valid"), 0x6413CB5154808C44LL);
    const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
    Variant tmp1;
    if (toBoolean((mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0))) {
      MethodCallPackage mcp3;
      mcp3.methodCall((GET_THIS_VALID()), NAMSTR(s_sys_ss37eff1c8, "getInnerIterator"), 0x3106F858B09C7424LL);
      const CallInfo *cit3 ATTRIBUTE_UNUSED = mcp3.ci;
      MethodCallPackage mcp2;
      CVarRef obj2 = (mcp3.bindClass(fi)->getMeth0Args())(mcp3, 0);
      mcp2.methodCall((obj2), NAMSTR(s_sys_ssb3a5c1b3, "current"), 0x5B3A4A72846B21DCLL);
      const CallInfo *cit2 ATTRIBUTE_UNUSED = mcp2.ci;
      tmp1 = ((mcp2.bindClass(fi)->getMeth0Args())(mcp2, 0));
    } else {
      tmp1 = (null);
    }
    return tmp1;
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 889 */
Variant c_AppendIterator::t_key() {
  INSTANCE_METHOD_INJECTION_BUILTIN(AppendIterator, AppendIterator::key);
  {
    MethodCallPackage mcp0;
    CVarRef obj0 = m_iterators;
    mcp0.methodCall((obj0), NAMSTR(s_sys_ss9943cbf4, "valid"), 0x6413CB5154808C44LL);
    const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
    Variant tmp1;
    if (toBoolean((mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0))) {
      MethodCallPackage mcp3;
      mcp3.methodCall((GET_THIS_VALID()), NAMSTR(s_sys_ss37eff1c8, "getInnerIterator"), 0x3106F858B09C7424LL);
      const CallInfo *cit3 ATTRIBUTE_UNUSED = mcp3.ci;
      MethodCallPackage mcp2;
      CVarRef obj2 = (mcp3.bindClass(fi)->getMeth0Args())(mcp3, 0);
      mcp2.methodCall((obj2), NAMSTR(s_sys_ss12e90587, "key"), 0x56EDB60C824E8C51LL);
      const CallInfo *cit2 ATTRIBUTE_UNUSED = mcp2.ci;
      tmp1 = ((mcp2.bindClass(fi)->getMeth0Args())(mcp2, 0));
    } else {
      tmp1 = (null);
    }
    return tmp1;
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 903 */
void c_AppendIterator::t_next() {
  INSTANCE_METHOD_INJECTION_BUILTIN(AppendIterator, AppendIterator::next);
  {
    bool tmp0;
    {
      MethodCallPackage mcp1;
      CVarRef obj1 = m_iterators;
      mcp1.methodCall((obj1), NAMSTR(s_sys_ss9943cbf4, "valid"), 0x6413CB5154808C44LL);
      const CallInfo *cit1 ATTRIBUTE_UNUSED = mcp1.ci;
      tmp0 = (!(toBoolean((mcp1.bindClass(fi)->getMeth0Args())(mcp1, 0))));
    }
    if (tmp0) {
      {
        return;
      }
    }
  }
  {
    MethodCallPackage mcp1;
    mcp1.methodCall((GET_THIS_VALID()), NAMSTR(s_sys_ss37eff1c8, "getInnerIterator"), 0x3106F858B09C7424LL);
    const CallInfo *cit1 ATTRIBUTE_UNUSED = mcp1.ci;
    MethodCallPackage mcp0;
    CVarRef obj0 = (mcp1.bindClass(fi)->getMeth0Args())(mcp1, 0);
    mcp0.methodCall((obj0), NAMSTR(s_sys_ss50652d33, "next"), 0x3C6D50F3BB8102B8LL);
    const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
    (mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0);
  }
  {
    bool tmp0;
    {
      MethodCallPackage mcp2;
      mcp2.methodCall((GET_THIS_VALID()), NAMSTR(s_sys_ss37eff1c8, "getInnerIterator"), 0x3106F858B09C7424LL);
      const CallInfo *cit2 ATTRIBUTE_UNUSED = mcp2.ci;
      MethodCallPackage mcp1;
      CVarRef obj1 = (mcp2.bindClass(fi)->getMeth0Args())(mcp2, 0);
      mcp1.methodCall((obj1), NAMSTR(s_sys_ss9943cbf4, "valid"), 0x6413CB5154808C44LL);
      const CallInfo *cit1 ATTRIBUTE_UNUSED = mcp1.ci;
      tmp0 = (toBoolean((mcp1.bindClass(fi)->getMeth0Args())(mcp1, 0)));
    }
    if (tmp0) {
      {
        return;
      }
    }
  }
  {
    MethodCallPackage mcp0;
    CVarRef obj0 = m_iterators;
    mcp0.methodCall((obj0), NAMSTR(s_sys_ss50652d33, "next"), 0x3C6D50F3BB8102B8LL);
    const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
    (mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0);
  }
  LOOP_COUNTER(1);
  {
    while (true) {
      {
        MethodCallPackage mcp0;
        CVarRef obj0 = m_iterators;
        mcp0.methodCall((obj0), NAMSTR(s_sys_ss9943cbf4, "valid"), 0x6413CB5154808C44LL);
        const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
        if (!(toBoolean((mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0)))) break;
      }
      LOOP_COUNTER_CHECK(1);
      {
        {
          MethodCallPackage mcp1;
          mcp1.methodCall((GET_THIS_VALID()), NAMSTR(s_sys_ss37eff1c8, "getInnerIterator"), 0x3106F858B09C7424LL);
          const CallInfo *cit1 ATTRIBUTE_UNUSED = mcp1.ci;
          MethodCallPackage mcp0;
          CVarRef obj0 = (mcp1.bindClass(fi)->getMeth0Args())(mcp1, 0);
          mcp0.methodCall((obj0), NAMSTR(s_sys_ss941ca25f, "rewind"), 0x1670096FDE27AF6ALL);
          const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
          (mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0);
        }
        {
          bool tmp0;
          {
            MethodCallPackage mcp2;
            mcp2.methodCall((GET_THIS_VALID()), NAMSTR(s_sys_ss37eff1c8, "getInnerIterator"), 0x3106F858B09C7424LL);
            const CallInfo *cit2 ATTRIBUTE_UNUSED = mcp2.ci;
            MethodCallPackage mcp1;
            CVarRef obj1 = (mcp2.bindClass(fi)->getMeth0Args())(mcp2, 0);
            mcp1.methodCall((obj1), NAMSTR(s_sys_ss9943cbf4, "valid"), 0x6413CB5154808C44LL);
            const CallInfo *cit1 ATTRIBUTE_UNUSED = mcp1.ci;
            tmp0 = (toBoolean((mcp1.bindClass(fi)->getMeth0Args())(mcp1, 0)));
          }
          if (tmp0) {
            {
              return;
            }
          }
        }
        {
          MethodCallPackage mcp0;
          CVarRef obj0 = m_iterators;
          mcp0.methodCall((obj0), NAMSTR(s_sys_ss50652d33, "next"), 0x3C6D50F3BB8102B8LL);
          const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
          (mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0);
        }
      }
    }
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 921 */
Variant c_AppendIterator::t___call(Variant v_func, Variant v_params) {
  INSTANCE_METHOD_INJECTION_BUILTIN(AppendIterator, AppendIterator::__call);
  {
    ArrayInit tmp0(2);
    MethodCallPackage mcp1;
    mcp1.methodCall((GET_THIS_VALID()), NAMSTR(s_sys_ss37eff1c8, "getInnerIterator"), 0x3106F858B09C7424LL);
    const CallInfo *cit1 ATTRIBUTE_UNUSED = mcp1.ci;
    const Variant &tmp2(((mcp1.bindClass(fi)->getMeth0Args())(mcp1, 0)));
    tmp0.set(tmp2);
    tmp0.set(v_func);
    const Array &tmp3((Array(tmp0)));
    return x_call_user_func_array(VarNR(tmp3), toArray(v_params));
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 657 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_IteratorIterator
Variant c_IteratorIterator::os_getInit(CStrRef s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = s->hash();
  switch (hash & 1) {
    case 0:
      HASH_RETURN_NAMSTR(0x0636A5F84AF9D29ELL, NAMSTR(s_sys_ss2fd353cc, "iterator"),
                         null, 8);
      break;
    default:
      break;
  }
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_IteratorIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_IteratorIterator
Variant c_IteratorIterator::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_IteratorIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_IteratorIterator
Variant &c_IteratorIterator::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_IteratorIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_IteratorIterator
Variant * c_IteratorIterator::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  CStrRef s = context.isNull() ? FrameInjection::GetClassName(false) : context;
  int64 hash = s->hash();
  switch (hash & 1) {
    case 0:
      HASH_GUARD_STRING(0x46D7EC2E443AFA34LL, IteratorIterator) { return o_realPropPrivate(prop, flags); }
      break;
    default:
      break;
  }
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_IteratorIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_IteratorIterator
Variant * c_IteratorIterator::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_IteratorIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_IteratorIterator
Variant * c_IteratorIterator::o_realPropPrivate(CStrRef s, int flags) const {
  int64 hash = s->hash();
  switch (hash & 1) {
    case 0:
      HASH_REALPROP_NAMSTR(0x0636A5F84AF9D29ELL, NAMSTR(s_sys_ss2fd353cc, "iterator"), 8, iterator);
      break;
    default:
      break;
  }
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_IteratorIterator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_IteratorIterator
Variant c_IteratorIterator::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_IteratorIterator
IMPLEMENT_CLASS_NO_DEFAULT_SWEEP(IteratorIterator)
bool c_IteratorIterator::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 7) {
    case 1:
      HASH_INSTANCEOF(0x66679538C5E6F0A1LL, NAMSTR(s_sys_ss22bfe43e, "Traversable"));
      break;
    case 4:
      HASH_INSTANCEOF(0x46D7EC2E443AFA34LL, NAMSTR(s_sys_ss5a365068, "IteratorIterator"));
      break;
    case 5:
      HASH_INSTANCEOF(0x39CA0210AC8E528DLL, NAMSTR(s_sys_ss299bd55e, "OuterIterator"));
      break;
    case 6:
      HASH_INSTANCEOF(0x0636A5F84AF9D29ELL, NAMSTR(s_sys_ssc64ebfff, "Iterator"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_IteratorIterator::cloneImpl() {
  ObjectData *obj = coo_IteratorIterator();
  c_IteratorIterator::cloneSet(obj);
  return obj;
}
void c_IteratorIterator::cloneSet(ObjectData *cl) {
  c_IteratorIterator *clone = static_cast<c_IteratorIterator*>(cl);
  ObjectData::cloneSet(clone);
  clone->m_iterator.setWithRef(m_iterator);
}
Variant c_IteratorIterator::doCall(Variant v_name, Variant v_arguments, bool fatal) {
  return t___call(v_name, !v_arguments.isNull() ? v_arguments : Variant(Array::Create()));
}
CallInfo c_IteratorIterator::ci_next((void*)&c_IteratorIterator::i_next, (void*)&c_IteratorIterator::ifa_next, 0, 4, 0x0000000000000000LL);
CallInfo c_IteratorIterator::ci_key((void*)&c_IteratorIterator::i_key, (void*)&c_IteratorIterator::ifa_key, 0, 4, 0x0000000000000000LL);
CallInfo c_IteratorIterator::ci_valid((void*)&c_IteratorIterator::i_valid, (void*)&c_IteratorIterator::ifa_valid, 0, 4, 0x0000000000000000LL);
CallInfo c_IteratorIterator::ci_getinneriterator((void*)&c_IteratorIterator::i_getinneriterator, (void*)&c_IteratorIterator::ifa_getinneriterator, 0, 4, 0x0000000000000000LL);
CallInfo c_IteratorIterator::ci___construct((void*)&c_IteratorIterator::i___construct, (void*)&c_IteratorIterator::ifa___construct, 1, 4, 0x0000000000000000LL);
CallInfo c_IteratorIterator::ci_current((void*)&c_IteratorIterator::i_current, (void*)&c_IteratorIterator::ifa_current, 0, 4, 0x0000000000000000LL);
CallInfo c_IteratorIterator::ci___call((void*)&c_IteratorIterator::i___call, (void*)&c_IteratorIterator::ifa___call, 2, 4, 0x0000000000000000LL);
CallInfo c_IteratorIterator::ci_rewind((void*)&c_IteratorIterator::i_rewind, (void*)&c_IteratorIterator::ifa_rewind, 0, 4, 0x0000000000000000LL);
Variant c_IteratorIterator::i_next(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_next, coo_IteratorIterator);
  }
  c_IteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_IteratorIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("IteratorIterator::next", 0, 1);
  return (self->t_next());
}
Variant c_IteratorIterator::i_key(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_key, coo_IteratorIterator);
  }
  c_IteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_IteratorIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("IteratorIterator::key", 0, 1);
  return (self->t_key());
}
Variant c_IteratorIterator::i_valid(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_valid, coo_IteratorIterator);
  }
  c_IteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_IteratorIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("IteratorIterator::valid", 0, 1);
  return (self->t_valid());
}
Variant c_IteratorIterator::i_getinneriterator(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_getinneriterator, coo_IteratorIterator);
  }
  c_IteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_IteratorIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("IteratorIterator::getInnerIterator", 0, 1);
  return (self->t_getinneriterator());
}
Variant c_IteratorIterator::i___construct(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i___construct, coo_IteratorIterator);
  }
  c_IteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_IteratorIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count < 1)) return throw_missing_typed_argument("IteratorIterator::__construct", "traversable", 1);
  if (UNLIKELY(count > 1)) return throw_toomany_arguments("IteratorIterator::__construct", 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___construct(arg0), null);
  }
}
Variant c_IteratorIterator::i_current(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_current, coo_IteratorIterator);
  }
  c_IteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_IteratorIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("IteratorIterator::current", 0, 1);
  return (self->t_current());
}
Variant c_IteratorIterator::i___call(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i___call, coo_IteratorIterator);
  }
  c_IteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_IteratorIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count != 2)) return throw_wrong_arguments("IteratorIterator::__call", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___call(arg0, arg1));
  }
}
Variant c_IteratorIterator::i_rewind(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_rewind, coo_IteratorIterator);
  }
  c_IteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_IteratorIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("IteratorIterator::rewind", 0, 1);
  return (self->t_rewind());
}
Variant c_IteratorIterator::ifa_next(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_next, coo_IteratorIterator);
  }
  c_IteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_IteratorIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("IteratorIterator::next", 0, 1);
  return (self->t_next());
}
Variant c_IteratorIterator::ifa_key(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_key, coo_IteratorIterator);
  }
  c_IteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_IteratorIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("IteratorIterator::key", 0, 1);
  return (self->t_key());
}
Variant c_IteratorIterator::ifa_valid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_valid, coo_IteratorIterator);
  }
  c_IteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_IteratorIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("IteratorIterator::valid", 0, 1);
  return (self->t_valid());
}
Variant c_IteratorIterator::ifa_getinneriterator(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_getinneriterator, coo_IteratorIterator);
  }
  c_IteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_IteratorIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("IteratorIterator::getInnerIterator", 0, 1);
  return (self->t_getinneriterator());
}
Variant c_IteratorIterator::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa___construct, coo_IteratorIterator);
  }
  c_IteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_IteratorIterator*>(mcp.obj));
  if (UNLIKELY(count < 1)) return throw_missing_typed_argument("IteratorIterator::__construct", "traversable", 1);
  if (UNLIKELY(count > 1)) return throw_toomany_arguments("IteratorIterator::__construct", 1, 2);
  CVarRef arg0(a0);
  return (self->t___construct(arg0), null);
}
Variant c_IteratorIterator::ifa_current(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_current, coo_IteratorIterator);
  }
  c_IteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_IteratorIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("IteratorIterator::current", 0, 1);
  return (self->t_current());
}
Variant c_IteratorIterator::ifa___call(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa___call, coo_IteratorIterator);
  }
  c_IteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_IteratorIterator*>(mcp.obj));
  if (UNLIKELY(count != 2)) return throw_wrong_arguments("IteratorIterator::__call", count, 2, 2, 1);
  CVarRef arg0(a0);
  CVarRef arg1(a1);
  return (self->t___call(arg0, arg1));
}
Variant c_IteratorIterator::ifa_rewind(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_rewind, coo_IteratorIterator);
  }
  c_IteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_IteratorIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("IteratorIterator::rewind", 0, 1);
  return (self->t_rewind());
}
const MethodCallInfoTable c_IteratorIterator::s_call_info_table[] = {
  { 0x56EDB60C824E8C51LL, 1, 3, "key", &c_IteratorIterator::ci_key },
  { 0x6413CB5154808C44LL, 1, 5, "valid", &c_IteratorIterator::ci_valid },
  { 0x3106F858B09C7424LL, 0, 16, "getInnerIterator", &c_IteratorIterator::ci_getinneriterator },
  { 0x3C6D50F3BB8102B8LL, 1, 4, "next", &c_IteratorIterator::ci_next },
  { 0x1670096FDE27AF6ALL, 1, 6, "rewind", &c_IteratorIterator::ci_rewind },
  { 0x5B3A4A72846B21DCLL, 1, 7, "current", &c_IteratorIterator::ci_current },
  { 0x5D73364F53CEEB6CLL, 0, 6, "__call", &c_IteratorIterator::ci___call },
  { 0x0D31D0AC229C615FLL, 1, 11, "__construct", &c_IteratorIterator::ci___construct },
  { 0, 1, 0, 0 }
};
const int c_IteratorIterator::s_call_info_index[] = {
  15,
  -1,0,-1,-1,1,-1,-1,-1,
  3,-1,4,-1,5,-1,-1,7,

};
c_IteratorIterator *c_IteratorIterator::create(CVarRef v_iterator) {
  CountableHelper h(this);
  init();
  t___construct(v_iterator);
  return this;
}
void c_IteratorIterator::dynConstruct(CArrRef params) {
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count < 1)) throw_missing_typed_argument("IteratorIterator::__construct", "traversable", 1);
  if (UNLIKELY(count != 1)) throw_wrong_arguments("IteratorIterator::__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_IteratorIterator::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_IteratorIterator::ci___construct;
  mcp.obj = this;
}
ObjectStaticCallbacks cw_IteratorIterator = {
  c_IteratorIterator::os_getInit,
  c_IteratorIterator::os_get,
  c_IteratorIterator::os_lval,
  c_IteratorIterator::os_invoke,
  c_IteratorIterator::os_constant,
  (ObjectData*(*)(ObjectData*))coo_IteratorIterator,
  c_IteratorIterator::s_call_info_table,c_IteratorIterator::s_call_info_index,
  &c_IteratorIterator::s_class_name,
  0
};
/* SRC: classes/iterator.php line 660 */
void c_IteratorIterator::t___construct(Variant v_iterator) {
  INSTANCE_METHOD_INJECTION_BUILTIN(IteratorIterator, IteratorIterator::__construct);
  bool oldInCtor = gasInCtor(true);
  if(!v_iterator.instanceof(NAMSTR(s_sys_ssa38f312b, "traversable"))) {
    throw_unexpected_argument_type(1,"IteratorIterator::__construct()","traversable",v_iterator);
    return;
  }
  if (instanceOf(v_iterator, NAMSTR(s_sys_ssa04330ec, "IteratorAggregate"))) {
    {
      {
        MethodCallPackage mcp0;
        CVarRef obj0 = v_iterator;
        mcp0.methodCall((obj0), NAMSTR(s_sys_ssfe98adf4, "getIterator"), 0x570B2E1232A12503LL);
        const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
        Variant tmp1(((mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0)));
        v_iterator.assignVal(tmp1);
      }
    }
  }
  if (instanceOf(v_iterator, NAMSTR(s_sys_ssc64ebfff, "Iterator"))) {
    {
      m_iterator.assignVal(v_iterator);
    }
  }
  else {
    {
      throw_exception(p_Exception(((c_Exception*)coo_Exception())->create(NAMSTR(s_sys_ss93bb6e5b, "Need to pass a Traversable that is convertable to an iterator"))));
    }
  }
  gasInCtor(oldInCtor);
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 672 */
Variant c_IteratorIterator::t_getinneriterator() {
  INSTANCE_METHOD_INJECTION_BUILTIN(IteratorIterator, IteratorIterator::getInnerIterator);
  return m_iterator;
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 676 */
Variant c_IteratorIterator::t_valid() {
  INSTANCE_METHOD_INJECTION_BUILTIN(IteratorIterator, IteratorIterator::valid);
  {
    MethodCallPackage mcp0;
    CVarRef obj0 = m_iterator;
    mcp0.methodCall((obj0), NAMSTR(s_sys_ss9943cbf4, "valid"), 0x6413CB5154808C44LL);
    const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
    return wrap_variant((mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0));
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 680 */
Variant c_IteratorIterator::t_key() {
  INSTANCE_METHOD_INJECTION_BUILTIN(IteratorIterator, IteratorIterator::key);
  {
    MethodCallPackage mcp0;
    CVarRef obj0 = m_iterator;
    mcp0.methodCall((obj0), NAMSTR(s_sys_ss12e90587, "key"), 0x56EDB60C824E8C51LL);
    const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
    return wrap_variant((mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0));
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 684 */
Variant c_IteratorIterator::t_current() {
  INSTANCE_METHOD_INJECTION_BUILTIN(IteratorIterator, IteratorIterator::current);
  {
    MethodCallPackage mcp0;
    CVarRef obj0 = m_iterator;
    mcp0.methodCall((obj0), NAMSTR(s_sys_ssb3a5c1b3, "current"), 0x5B3A4A72846B21DCLL);
    const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
    return wrap_variant((mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0));
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 688 */
Variant c_IteratorIterator::t_next() {
  INSTANCE_METHOD_INJECTION_BUILTIN(IteratorIterator, IteratorIterator::next);
  {
    MethodCallPackage mcp0;
    CVarRef obj0 = m_iterator;
    mcp0.methodCall((obj0), NAMSTR(s_sys_ss50652d33, "next"), 0x3C6D50F3BB8102B8LL);
    const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
    return wrap_variant((mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0));
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 692 */
Variant c_IteratorIterator::t_rewind() {
  INSTANCE_METHOD_INJECTION_BUILTIN(IteratorIterator, IteratorIterator::rewind);
  {
    MethodCallPackage mcp0;
    CVarRef obj0 = m_iterator;
    mcp0.methodCall((obj0), NAMSTR(s_sys_ss941ca25f, "rewind"), 0x1670096FDE27AF6ALL);
    const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
    return wrap_variant((mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0));
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 696 */
Variant c_IteratorIterator::t___call(Variant v_func, Variant v_params) {
  INSTANCE_METHOD_INJECTION_BUILTIN(IteratorIterator, IteratorIterator::__call);
  return x_call_user_func_array(VarNR(Array(ArrayInit(2).set(m_iterator).set(v_func).create())), toArray(v_params));
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 228 */
const int64 q_RecursiveIteratorIterator_LEAVES_ONLY = 0LL;
const int64 q_RecursiveIteratorIterator_SELF_FIRST = 1LL;
const int64 q_RecursiveIteratorIterator_CHILD_FIRST = 2LL;
const int64 q_RecursiveIteratorIterator_CATCH_GET_CHILD = 16LL;
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_RecursiveIteratorIterator
Variant c_RecursiveIteratorIterator::os_getInit(CStrRef s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = s->hash();
  switch (hash & 1) {
    case 1:
      HASH_RETURN_NAMSTR(0x26C16E62FD792BB7LL, NAMSTR(s_sys_ss7f14ba70, "rsrc"),
                         null, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_RecursiveIteratorIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_RecursiveIteratorIterator
Variant c_RecursiveIteratorIterator::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_RecursiveIteratorIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_RecursiveIteratorIterator
Variant &c_RecursiveIteratorIterator::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_RecursiveIteratorIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_RecursiveIteratorIterator
Variant * c_RecursiveIteratorIterator::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  CStrRef s = context.isNull() ? FrameInjection::GetClassName(false) : context;
  int64 hash = s->hash();
  switch (hash & 1) {
    case 0:
      HASH_GUARD_STRING(0x365899865E2EAA32LL, RecursiveIteratorIterator) { return o_realPropPrivate(prop, flags); }
      break;
    default:
      break;
  }
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_RecursiveIteratorIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_RecursiveIteratorIterator
Variant * c_RecursiveIteratorIterator::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_RecursiveIteratorIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_RecursiveIteratorIterator
Variant * c_RecursiveIteratorIterator::o_realPropPrivate(CStrRef s, int flags) const {
  int64 hash = s->hash();
  switch (hash & 1) {
    case 1:
      HASH_REALPROP_NAMSTR(0x26C16E62FD792BB7LL, NAMSTR(s_sys_ss7f14ba70, "rsrc"), 4, rsrc);
      break;
    default:
      break;
  }
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_RecursiveIteratorIterator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_RecursiveIteratorIterator
Variant c_RecursiveIteratorIterator::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 7) {
    case 1:
      HASH_RETURN(0x618BE0B31B5C1FD1LL, q_RecursiveIteratorIterator_CHILD_FIRST, "CHILD_FIRST");
      break;
    case 4:
      HASH_RETURN(0x181DAA5BC4B24F6CLL, q_RecursiveIteratorIterator_LEAVES_ONLY, "LEAVES_ONLY");
      HASH_RETURN(0x7F32D13555655AA4LL, q_RecursiveIteratorIterator_CATCH_GET_CHILD, "CATCH_GET_CHILD");
      break;
    case 5:
      HASH_RETURN(0x0822A034E83D2285LL, q_RecursiveIteratorIterator_SELF_FIRST, "SELF_FIRST");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_RecursiveIteratorIterator
IMPLEMENT_CLASS_NO_DEFAULT_SWEEP(RecursiveIteratorIterator)
bool c_RecursiveIteratorIterator::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 7) {
    case 1:
      HASH_INSTANCEOF(0x66679538C5E6F0A1LL, NAMSTR(s_sys_ss22bfe43e, "Traversable"));
      break;
    case 2:
      HASH_INSTANCEOF(0x365899865E2EAA32LL, NAMSTR(s_sys_ssc57472df, "RecursiveIteratorIterator"));
      break;
    case 5:
      HASH_INSTANCEOF(0x39CA0210AC8E528DLL, NAMSTR(s_sys_ss299bd55e, "OuterIterator"));
      break;
    case 6:
      HASH_INSTANCEOF(0x0636A5F84AF9D29ELL, NAMSTR(s_sys_ssc64ebfff, "Iterator"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_RecursiveIteratorIterator::cloneImpl() {
  ObjectData *obj = coo_RecursiveIteratorIterator();
  c_RecursiveIteratorIterator::cloneSet(obj);
  return obj;
}
void c_RecursiveIteratorIterator::cloneSet(ObjectData *cl) {
  c_RecursiveIteratorIterator *clone = static_cast<c_RecursiveIteratorIterator*>(cl);
  ObjectData::cloneSet(clone);
  clone->m_rsrc.setWithRef(m_rsrc);
}
CallInfo c_RecursiveIteratorIterator::ci_next((void*)&c_RecursiveIteratorIterator::i_next, (void*)&c_RecursiveIteratorIterator::ifa_next, 0, 4, 0x0000000000000000LL);
CallInfo c_RecursiveIteratorIterator::ci_key((void*)&c_RecursiveIteratorIterator::i_key, (void*)&c_RecursiveIteratorIterator::ifa_key, 0, 4, 0x0000000000000000LL);
CallInfo c_RecursiveIteratorIterator::ci_valid((void*)&c_RecursiveIteratorIterator::i_valid, (void*)&c_RecursiveIteratorIterator::ifa_valid, 0, 4, 0x0000000000000000LL);
CallInfo c_RecursiveIteratorIterator::ci_getinneriterator((void*)&c_RecursiveIteratorIterator::i_getinneriterator, (void*)&c_RecursiveIteratorIterator::ifa_getinneriterator, 0, 4, 0x0000000000000000LL);
CallInfo c_RecursiveIteratorIterator::ci___construct((void*)&c_RecursiveIteratorIterator::i___construct, (void*)&c_RecursiveIteratorIterator::ifa___construct, 3, 4, 0x0000000000000000LL);
CallInfo c_RecursiveIteratorIterator::ci_current((void*)&c_RecursiveIteratorIterator::i_current, (void*)&c_RecursiveIteratorIterator::ifa_current, 0, 4, 0x0000000000000000LL);
CallInfo c_RecursiveIteratorIterator::ci_rewind((void*)&c_RecursiveIteratorIterator::i_rewind, (void*)&c_RecursiveIteratorIterator::ifa_rewind, 0, 4, 0x0000000000000000LL);
Variant c_RecursiveIteratorIterator::i_next(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_next, coo_RecursiveIteratorIterator);
  }
  c_RecursiveIteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_RecursiveIteratorIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("RecursiveIteratorIterator::next", 0, 1);
  return (self->t_next(), null);
}
Variant c_RecursiveIteratorIterator::i_key(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_key, coo_RecursiveIteratorIterator);
  }
  c_RecursiveIteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_RecursiveIteratorIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("RecursiveIteratorIterator::key", 0, 1);
  return (self->t_key());
}
Variant c_RecursiveIteratorIterator::i_valid(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_valid, coo_RecursiveIteratorIterator);
  }
  c_RecursiveIteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_RecursiveIteratorIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("RecursiveIteratorIterator::valid", 0, 1);
  return (self->t_valid());
}
Variant c_RecursiveIteratorIterator::i_getinneriterator(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_getinneriterator, coo_RecursiveIteratorIterator);
  }
  c_RecursiveIteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_RecursiveIteratorIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("RecursiveIteratorIterator::getInnerIterator", 0, 1);
  return (self->t_getinneriterator());
}
Variant c_RecursiveIteratorIterator::i___construct(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i___construct, coo_RecursiveIteratorIterator);
  }
  c_RecursiveIteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_RecursiveIteratorIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count < 1 || count > 3)) return throw_wrong_arguments("RecursiveIteratorIterator::__construct", count, 1, 3, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t___construct(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1, arg2), null);
  }
}
Variant c_RecursiveIteratorIterator::i_current(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_current, coo_RecursiveIteratorIterator);
  }
  c_RecursiveIteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_RecursiveIteratorIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("RecursiveIteratorIterator::current", 0, 1);
  return (self->t_current());
}
Variant c_RecursiveIteratorIterator::i_rewind(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_rewind, coo_RecursiveIteratorIterator);
  }
  c_RecursiveIteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_RecursiveIteratorIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("RecursiveIteratorIterator::rewind", 0, 1);
  return (self->t_rewind(), null);
}
Variant c_RecursiveIteratorIterator::ifa_next(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_next, coo_RecursiveIteratorIterator);
  }
  c_RecursiveIteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_RecursiveIteratorIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("RecursiveIteratorIterator::next", 0, 1);
  return (self->t_next(), null);
}
Variant c_RecursiveIteratorIterator::ifa_key(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_key, coo_RecursiveIteratorIterator);
  }
  c_RecursiveIteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_RecursiveIteratorIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("RecursiveIteratorIterator::key", 0, 1);
  return (self->t_key());
}
Variant c_RecursiveIteratorIterator::ifa_valid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_valid, coo_RecursiveIteratorIterator);
  }
  c_RecursiveIteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_RecursiveIteratorIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("RecursiveIteratorIterator::valid", 0, 1);
  return (self->t_valid());
}
Variant c_RecursiveIteratorIterator::ifa_getinneriterator(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_getinneriterator, coo_RecursiveIteratorIterator);
  }
  c_RecursiveIteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_RecursiveIteratorIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("RecursiveIteratorIterator::getInnerIterator", 0, 1);
  return (self->t_getinneriterator());
}
Variant c_RecursiveIteratorIterator::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa___construct, coo_RecursiveIteratorIterator);
  }
  c_RecursiveIteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_RecursiveIteratorIterator*>(mcp.obj));
  if (UNLIKELY(count < 1 || count > 3)) return throw_wrong_arguments("RecursiveIteratorIterator::__construct", count, 1, 3, 2);
  CVarRef arg0(a0);
  if (count <= 1) return (self->t___construct(arg0), null);
  CVarRef arg1(a1);
  if (count <= 2) return (self->t___construct(arg0, arg1), null);
  CVarRef arg2(a2);
  return (self->t___construct(arg0, arg1, arg2), null);
}
Variant c_RecursiveIteratorIterator::ifa_current(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_current, coo_RecursiveIteratorIterator);
  }
  c_RecursiveIteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_RecursiveIteratorIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("RecursiveIteratorIterator::current", 0, 1);
  return (self->t_current());
}
Variant c_RecursiveIteratorIterator::ifa_rewind(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_rewind, coo_RecursiveIteratorIterator);
  }
  c_RecursiveIteratorIterator *self ATTRIBUTE_UNUSED (static_cast<c_RecursiveIteratorIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("RecursiveIteratorIterator::rewind", 0, 1);
  return (self->t_rewind(), null);
}
const MethodCallInfoTable c_RecursiveIteratorIterator::s_call_info_table[] = {
  { 0x56EDB60C824E8C51LL, 1, 3, "key", &c_RecursiveIteratorIterator::ci_key },
  { 0x6413CB5154808C44LL, 1, 5, "valid", &c_RecursiveIteratorIterator::ci_valid },
  { 0x3106F858B09C7424LL, 0, 16, "getInnerIterator", &c_RecursiveIteratorIterator::ci_getinneriterator },
  { 0x3C6D50F3BB8102B8LL, 1, 4, "next", &c_RecursiveIteratorIterator::ci_next },
  { 0x1670096FDE27AF6ALL, 1, 6, "rewind", &c_RecursiveIteratorIterator::ci_rewind },
  { 0x5B3A4A72846B21DCLL, 1, 7, "current", &c_RecursiveIteratorIterator::ci_current },
  { 0x0D31D0AC229C615FLL, 1, 11, "__construct", &c_RecursiveIteratorIterator::ci___construct },
  { 0, 1, 0, 0 }
};
const int c_RecursiveIteratorIterator::s_call_info_index[] = {
  15,
  -1,0,-1,-1,1,-1,-1,-1,
  3,-1,4,-1,5,-1,-1,6,

};
c_RecursiveIteratorIterator *c_RecursiveIteratorIterator::create(CVarRef v_iterator, CVarRef v_mode //  = NAMVAR(s_sys_svif01bca90, 0LL) /* RecursiveIteratorIterator::LEAVES_ONLY */
, CVarRef v_flags //  = NAMVAR(s_sys_svif01bca90, 0LL)
) {
  CountableHelper h(this);
  init();
  t___construct(v_iterator, v_mode, v_flags);
  return this;
}
void c_RecursiveIteratorIterator::dynConstruct(CArrRef params) {
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count < 1 || count > 3)) throw_wrong_arguments("RecursiveIteratorIterator::__construct", count, 1, 3, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2));
  } while (false);
}
void c_RecursiveIteratorIterator::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_RecursiveIteratorIterator::ci___construct;
  mcp.obj = this;
}
ObjectStaticCallbacks cw_RecursiveIteratorIterator = {
  c_RecursiveIteratorIterator::os_getInit,
  c_RecursiveIteratorIterator::os_get,
  c_RecursiveIteratorIterator::os_lval,
  c_RecursiveIteratorIterator::os_invoke,
  c_RecursiveIteratorIterator::os_constant,
  (ObjectData*(*)(ObjectData*))coo_RecursiveIteratorIterator,
  c_RecursiveIteratorIterator::s_call_info_table,c_RecursiveIteratorIterator::s_call_info_index,
  &c_RecursiveIteratorIterator::s_class_name,
  0
};
/* SRC: classes/iterator.php line 237 */
void c_RecursiveIteratorIterator::t___construct(Variant v_iterator, Variant v_mode //  = 0LL /* RecursiveIteratorIterator::LEAVES_ONLY */
, Variant v_flags //  = 0LL
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(RecursiveIteratorIterator, RecursiveIteratorIterator::__construct);
  bool oldInCtor = gasInCtor(true);
  x_hphp_recursiveiteratoriterator___construct(GET_THIS_TYPED(RecursiveIteratorIterator), toObject(v_iterator), toInt64(v_mode), toInt64(v_flags));
  gasInCtor(oldInCtor);
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 253 */
Object c_RecursiveIteratorIterator::t_getinneriterator() {
  INSTANCE_METHOD_INJECTION_BUILTIN(RecursiveIteratorIterator, RecursiveIteratorIterator::getInnerIterator);
  return x_hphp_recursiveiteratoriterator_getinneriterator(GET_THIS_TYPED(RecursiveIteratorIterator));
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 264 */
Variant c_RecursiveIteratorIterator::t_current() {
  INSTANCE_METHOD_INJECTION_BUILTIN(RecursiveIteratorIterator, RecursiveIteratorIterator::current);
  return x_hphp_recursiveiteratoriterator_current(GET_THIS_TYPED(RecursiveIteratorIterator));
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 275 */
Variant c_RecursiveIteratorIterator::t_key() {
  INSTANCE_METHOD_INJECTION_BUILTIN(RecursiveIteratorIterator, RecursiveIteratorIterator::key);
  return x_hphp_recursiveiteratoriterator_key(GET_THIS_TYPED(RecursiveIteratorIterator));
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 286 */
void c_RecursiveIteratorIterator::t_next() {
  INSTANCE_METHOD_INJECTION_BUILTIN(RecursiveIteratorIterator, RecursiveIteratorIterator::next);
  x_hphp_recursiveiteratoriterator_next(GET_THIS_TYPED(RecursiveIteratorIterator));
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 297 */
void c_RecursiveIteratorIterator::t_rewind() {
  INSTANCE_METHOD_INJECTION_BUILTIN(RecursiveIteratorIterator, RecursiveIteratorIterator::rewind);
  x_hphp_recursiveiteratoriterator_rewind(GET_THIS_TYPED(RecursiveIteratorIterator));
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 309 */
bool c_RecursiveIteratorIterator::t_valid() {
  INSTANCE_METHOD_INJECTION_BUILTIN(RecursiveIteratorIterator, RecursiveIteratorIterator::valid);
  return x_hphp_recursiveiteratoriterator_valid(GET_THIS_TYPED(RecursiveIteratorIterator));
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 644 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_MutableArrayIterator
Variant c_MutableArrayIterator::os_getInit(CStrRef s) {
  return c_ArrayIterator::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_MutableArrayIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_MutableArrayIterator
Variant c_MutableArrayIterator::os_get(CStrRef s) {
  return c_ArrayIterator::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_MutableArrayIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_MutableArrayIterator
Variant &c_MutableArrayIterator::os_lval(CStrRef s) {
  return c_ArrayIterator::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_MutableArrayIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_MutableArrayIterator
Variant * c_MutableArrayIterator::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_MutableArrayIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_MutableArrayIterator
Variant * c_MutableArrayIterator::o_realPropPublic(CStrRef s, int flags) const {
  return c_ArrayIterator::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_MutableArrayIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_MutableArrayIterator
Variant * c_MutableArrayIterator::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_MutableArrayIterator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_MutableArrayIterator
Variant c_MutableArrayIterator::os_constant(const char *s) {
  return c_ArrayIterator::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_MutableArrayIterator
IMPLEMENT_CLASS_NO_DEFAULT_SWEEP(MutableArrayIterator)
bool c_MutableArrayIterator::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 15) {
    case 1:
      HASH_INSTANCEOF(0x795F86375EE263D1LL, NAMSTR(s_sys_ss5b753b53, "Countable"));
      HASH_INSTANCEOF(0x66679538C5E6F0A1LL, NAMSTR(s_sys_ss22bfe43e, "Traversable"));
      break;
    case 3:
      HASH_INSTANCEOF(0x3D5870E53BF89873LL, NAMSTR(s_sys_ss993f2e69, "ArrayIterator"));
      HASH_INSTANCEOF(0x60C47E7FE145DC43LL, NAMSTR(s_sys_ssc1c38583, "SeekableIterator"));
      break;
    case 11:
      HASH_INSTANCEOF(0x3BDD11EABFCD6F0BLL, NAMSTR(s_sys_ss92306c9b, "ArrayAccess"));
      break;
    case 14:
      HASH_INSTANCEOF(0x0636A5F84AF9D29ELL, NAMSTR(s_sys_ssc64ebfff, "Iterator"));
      break;
    case 15:
      HASH_INSTANCEOF(0x5A1D16E68CA95F2FLL, NAMSTR(s_sys_ss337f2a0c, "MutableArrayIterator"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_MutableArrayIterator::cloneImpl() {
  ObjectData *obj = coo_MutableArrayIterator();
  c_MutableArrayIterator::cloneSet(obj);
  return obj;
}
void c_MutableArrayIterator::cloneSet(ObjectData *cl) {
  c_MutableArrayIterator *clone = static_cast<c_MutableArrayIterator*>(cl);
  c_ArrayIterator::cloneSet(clone);
}
CallInfo c_MutableArrayIterator::ci_currentref((void*)&c_MutableArrayIterator::i_currentref, (void*)&c_MutableArrayIterator::ifa_currentref, 0, 4, 0x0000000000000000LL);
CallInfo c_MutableArrayIterator::ci___construct((void*)&c_MutableArrayIterator::i___construct, (void*)&c_MutableArrayIterator::ifa___construct, 2, 4, 0x0000000000000001LL);
Variant c_MutableArrayIterator::i_currentref(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_currentref, coo_MutableArrayIterator);
  }
  c_MutableArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_MutableArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("MutableArrayIterator::currentRef", 0, 1);
  return strongBind(self->t_currentref());
}
Variant c_MutableArrayIterator::i___construct(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i___construct, coo_MutableArrayIterator);
  }
  c_MutableArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_MutableArrayIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count < 1 || count > 2)) return throw_wrong_arguments("MutableArrayIterator::__construct", count, 1, 2, 2);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    VRefParam arg0(vref(ad->getValueRef(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_MutableArrayIterator::ifa_currentref(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_currentref, coo_MutableArrayIterator);
  }
  c_MutableArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_MutableArrayIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("MutableArrayIterator::currentRef", 0, 1);
  return strongBind(self->t_currentref());
}
Variant c_MutableArrayIterator::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa___construct, coo_MutableArrayIterator);
  }
  c_MutableArrayIterator *self ATTRIBUTE_UNUSED (static_cast<c_MutableArrayIterator*>(mcp.obj));
  if (UNLIKELY(count < 1 || count > 2)) return throw_wrong_arguments("MutableArrayIterator::__construct", count, 1, 2, 2);
  VRefParam arg0(vref(a0));
  if (count <= 1) return (self->t___construct(arg0), null);
  CVarRef arg1(a1);
  return (self->t___construct(arg0, arg1), null);
}
const MethodCallInfoTable c_MutableArrayIterator::s_call_info_table[] = {
  { 0x06F242EC64EB2993LL, 1, 10, "currentRef", &c_MutableArrayIterator::ci_currentref },
  { 0x0D31D0AC229C615FLL, 0, 11, "__construct", &c_MutableArrayIterator::ci___construct },
  { 0, 1, 0, 0 }
};
const int c_MutableArrayIterator::s_call_info_index[] = {
  3,
  -1,-1,-1,0,
};
c_MutableArrayIterator *c_MutableArrayIterator::create(VRefParam v_array, CVarRef v_flags //  = NAMVAR(s_sys_svif01bca90, 0LL)
) {
  CountableHelper h(this);
  init();
  t___construct(v_array, v_flags);
  return this;
}
void c_MutableArrayIterator::dynConstruct(CArrRef params) {
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count < 1 || count > 2)) throw_wrong_arguments("MutableArrayIterator::__construct", count, 1, 2, 2);
  const_cast<Array&>(params).escalate(true);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    VRefParam arg0(vref(ad->getValueRef(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_MutableArrayIterator::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_MutableArrayIterator::ci___construct;
  mcp.obj = this;
}
ObjectStaticCallbacks cw_MutableArrayIterator = {
  c_MutableArrayIterator::os_getInit,
  c_MutableArrayIterator::os_get,
  c_MutableArrayIterator::os_lval,
  c_MutableArrayIterator::os_invoke,
  c_MutableArrayIterator::os_constant,
  (ObjectData*(*)(ObjectData*))coo_MutableArrayIterator,
  c_MutableArrayIterator::s_call_info_table,c_MutableArrayIterator::s_call_info_index,
  &c_MutableArrayIterator::s_class_name,
  &cw_ArrayIterator
};
/* SRC: classes/iterator.php line 645 */
void c_MutableArrayIterator::t___construct(VRefParam rv_array, Variant v_flags //  = 0LL
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(MutableArrayIterator, MutableArrayIterator::__construct);
  bool oldInCtor = gasInCtor(true);
  Variant &v_array ATTRIBUTE_UNUSED = rv_array;
  m_arr.assignRef(v_array);
  m_flags.assignVal(v_flags);
  x_reset(ref(m_arr));
  gasInCtor(oldInCtor);
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 651 */
Variant c_MutableArrayIterator::t_currentref() {
  INSTANCE_METHOD_INJECTION_BUILTIN(MutableArrayIterator, MutableArrayIterator::currentRef);
  return strongBind(x_hphp_current_ref(ref(m_arr)));
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 711 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_FilterIterator
Variant c_FilterIterator::os_getInit(CStrRef s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = s->hash();
  switch (hash & 1) {
    case 1:
      HASH_RETURN_NAMSTR(0x7794684C8B506749LL, NAMSTR(s_sys_ss6b9db86e, "it"),
                         null, 2);
      break;
    default:
      break;
  }
  return c_IteratorIterator::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_FilterIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_FilterIterator
Variant c_FilterIterator::os_get(CStrRef s) {
  return c_IteratorIterator::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_FilterIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_FilterIterator
Variant &c_FilterIterator::os_lval(CStrRef s) {
  return c_IteratorIterator::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_FilterIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_FilterIterator
Variant * c_FilterIterator::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  CStrRef s = context.isNull() ? FrameInjection::GetClassName(false) : context;
  int64 hash = s->hash();
  switch (hash & 3) {
    case 0:
      HASH_GUARD_STRING(0x46D7EC2E443AFA34LL, IteratorIterator) { return c_IteratorIterator::o_realPropPrivate(prop, flags); }
      break;
    case 1:
      HASH_GUARD_STRING(0x7A394042E7488231LL, FilterIterator) { return o_realPropPrivate(prop, flags); }
      break;
    default:
      break;
  }
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_FilterIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_FilterIterator
Variant * c_FilterIterator::o_realPropPublic(CStrRef s, int flags) const {
  return c_IteratorIterator::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_FilterIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_FilterIterator
Variant * c_FilterIterator::o_realPropPrivate(CStrRef s, int flags) const {
  int64 hash = s->hash();
  switch (hash & 1) {
    case 1:
      HASH_REALPROP_NAMSTR(0x7794684C8B506749LL, NAMSTR(s_sys_ss6b9db86e, "it"), 2, it);
      break;
    default:
      break;
  }
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_FilterIterator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_FilterIterator
Variant c_FilterIterator::os_constant(const char *s) {
  return c_IteratorIterator::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_FilterIterator
IMPLEMENT_CLASS_NO_DEFAULT_SWEEP(FilterIterator)
bool c_FilterIterator::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 15) {
    case 1:
      HASH_INSTANCEOF(0x7A394042E7488231LL, NAMSTR(s_sys_ss92c34a85, "FilterIterator"));
      HASH_INSTANCEOF(0x66679538C5E6F0A1LL, NAMSTR(s_sys_ss22bfe43e, "Traversable"));
      break;
    case 4:
      HASH_INSTANCEOF(0x46D7EC2E443AFA34LL, NAMSTR(s_sys_ss5a365068, "IteratorIterator"));
      break;
    case 13:
      HASH_INSTANCEOF(0x39CA0210AC8E528DLL, NAMSTR(s_sys_ss299bd55e, "OuterIterator"));
      break;
    case 14:
      HASH_INSTANCEOF(0x0636A5F84AF9D29ELL, NAMSTR(s_sys_ssc64ebfff, "Iterator"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_FilterIterator::cloneImpl() {
  ObjectData *obj = coo_FilterIterator();
  c_FilterIterator::cloneSet(obj);
  return obj;
}
void c_FilterIterator::cloneSet(ObjectData *cl) {
  c_FilterIterator *clone = static_cast<c_FilterIterator*>(cl);
  c_IteratorIterator::cloneSet(clone);
  clone->m_it.setWithRef(m_it);
}
Variant c_FilterIterator::doCall(Variant v_name, Variant v_arguments, bool fatal) {
  return t___call(v_name, !v_arguments.isNull() ? v_arguments : Variant(Array::Create()));
}
CallInfo c_FilterIterator::ci_next((void*)&c_FilterIterator::i_next, (void*)&c_FilterIterator::ifa_next, 0, 4, 0x0000000000000000LL);
CallInfo c_FilterIterator::ci_key((void*)&c_FilterIterator::i_key, (void*)&c_FilterIterator::ifa_key, 0, 4, 0x0000000000000000LL);
CallInfo c_FilterIterator::ci_valid((void*)&c_FilterIterator::i_valid, (void*)&c_FilterIterator::ifa_valid, 0, 4, 0x0000000000000000LL);
CallInfo c_FilterIterator::ci_getinneriterator((void*)&c_FilterIterator::i_getinneriterator, (void*)&c_FilterIterator::ifa_getinneriterator, 0, 4, 0x0000000000000000LL);
CallInfo c_FilterIterator::ci___construct((void*)&c_FilterIterator::i___construct, (void*)&c_FilterIterator::ifa___construct, 1, 4, 0x0000000000000000LL);
CallInfo c_FilterIterator::ci___clone((void*)&c_FilterIterator::i___clone, (void*)&c_FilterIterator::ifa___clone, 0, 4, 0x0000000000000000LL);
CallInfo c_FilterIterator::ci_fetch((void*)&c_FilterIterator::i_fetch, (void*)&c_FilterIterator::ifa_fetch, 0, 4, 0x0000000000000000LL);
CallInfo c_FilterIterator::ci_current((void*)&c_FilterIterator::i_current, (void*)&c_FilterIterator::ifa_current, 0, 4, 0x0000000000000000LL);
CallInfo c_FilterIterator::ci___call((void*)&c_FilterIterator::i___call, (void*)&c_FilterIterator::ifa___call, 2, 4, 0x0000000000000000LL);
CallInfo c_FilterIterator::ci_rewind((void*)&c_FilterIterator::i_rewind, (void*)&c_FilterIterator::ifa_rewind, 0, 4, 0x0000000000000000LL);
Variant c_FilterIterator::i_next(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_next, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("FilterIterator::next", 0, 1);
  return (self->t_next(), null);
}
Variant c_FilterIterator::i_key(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_key, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("FilterIterator::key", 0, 1);
  return (self->t_key());
}
Variant c_FilterIterator::i_valid(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_valid, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("FilterIterator::valid", 0, 1);
  return (self->t_valid());
}
Variant c_FilterIterator::i_getinneriterator(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_getinneriterator, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("FilterIterator::getInnerIterator", 0, 1);
  return (self->t_getinneriterator());
}
Variant c_FilterIterator::i___construct(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i___construct, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count < 1)) return throw_missing_typed_argument("FilterIterator::__construct", "iterator", 1);
  if (UNLIKELY(count > 1)) return throw_toomany_arguments("FilterIterator::__construct", 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___construct(arg0), null);
  }
}
Variant c_FilterIterator::i___clone(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i___clone, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("FilterIterator::__clone", 0, 1);
  return (self->t___clone());
}
Variant c_FilterIterator::i_fetch(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_fetch, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("FilterIterator::fetch", 0, 1);
  return (self->t_fetch(), null);
}
Variant c_FilterIterator::i_current(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_current, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("FilterIterator::current", 0, 1);
  return (self->t_current());
}
Variant c_FilterIterator::i___call(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i___call, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count != 2)) return throw_wrong_arguments("FilterIterator::__call", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___call(arg0, arg1));
  }
}
Variant c_FilterIterator::i_rewind(MethodCallPackage &mcp, CArrRef params) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::i_dummy(mcp, params, i_rewind, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("FilterIterator::rewind", 0, 1);
  return (self->t_rewind(), null);
}
Variant c_FilterIterator::ifa_next(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_next, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("FilterIterator::next", 0, 1);
  return (self->t_next(), null);
}
Variant c_FilterIterator::ifa_key(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_key, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("FilterIterator::key", 0, 1);
  return (self->t_key());
}
Variant c_FilterIterator::ifa_valid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_valid, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("FilterIterator::valid", 0, 1);
  return (self->t_valid());
}
Variant c_FilterIterator::ifa_getinneriterator(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_getinneriterator, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("FilterIterator::getInnerIterator", 0, 1);
  return (self->t_getinneriterator());
}
Variant c_FilterIterator::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa___construct, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  if (UNLIKELY(count < 1)) return throw_missing_typed_argument("FilterIterator::__construct", "iterator", 1);
  if (UNLIKELY(count > 1)) return throw_toomany_arguments("FilterIterator::__construct", 1, 2);
  CVarRef arg0(a0);
  return (self->t___construct(arg0), null);
}
Variant c_FilterIterator::ifa___clone(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa___clone, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("FilterIterator::__clone", 0, 1);
  return (self->t___clone());
}
Variant c_FilterIterator::ifa_fetch(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_fetch, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("FilterIterator::fetch", 0, 1);
  return (self->t_fetch(), null);
}
Variant c_FilterIterator::ifa_current(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_current, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("FilterIterator::current", 0, 1);
  return (self->t_current());
}
Variant c_FilterIterator::ifa___call(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa___call, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  if (UNLIKELY(count != 2)) return throw_wrong_arguments("FilterIterator::__call", count, 2, 2, 1);
  CVarRef arg0(a0);
  CVarRef arg1(a1);
  return (self->t___call(arg0, arg1));
}
Variant c_FilterIterator::ifa_rewind(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (UNLIKELY(mcp.obj == 0)) {
    return ObjectData::ifa_dummy(mcp, count, INVOKE_FEW_ARGS_PASS_ARGS, ifa_rewind, coo_FilterIterator);
  }
  c_FilterIterator *self ATTRIBUTE_UNUSED (static_cast<c_FilterIterator*>(mcp.obj));
  if (UNLIKELY(count > 0)) return throw_toomany_arguments("FilterIterator::rewind", 0, 1);
  return (self->t_rewind(), null);
}
const MethodCallInfoTable c_FilterIterator::s_call_info_table[] = {
  { 0x6413CB5154808C44LL, 1, 5, "valid", &c_FilterIterator::ci_valid },
  { 0x3106F858B09C7424LL, 0, 16, "getInnerIterator", &c_FilterIterator::ci_getinneriterator },
  { 0x1670096FDE27AF6ALL, 1, 6, "rewind", &c_FilterIterator::ci_rewind },
  { 0x5D73364F53CEEB6CLL, 1, 6, "__call", &c_FilterIterator::ci___call },
  { 0x56EDB60C824E8C51LL, 1, 3, "key", &c_FilterIterator::ci_key },
  { 0x3C6D50F3BB8102B8LL, 1, 4, "next", &c_FilterIterator::ci_next },
  { 0x0F2CA10C0004BE9BLL, 1, 7, "__clone", &c_FilterIterator::ci___clone },
  { 0x5E82B850BB90B0FBLL, 0, 5, "fetch", &c_FilterIterator::ci_fetch },
  { 0x5B3A4A72846B21DCLL, 1, 7, "current", &c_FilterIterator::ci_current },
  { 0x0D31D0AC229C615FLL, 1, 11, "__construct", &c_FilterIterator::ci___construct },
  { 0, 1, 0, 0 }
};
const int c_FilterIterator::s_call_info_index[] = {
  31,
  -1,-1,-1,-1,0,-1,-1,-1,
  -1,-1,2,-1,3,-1,-1,-1,
  -1,4,-1,-1,-1,-1,-1,-1,
  5,-1,-1,6,8,-1,-1,9,

};
c_FilterIterator *c_FilterIterator::create(CVarRef v_it) {
  CountableHelper h(this);
  init();
  t___construct(v_it);
  return this;
}
void c_FilterIterator::dynConstruct(CArrRef params) {
  int count ATTRIBUTE_UNUSED = params.size();
  if (UNLIKELY(count < 1)) throw_missing_typed_argument("FilterIterator::__construct", "iterator", 1);
  if (UNLIKELY(count != 1)) throw_wrong_arguments("FilterIterator::__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_FilterIterator::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_FilterIterator::ci___construct;
  mcp.obj = this;
}
ObjectStaticCallbacks cw_FilterIterator = {
  c_FilterIterator::os_getInit,
  c_FilterIterator::os_get,
  c_FilterIterator::os_lval,
  c_FilterIterator::os_invoke,
  c_FilterIterator::os_constant,
  (ObjectData*(*)(ObjectData*))coo_FilterIterator,
  c_FilterIterator::s_call_info_table,c_FilterIterator::s_call_info_index,
  &c_FilterIterator::s_class_name,
  &cw_IteratorIterator
};
/* SRC: classes/iterator.php line 714 */
void c_FilterIterator::t___construct(Variant v_it) {
  INSTANCE_METHOD_INJECTION_BUILTIN(FilterIterator, FilterIterator::__construct);
  bool oldInCtor = gasInCtor(true);
  if(!v_it.instanceof(NAMSTR(s_sys_ss2fd353cc, "iterator"))) {
    throw_unexpected_argument_type(1,"FilterIterator::__construct()","iterator",v_it);
    return;
  }
  m_it.assignVal(v_it);
  gasInCtor(oldInCtor);
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 718 */
void c_FilterIterator::t_rewind() {
  INSTANCE_METHOD_INJECTION_BUILTIN(FilterIterator, FilterIterator::rewind);
  {
    MethodCallPackage mcp0;
    CVarRef obj0 = m_it;
    mcp0.methodCall((obj0), NAMSTR(s_sys_ss941ca25f, "rewind"), 0x1670096FDE27AF6ALL);
    const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
    (mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0);
  }
  t_fetch();
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 723 */
/* SRC: classes/iterator.php line 725 */
void c_FilterIterator::t_fetch() {
  INSTANCE_METHOD_INJECTION_BUILTIN(FilterIterator, FilterIterator::fetch);
  LOOP_COUNTER(1);
  {
    while (true) {
      {
        MethodCallPackage mcp0;
        CVarRef obj0 = m_it;
        mcp0.methodCall((obj0), NAMSTR(s_sys_ss9943cbf4, "valid"), 0x6413CB5154808C44LL);
        const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
        if (!(toBoolean((mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0)))) break;
      }
      LOOP_COUNTER_CHECK(1);
      {
        {
          bool tmp0;
          {
            MethodCallPackage mcp1;
            mcp1.methodCall((GET_THIS_VALID()), NAMSTR(s_sys_ss6352645d, "accept"), 0x7DFE4A7C2052FD88LL);
            const CallInfo *cit1 ATTRIBUTE_UNUSED = mcp1.ci;
            tmp0 = (toBoolean((mcp1.bindClass(fi)->getMeth0Args())(mcp1, 0)));
          }
          if (tmp0) {
            {
              return;
            }
          }
        }
        {
          MethodCallPackage mcp0;
          CVarRef obj0 = m_it;
          mcp0.methodCall((obj0), NAMSTR(s_sys_ss50652d33, "next"), 0x3C6D50F3BB8102B8LL);
          const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
          (mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0);
        }
      }
    }
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 734 */
void c_FilterIterator::t_next() {
  INSTANCE_METHOD_INJECTION_BUILTIN(FilterIterator, FilterIterator::next);
  {
    MethodCallPackage mcp0;
    CVarRef obj0 = m_it;
    mcp0.methodCall((obj0), NAMSTR(s_sys_ss50652d33, "next"), 0x3C6D50F3BB8102B8LL);
    const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
    (mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0);
  }
  t_fetch();
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 739 */
Variant c_FilterIterator::t_valid() {
  INSTANCE_METHOD_INJECTION_BUILTIN(FilterIterator, FilterIterator::valid);
  {
    MethodCallPackage mcp0;
    CVarRef obj0 = m_it;
    mcp0.methodCall((obj0), NAMSTR(s_sys_ss9943cbf4, "valid"), 0x6413CB5154808C44LL);
    const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
    return wrap_variant((mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0));
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 743 */
Variant c_FilterIterator::t_key() {
  INSTANCE_METHOD_INJECTION_BUILTIN(FilterIterator, FilterIterator::key);
  {
    MethodCallPackage mcp0;
    CVarRef obj0 = m_it;
    mcp0.methodCall((obj0), NAMSTR(s_sys_ss12e90587, "key"), 0x56EDB60C824E8C51LL);
    const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
    return wrap_variant((mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0));
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 747 */
Variant c_FilterIterator::t_current() {
  INSTANCE_METHOD_INJECTION_BUILTIN(FilterIterator, FilterIterator::current);
  {
    MethodCallPackage mcp0;
    CVarRef obj0 = m_it;
    mcp0.methodCall((obj0), NAMSTR(s_sys_ssb3a5c1b3, "current"), 0x5B3A4A72846B21DCLL);
    const CallInfo *cit0 ATTRIBUTE_UNUSED = mcp0.ci;
    return wrap_variant((mcp0.bindClass(fi)->getMeth0Args())(mcp0, 0));
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 751 */
Variant c_FilterIterator::t___clone() {
  INSTANCE_METHOD_INJECTION_BUILTIN(FilterIterator, FilterIterator::__clone);
  return null;
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 755 */
Variant c_FilterIterator::t_getinneriterator() {
  INSTANCE_METHOD_INJECTION_BUILTIN(FilterIterator, FilterIterator::getInnerIterator);
  return m_it;
}
namespace hphp_impl_splitter {}
/* SRC: classes/iterator.php line 759 */
Variant c_FilterIterator::t___call(Variant v_func, Variant v_params) {
  INSTANCE_METHOD_INJECTION_BUILTIN(FilterIterator, FilterIterator::__call);
  return x_call_user_func_array(VarNR(Array(ArrayInit(2).set(m_it).set(v_func).create())), toArray(v_params));
}
namespace hphp_impl_splitter {}
ObjectData *coo_ArrayIterator() {
  return NEWOBJ(c_ArrayIterator)();
}
ObjectData *coo_AppendIterator() {
  return NEWOBJ(c_AppendIterator)();
}
ObjectData *coo_IteratorIterator() {
  return NEWOBJ(c_IteratorIterator)();
}
ObjectData *coo_RecursiveIteratorIterator() {
  return NEWOBJ(c_RecursiveIteratorIterator)();
}
ObjectData *coo_MutableArrayIterator() {
  return NEWOBJ(c_MutableArrayIterator)();
}
ObjectData *coo_FilterIterator() {
  return NEWOBJ(c_FilterIterator)();
}

// Class tables
ClassPropTable cpt_AppendIterator;
ClassPropTable cpt_ArrayIterator;
ClassPropTable cpt_FilterIterator;
ClassPropTable cpt_IteratorIterator;
ClassPropTable cpt_RecursiveIteratorIterator;
static int ctInitializer() {
  const char *ctMapData[] = {
    (const char *)1, (const char *)1, (const char *)&cpt_AppendIterator, (const char *)NULL,
    (const char *)256, (const char *)&NAMSTR(s_sys_ssb3fce46e, "\000AppendIterator\000iterators"),
    (const char *)GET_PROPERTY_OFFSET(c_AppendIterator, m_iterators),
    (const char *)10,

    (const char *)2, (const char *)0, (const char *)&cpt_ArrayIterator, (const char *)NULL,
    (const char *)128, (const char *)&NAMSTR(s_sys_ss7cb08d68, "arr"),
    (const char *)GET_PROPERTY_OFFSET(c_ArrayIterator, m_arr),
    (const char *)10,
    (const char *)128, (const char *)&NAMSTR(s_sys_ss28fae70d, "flags"),
    (const char *)GET_PROPERTY_OFFSET(c_ArrayIterator, m_flags),
    (const char *)10,

    (const char *)1, (const char *)1, (const char *)&cpt_FilterIterator, (const char *)&cpt_IteratorIterator,
    (const char *)256, (const char *)&NAMSTR(s_sys_ssc4be4990, "\000FilterIterator\000it"),
    (const char *)GET_PROPERTY_OFFSET(c_FilterIterator, m_it),
    (const char *)10,

    (const char *)1, (const char *)1, (const char *)&cpt_IteratorIterator, (const char *)NULL,
    (const char *)256, (const char *)&NAMSTR(s_sys_ss8c1ec20c, "\000IteratorIterator\000iterator"),
    (const char *)GET_PROPERTY_OFFSET(c_IteratorIterator, m_iterator),
    (const char *)10,

    (const char *)1, (const char *)1, (const char *)&cpt_RecursiveIteratorIterator, (const char *)NULL,
    (const char *)256, (const char *)&NAMSTR(s_sys_ss246080da, "\000RecursiveIteratorIterator\000rsrc"),
    (const char *)GET_PROPERTY_OFFSET(c_RecursiveIteratorIterator, m_rsrc),
    (const char *)10,

    NULL, NULL, NULL,
  };
  static ClassPropTableEntry entries[6];
  static ClassPropTableEntry *pentries[9];
  return ClassInfo::InitClassPropTable(ctMapData, entries, pentries);
}
static int ct_initializer = ctInitializer();

// o_getClassPropTable
const ClassPropTable *c_AppendIterator::o_getClassPropTable() const { return &cpt_AppendIterator; }
const ClassPropTable *c_ArrayIterator::o_getClassPropTable() const { return &cpt_ArrayIterator; }
const ClassPropTable *c_FilterIterator::o_getClassPropTable() const { return &cpt_FilterIterator; }
const ClassPropTable *c_IteratorIterator::o_getClassPropTable() const { return &cpt_IteratorIterator; }
const ClassPropTable *c_RecursiveIteratorIterator::o_getClassPropTable() const { return &cpt_RecursiveIteratorIterator; }

///////////////////////////////////////////////////////////////////////////////
}
