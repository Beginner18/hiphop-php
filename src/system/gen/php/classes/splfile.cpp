/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010 Facebook, Inc. (http://www.facebook.com)          |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
// @generated by HipHop Compiler

#include <php/classes/iterator.h>
#include <php/classes/splfile.h>
#include <runtime/ext/ext.h>
#include <runtime/eval/eval.h>

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////

/* preface starts */
/* preface finishes */
/* SRC: classes/splfile.php line 120 */
const int64 q_splfileobject_DROP_NEW_LINE = 1LL;
const int64 q_splfileobject_READ_AHEAD = 2LL;
const int64 q_splfileobject_SKIP_EMPTY = 6LL;
const int64 q_splfileobject_READ_CSV = 8LL;
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_splfileobject
Variant c_splfileobject::os_getInit(const char *s, int64 hash) {
  return c_splfileinfo::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_splfileobject
Variant c_splfileobject::os_get(const char *s, int64 hash) {
  return c_splfileinfo::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_splfileobject
Variant &c_splfileobject::os_lval(const char *s, int64 hash) {
  return c_splfileinfo::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_splfileobject
void c_splfileobject::o_getArray(Array &props) const {
  c_splfileinfo::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_splfileobject
void c_splfileobject::o_setArray(CArrRef props) {
  c_splfileinfo::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_get_splfileobject
Variant c_splfileobject::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_splfileobject
Variant c_splfileobject::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_splfileinfo::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_splfileobject
Variant c_splfileobject::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_exists_splfileobject
bool c_splfileobject::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_splfileobject
bool c_splfileobject::o_existsPublic(CStrRef s, int64 hash) const {
  return c_splfileinfo::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_splfileobject
bool c_splfileobject::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_set_splfileobject
Variant c_splfileobject::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_splfileobject
Variant c_splfileobject::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_splfileinfo::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_splfileobject
Variant c_splfileobject::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_lval_splfileobject
Variant& c_splfileobject::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_splfileobject
Variant& c_splfileobject::o_lvalPublic(CStrRef s, int64 hash) {
  return c_splfileinfo::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_splfileobject
Variant& c_splfileobject::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_splfileobject
Variant c_splfileobject::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 7) {
    case 2:
      HASH_RETURN(0x54B2A676B563E232LL, q_splfileobject_SKIP_EMPTY, "SKIP_EMPTY");
      break;
    case 3:
      HASH_RETURN(0x23519E830A6DEC13LL, q_splfileobject_READ_CSV, "READ_CSV");
      break;
    case 4:
      HASH_RETURN(0x05ABC27224BDAC64LL, q_splfileobject_DROP_NEW_LINE, "DROP_NEW_LINE");
      break;
    case 6:
      HASH_RETURN(0x6ABD9DCA7D94431ELL, q_splfileobject_READ_AHEAD, "READ_AHEAD");
      break;
    default:
      break;
  }
  return c_splfileinfo::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_splfileobject
IMPLEMENT_CLASS(splfileobject)
c_splfileobject *c_splfileobject::create(Variant v_filename, Variant v_open_mode //  = "r"
, Variant v_use_include_path //  = false
, Variant v_context //  = null
) {
  CountableHelper h(this);
  init();
  t___construct(v_filename, v_open_mode, v_use_include_path, v_context);
  return this;
}
ObjectData *c_splfileobject::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 4) throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1, arg2, arg3));
    } while (false);
  }
  return this;
}
void c_splfileobject::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1, arg2, arg3));
  } while (false);
}
void c_splfileobject::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else (t___construct(a0, a1, a2, a3), null);
}
ObjectData *c_splfileobject::cloneImpl() {
  c_splfileobject *obj = NEW(c_splfileobject)();
  cloneSet(obj);
  return obj;
}
void c_splfileobject::cloneSet(c_splfileobject *clone) {
  c_splfileinfo::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_splfileobject
Variant c_splfileobject::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xad:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        return (t_getperms());
      }
      break;
    case 0xae:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        return (t_iswritable());
      }
      break;
    case 0x15e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 1) return throw_wrong_arguments("SplFileObject::fscanf", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_fscanf(arg0));
        }
      }
      break;
    case 0xaf:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getbasename());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getbasename(arg0));
        }
      }
      break;
    case 0xb0:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        return (t_getpathname());
      }
      break;
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::next", 0, 1);
        return (t_next());
      }
      break;
    case 0x15f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 2) return throw_wrong_arguments("SplFileObject::fseek", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fseek(arg0, arg1));
        }
      }
      break;
    case 0xb1:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        return (t_getgroup());
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::key", 0, 1);
        return (t_key());
      }
      break;
    case 0x160:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 1) return throw_wrong_arguments("SplFileObject::fgetss", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_fgetss(arg0));
        }
      }
      break;
    case 0xb2:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setfileclass());
          CVarRef arg0((ad->getValue(pos)));
          return (t_setfileclass(arg0));
        }
      }
      break;
    case 0x161:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 3) return throw_toomany_arguments("SplFileObject::fgetcsv", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fgetcsv());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_fgetcsv(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_fgetcsv(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fgetcsv(arg0, arg1, arg2));
        }
      }
      break;
    case 0xb3:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setinfoclass());
          CVarRef arg0((ad->getValue(pos)));
          return (t_setinfoclass(arg0));
        }
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::valid", 0, 1);
        return (t_valid());
      }
      break;
    case 0x162:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 3) return throw_toomany_arguments("SplFileObject::setCsvControl", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setcsvcontrol());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_setcsvcontrol(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_setcsvcontrol(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setcsvcontrol(arg0, arg1, arg2));
        }
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0xb4:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        return (t_getlinktarget());
      }
      break;
    case 0x163:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::getCsvControl", 0, 1);
        return (t_getcsvcontrol());
      }
      break;
    case 0xb5:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        return (t_isreadable());
      }
      break;
    case 0xb6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        return (t_getrealpath());
      }
      break;
    case 0x11:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 1) return throw_wrong_arguments("SplFileObject::setFlags", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setflags(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count < 1 || count > 4) return throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3), null);
        }
      }
      break;
    case 0xb7:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getpathinfo());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getpathinfo(arg0));
        }
      }
      break;
    case 0x164:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 1) return throw_wrong_arguments("SplFileObject::setMaxLineLen", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setmaxlinelen(arg0));
        }
      }
      break;
    case 0x165:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::getMaxLineLen", 0, 1);
        return (t_getmaxlinelen());
      }
      break;
    case 0xb8:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        return (t_getctime());
      }
      break;
    case 0xb9:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        return (t_getpath());
      }
      break;
    case 0x166:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 1) return throw_wrong_arguments("SplFileObject::ftruncate", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_ftruncate(arg0));
        }
      }
      break;
    case 0xba:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        return (t_getinode());
      }
      break;
    case 0x168:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::fflush", 0, 1);
        return (t_fflush());
      }
      break;
    case 0x167:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::eof", 0, 1);
        return (t_eof());
      }
      break;
    case 0xbb:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        return (t_islink());
      }
      break;
    case 0xbc:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        return (t_getsize());
      }
      break;
    case 0xbe:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        return (t_isfile());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 0x169:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgetc", 0, 1);
        return (t_fgetc());
      }
      break;
    case 0x16a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::fpassthru", 0, 1);
        return (t_fpassthru());
      }
      break;
    case 0xbf:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        return (t_getowner());
      }
      break;
    case 0xf9:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::hasChildren", 0, 1);
        return (t_haschildren());
      }
      break;
    case 0x16b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgets", 0, 1);
        return (t_fgets());
      }
      break;
    case 0x15:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 1) return throw_wrong_arguments("SplFileObject::seek", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_seek(arg0));
        }
      }
      break;
    case 0x16c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 2) return throw_wrong_arguments("SplFileObject::flock", count, 2, 2, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
          return (t_flock(arg0, ref(arg1)));
        }
      }
      break;
    case 0xc0:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        return (t_getmtime());
      }
      break;
    case 0xc1:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        return (t_isdir());
      }
      break;
    case 0x16:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::getFlags", 0, 1);
        return (t_getflags());
      }
      break;
    case 0xc2:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getfileinfo());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getfileinfo(arg0));
        }
      }
      break;
    case 0xfa:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::getChildren", 0, 1);
        return (t_getchildren());
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::current", 0, 1);
        return (t_current());
      }
      break;
    case 0x16e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 2) return throw_wrong_arguments("SplFileObject::fwrite", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fwrite(arg0, arg1));
        }
      }
      break;
    case 0x16d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::ftell", 0, 1);
        return (t_ftell());
      }
      break;
    case 0xc4:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        return (t_isexecutable());
      }
      break;
    case 0xc3:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        return (t_getatime());
      }
      break;
    case 0xc5:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_openfile());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_openfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_openfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_openfile(arg0, arg1, arg2));
        }
      }
      break;
    case 0x16f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::fstat", 0, 1);
        return (t_fstat());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 0xc7:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        return (t_gettype());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 0:
      HASH_GUARD(0x09637D7CA2E33F00LL, fgetc) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgetc", 0, 1);
        return (t_fgetc());
      }
      break;
    case 6:
      HASH_GUARD(0x6B2EAD4A44934786LL, getrealpath) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        return (t_getrealpath());
      }
      HASH_GUARD(0x44CE4DB1CE7E9F86LL, flock) {
        if (count != 2) return throw_wrong_arguments("SplFileObject::flock", count, 2, 2, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
          return (t_flock(arg0, ref(arg1)));
        }
      }
      HASH_GUARD(0x1D3B08AA0AF50F06LL, gettype) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        return (t_gettype());
      }
      break;
    case 8:
      HASH_GUARD(0x1ADA46FCC8EFEC08LL, isdir) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        return (t_isdir());
      }
      break;
    case 10:
      HASH_GUARD(0x2FC3A6941D522E0ALL, setflags) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::setFlags", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setflags(arg0));
        }
      }
      break;
    case 14:
      HASH_GUARD(0x32ABF385AD4BE48ELL, getowner) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        return (t_getowner());
      }
      break;
    case 15:
      HASH_GUARD(0x732EC1BDA8EC520FLL, getchildren) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getChildren", 0, 1);
        return (t_getchildren());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 21:
      HASH_GUARD(0x40044334DA397C15LL, haschildren) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::hasChildren", 0, 1);
        return (t_haschildren());
      }
      break;
    case 26:
      HASH_GUARD(0x2B7CAC006AF27F9ALL, fflush) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fflush", 0, 1);
        return (t_fflush());
      }
      break;
    case 27:
      HASH_GUARD(0x5B33B55D4B7E339BLL, fpassthru) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fpassthru", 0, 1);
        return (t_fpassthru());
      }
      break;
    case 28:
      HASH_GUARD(0x572E108C6731E29CLL, getbasename) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getbasename());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getbasename(arg0));
        }
      }
      break;
    case 29:
      HASH_GUARD(0x4C43532D60465F1DLL, isfile) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        return (t_isfile());
      }
      break;
    case 30:
      HASH_GUARD(0x3E4E7C561D3A541ELL, fgetss) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::fgetss", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_fgetss(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD(0x4BC19906B553C59FLL, getatime) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        return (t_getatime());
      }
      break;
    case 35:
      HASH_GUARD(0x044B276686B77923LL, fscanf) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::fscanf", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_fscanf(arg0));
        }
      }
      break;
    case 37:
      HASH_GUARD(0x5948407CA9CC4DA5LL, setfileclass) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setfileclass());
          CVarRef arg0((ad->getValue(pos)));
          return (t_setfileclass(arg0));
        }
      }
      break;
    case 43:
      HASH_GUARD(0x0D6276BAB75513ABLL, getlinktarget) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        return (t_getlinktarget());
      }
      break;
    case 45:
      HASH_GUARD(0x1C1216F2B7C16CADLL, ftell) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::ftell", 0, 1);
        return (t_ftell());
      }
      break;
    case 47:
      HASH_GUARD(0x5640A4755D0078AFLL, getctime) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        return (t_getctime());
      }
      break;
    case 53:
      HASH_GUARD(0x337DEC2D48BDFE35LL, openfile) {
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_openfile());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_openfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_openfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_openfile(arg0, arg1, arg2));
        }
      }
      break;
    case 55:
      HASH_GUARD(0x4CEC6AA30E43D437LL, setmaxlinelen) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::setMaxLineLen", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setmaxlinelen(arg0));
        }
      }
      break;
    case 56:
      HASH_GUARD(0x3C6D50F3BB8102B8LL, next) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::next", 0, 1);
        return (t_next());
      }
      HASH_GUARD(0x0890F9052322E838LL, fstat) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fstat", 0, 1);
        return (t_fstat());
      }
      break;
    case 63:
      HASH_GUARD(0x04C642C6C162243FLL, getpath) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        return (t_getpath());
      }
      HASH_GUARD(0x7D50FA42F9D4923FLL, getfileinfo) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getfileinfo());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getfileinfo(arg0));
        }
      }
      break;
    case 67:
      HASH_GUARD(0x5ACCF9166CD9D043LL, ftruncate) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::ftruncate", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_ftruncate(arg0));
        }
      }
      HASH_GUARD(0x794FAFD4412AEFC3LL, eof) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::eof", 0, 1);
        return (t_eof());
      }
      break;
    case 68:
      HASH_GUARD(0x6413CB5154808C44LL, valid) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::valid", 0, 1);
        return (t_valid());
      }
      break;
    case 69:
      HASH_GUARD(0x5676046725D241C5LL, setinfoclass) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setinfoclass());
          CVarRef arg0((ad->getValue(pos)));
          return (t_setinfoclass(arg0));
        }
      }
      break;
    case 73:
      HASH_GUARD(0x4282E0231F600049LL, fseek) {
        if (count != 2) return throw_wrong_arguments("SplFileObject::fseek", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fseek(arg0, arg1));
        }
      }
      break;
    case 74:
      HASH_GUARD(0x01A800A73CD2604ALL, getinode) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        return (t_getinode());
      }
      break;
    case 77:
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 78:
      HASH_GUARD(0x7E978C38D741664ELL, fgetcsv) {
        if (count > 3) return throw_toomany_arguments("SplFileObject::fgetcsv", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fgetcsv());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_fgetcsv(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_fgetcsv(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fgetcsv(arg0, arg1, arg2));
        }
      }
      break;
    case 79:
      HASH_GUARD(0x569FC7D8E9401C4FLL, isreadable) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        return (t_isreadable());
      }
      break;
    case 80:
      HASH_GUARD(0x3A335010F905ACD0LL, setcsvcontrol) {
        if (count > 3) return throw_toomany_arguments("SplFileObject::setCsvControl", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setcsvcontrol());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_setcsvcontrol(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_setcsvcontrol(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setcsvcontrol(arg0, arg1, arg2));
        }
      }
      break;
    case 81:
      HASH_GUARD(0x56EDB60C824E8C51LL, key) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::key", 0, 1);
        return (t_key());
      }
      break;
    case 88:
      HASH_GUARD(0x1D5801BB72C51C58LL, islink) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        return (t_islink());
      }
      break;
    case 90:
      HASH_GUARD(0x25F68E7910FE9CDALL, getmaxlinelen) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getMaxLineLen", 0, 1);
        return (t_getmaxlinelen());
      }
      break;
    case 92:
      HASH_GUARD(0x5B3A4A72846B21DCLL, current) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::current", 0, 1);
        return (t_current());
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 4) return throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3), null);
        }
      }
      break;
    case 97:
      HASH_GUARD(0x27E7DBA875AD17E1LL, getflags) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getFlags", 0, 1);
        return (t_getflags());
      }
      break;
    case 98:
      HASH_GUARD(0x6FE9F691E4A6D962LL, getcsvcontrol) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getCsvControl", 0, 1);
        return (t_getcsvcontrol());
      }
      break;
    case 99:
      HASH_GUARD(0x638F2A56B8463A63LL, iswritable) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        return (t_iswritable());
      }
      break;
    case 101:
      HASH_GUARD(0x05D72365192CE465LL, fwrite) {
        if (count != 2) return throw_wrong_arguments("SplFileObject::fwrite", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fwrite(arg0, arg1));
        }
      }
      break;
    case 103:
      HASH_GUARD(0x00DCC39EDB16AFE7LL, getpathinfo) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getpathinfo());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getpathinfo(arg0));
        }
      }
      HASH_GUARD(0x7EF5445C77054C67LL, seek) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::seek", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_seek(arg0));
        }
      }
      break;
    case 106:
      HASH_GUARD(0x0F9EDEC32565D86ALL, getgroup) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        return (t_getgroup());
      }
      HASH_GUARD(0x6615B5496D03A6EALL, getsize) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        return (t_getsize());
      }
      HASH_GUARD(0x1670096FDE27AF6ALL, rewind) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 115:
      HASH_GUARD(0x7AE1BE187F18FDF3LL, fgets) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgets", 0, 1);
        return (t_fgets());
      }
      break;
    case 116:
      HASH_GUARD(0x265BDC54C992EE74LL, getmtime) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        return (t_getmtime());
      }
      break;
    case 120:
      HASH_GUARD(0x25070641C3D924F8LL, getpathname) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        return (t_getpathname());
      }
      break;
    case 122:
      HASH_GUARD(0x3786834B2A0CCB7ALL, isexecutable) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        return (t_isexecutable());
      }
      break;
    case 125:
      HASH_GUARD(0x4351578037A06E7DLL, getperms) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        return (t_getperms());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_splfileobject
Variant c_splfileobject::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xad:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        return (t_getperms());
      }
      break;
    case 0xae:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        return (t_iswritable());
      }
      break;
    case 0x15e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 1) return throw_wrong_arguments("SplFileObject::fscanf", count, 1, 1, 1);
        return (t_fscanf(a0));
      }
      break;
    case 0xaf:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        if (count <= 0) return (t_getbasename());
        return (t_getbasename(a0));
      }
      break;
    case 0xb0:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        return (t_getpathname());
      }
      break;
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::next", 0, 1);
        return (t_next());
      }
      break;
    case 0x15f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 2) return throw_wrong_arguments("SplFileObject::fseek", count, 2, 2, 1);
        return (t_fseek(a0, a1));
      }
      break;
    case 0xb1:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        return (t_getgroup());
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::key", 0, 1);
        return (t_key());
      }
      break;
    case 0x160:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 1) return throw_wrong_arguments("SplFileObject::fgetss", count, 1, 1, 1);
        return (t_fgetss(a0));
      }
      break;
    case 0xb2:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        if (count <= 0) return (t_setfileclass());
        return (t_setfileclass(a0));
      }
      break;
    case 0x161:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 3) return throw_toomany_arguments("SplFileObject::fgetcsv", 3, 1);
        if (count <= 0) return (t_fgetcsv());
        if (count == 1) return (t_fgetcsv(a0));
        if (count == 2) return (t_fgetcsv(a0, a1));
        return (t_fgetcsv(a0, a1, a2));
      }
      break;
    case 0xb3:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        if (count <= 0) return (t_setinfoclass());
        return (t_setinfoclass(a0));
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::valid", 0, 1);
        return (t_valid());
      }
      break;
    case 0x162:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 3) return throw_toomany_arguments("SplFileObject::setCsvControl", 3, 1);
        if (count <= 0) return (t_setcsvcontrol());
        if (count == 1) return (t_setcsvcontrol(a0));
        if (count == 2) return (t_setcsvcontrol(a0, a1));
        return (t_setcsvcontrol(a0, a1, a2));
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0xb4:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        return (t_getlinktarget());
      }
      break;
    case 0x163:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::getCsvControl", 0, 1);
        return (t_getcsvcontrol());
      }
      break;
    case 0xb5:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        return (t_isreadable());
      }
      break;
    case 0xb6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        return (t_getrealpath());
      }
      break;
    case 0x11:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 1) return throw_wrong_arguments("SplFileObject::setFlags", count, 1, 1, 1);
        return (t_setflags(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count < 1 || count > 4) return throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 0xb7:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        if (count <= 0) return (t_getpathinfo());
        return (t_getpathinfo(a0));
      }
      break;
    case 0x164:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 1) return throw_wrong_arguments("SplFileObject::setMaxLineLen", count, 1, 1, 1);
        return (t_setmaxlinelen(a0));
      }
      break;
    case 0x165:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::getMaxLineLen", 0, 1);
        return (t_getmaxlinelen());
      }
      break;
    case 0xb8:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        return (t_getctime());
      }
      break;
    case 0xb9:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        return (t_getpath());
      }
      break;
    case 0x166:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 1) return throw_wrong_arguments("SplFileObject::ftruncate", count, 1, 1, 1);
        return (t_ftruncate(a0));
      }
      break;
    case 0xba:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        return (t_getinode());
      }
      break;
    case 0x168:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::fflush", 0, 1);
        return (t_fflush());
      }
      break;
    case 0x167:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::eof", 0, 1);
        return (t_eof());
      }
      break;
    case 0xbb:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        return (t_islink());
      }
      break;
    case 0xbc:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        return (t_getsize());
      }
      break;
    case 0xbe:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        return (t_isfile());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 0x169:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgetc", 0, 1);
        return (t_fgetc());
      }
      break;
    case 0x16a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::fpassthru", 0, 1);
        return (t_fpassthru());
      }
      break;
    case 0xbf:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        return (t_getowner());
      }
      break;
    case 0xf9:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::hasChildren", 0, 1);
        return (t_haschildren());
      }
      break;
    case 0x16b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgets", 0, 1);
        return (t_fgets());
      }
      break;
    case 0x15:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 1) return throw_wrong_arguments("SplFileObject::seek", count, 1, 1, 1);
        return (t_seek(a0));
      }
      break;
    case 0x16c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 2) return throw_wrong_arguments("SplFileObject::flock", count, 2, 2, 1);
        return (t_flock(a0, ref(a1)));
      }
      break;
    case 0xc0:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        return (t_getmtime());
      }
      break;
    case 0xc1:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        return (t_isdir());
      }
      break;
    case 0x16:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::getFlags", 0, 1);
        return (t_getflags());
      }
      break;
    case 0xc2:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        if (count <= 0) return (t_getfileinfo());
        return (t_getfileinfo(a0));
      }
      break;
    case 0xfa:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::getChildren", 0, 1);
        return (t_getchildren());
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::current", 0, 1);
        return (t_current());
      }
      break;
    case 0x16e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 2) return throw_wrong_arguments("SplFileObject::fwrite", count, 2, 2, 1);
        return (t_fwrite(a0, a1));
      }
      break;
    case 0x16d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::ftell", 0, 1);
        return (t_ftell());
      }
      break;
    case 0xc4:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        return (t_isexecutable());
      }
      break;
    case 0xc3:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        return (t_getatime());
      }
      break;
    case 0xc5:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        if (count <= 0) return (t_openfile());
        if (count == 1) return (t_openfile(a0));
        if (count == 2) return (t_openfile(a0, a1));
        return (t_openfile(a0, a1, a2));
      }
      break;
    case 0x16f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::fstat", 0, 1);
        return (t_fstat());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileObject::rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 0xc7:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        return (t_gettype());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 0:
      HASH_GUARD(0x09637D7CA2E33F00LL, fgetc) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgetc", 0, 1);
        return (t_fgetc());
      }
      break;
    case 6:
      HASH_GUARD(0x6B2EAD4A44934786LL, getrealpath) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        return (t_getrealpath());
      }
      HASH_GUARD(0x44CE4DB1CE7E9F86LL, flock) {
        if (count != 2) return throw_wrong_arguments("SplFileObject::flock", count, 2, 2, 1);
        return (t_flock(a0, ref(a1)));
      }
      HASH_GUARD(0x1D3B08AA0AF50F06LL, gettype) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        return (t_gettype());
      }
      break;
    case 8:
      HASH_GUARD(0x1ADA46FCC8EFEC08LL, isdir) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        return (t_isdir());
      }
      break;
    case 10:
      HASH_GUARD(0x2FC3A6941D522E0ALL, setflags) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::setFlags", count, 1, 1, 1);
        return (t_setflags(a0));
      }
      break;
    case 14:
      HASH_GUARD(0x32ABF385AD4BE48ELL, getowner) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        return (t_getowner());
      }
      break;
    case 15:
      HASH_GUARD(0x732EC1BDA8EC520FLL, getchildren) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getChildren", 0, 1);
        return (t_getchildren());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 21:
      HASH_GUARD(0x40044334DA397C15LL, haschildren) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::hasChildren", 0, 1);
        return (t_haschildren());
      }
      break;
    case 26:
      HASH_GUARD(0x2B7CAC006AF27F9ALL, fflush) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fflush", 0, 1);
        return (t_fflush());
      }
      break;
    case 27:
      HASH_GUARD(0x5B33B55D4B7E339BLL, fpassthru) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fpassthru", 0, 1);
        return (t_fpassthru());
      }
      break;
    case 28:
      HASH_GUARD(0x572E108C6731E29CLL, getbasename) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        if (count <= 0) return (t_getbasename());
        return (t_getbasename(a0));
      }
      break;
    case 29:
      HASH_GUARD(0x4C43532D60465F1DLL, isfile) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        return (t_isfile());
      }
      break;
    case 30:
      HASH_GUARD(0x3E4E7C561D3A541ELL, fgetss) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::fgetss", count, 1, 1, 1);
        return (t_fgetss(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x4BC19906B553C59FLL, getatime) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        return (t_getatime());
      }
      break;
    case 35:
      HASH_GUARD(0x044B276686B77923LL, fscanf) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::fscanf", count, 1, 1, 1);
        return (t_fscanf(a0));
      }
      break;
    case 37:
      HASH_GUARD(0x5948407CA9CC4DA5LL, setfileclass) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        if (count <= 0) return (t_setfileclass());
        return (t_setfileclass(a0));
      }
      break;
    case 43:
      HASH_GUARD(0x0D6276BAB75513ABLL, getlinktarget) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        return (t_getlinktarget());
      }
      break;
    case 45:
      HASH_GUARD(0x1C1216F2B7C16CADLL, ftell) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::ftell", 0, 1);
        return (t_ftell());
      }
      break;
    case 47:
      HASH_GUARD(0x5640A4755D0078AFLL, getctime) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        return (t_getctime());
      }
      break;
    case 53:
      HASH_GUARD(0x337DEC2D48BDFE35LL, openfile) {
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        if (count <= 0) return (t_openfile());
        if (count == 1) return (t_openfile(a0));
        if (count == 2) return (t_openfile(a0, a1));
        return (t_openfile(a0, a1, a2));
      }
      break;
    case 55:
      HASH_GUARD(0x4CEC6AA30E43D437LL, setmaxlinelen) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::setMaxLineLen", count, 1, 1, 1);
        return (t_setmaxlinelen(a0));
      }
      break;
    case 56:
      HASH_GUARD(0x3C6D50F3BB8102B8LL, next) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::next", 0, 1);
        return (t_next());
      }
      HASH_GUARD(0x0890F9052322E838LL, fstat) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fstat", 0, 1);
        return (t_fstat());
      }
      break;
    case 63:
      HASH_GUARD(0x04C642C6C162243FLL, getpath) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        return (t_getpath());
      }
      HASH_GUARD(0x7D50FA42F9D4923FLL, getfileinfo) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        if (count <= 0) return (t_getfileinfo());
        return (t_getfileinfo(a0));
      }
      break;
    case 67:
      HASH_GUARD(0x5ACCF9166CD9D043LL, ftruncate) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::ftruncate", count, 1, 1, 1);
        return (t_ftruncate(a0));
      }
      HASH_GUARD(0x794FAFD4412AEFC3LL, eof) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::eof", 0, 1);
        return (t_eof());
      }
      break;
    case 68:
      HASH_GUARD(0x6413CB5154808C44LL, valid) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::valid", 0, 1);
        return (t_valid());
      }
      break;
    case 69:
      HASH_GUARD(0x5676046725D241C5LL, setinfoclass) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        if (count <= 0) return (t_setinfoclass());
        return (t_setinfoclass(a0));
      }
      break;
    case 73:
      HASH_GUARD(0x4282E0231F600049LL, fseek) {
        if (count != 2) return throw_wrong_arguments("SplFileObject::fseek", count, 2, 2, 1);
        return (t_fseek(a0, a1));
      }
      break;
    case 74:
      HASH_GUARD(0x01A800A73CD2604ALL, getinode) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        return (t_getinode());
      }
      break;
    case 77:
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 78:
      HASH_GUARD(0x7E978C38D741664ELL, fgetcsv) {
        if (count > 3) return throw_toomany_arguments("SplFileObject::fgetcsv", 3, 1);
        if (count <= 0) return (t_fgetcsv());
        if (count == 1) return (t_fgetcsv(a0));
        if (count == 2) return (t_fgetcsv(a0, a1));
        return (t_fgetcsv(a0, a1, a2));
      }
      break;
    case 79:
      HASH_GUARD(0x569FC7D8E9401C4FLL, isreadable) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        return (t_isreadable());
      }
      break;
    case 80:
      HASH_GUARD(0x3A335010F905ACD0LL, setcsvcontrol) {
        if (count > 3) return throw_toomany_arguments("SplFileObject::setCsvControl", 3, 1);
        if (count <= 0) return (t_setcsvcontrol());
        if (count == 1) return (t_setcsvcontrol(a0));
        if (count == 2) return (t_setcsvcontrol(a0, a1));
        return (t_setcsvcontrol(a0, a1, a2));
      }
      break;
    case 81:
      HASH_GUARD(0x56EDB60C824E8C51LL, key) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::key", 0, 1);
        return (t_key());
      }
      break;
    case 88:
      HASH_GUARD(0x1D5801BB72C51C58LL, islink) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        return (t_islink());
      }
      break;
    case 90:
      HASH_GUARD(0x25F68E7910FE9CDALL, getmaxlinelen) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getMaxLineLen", 0, 1);
        return (t_getmaxlinelen());
      }
      break;
    case 92:
      HASH_GUARD(0x5B3A4A72846B21DCLL, current) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::current", 0, 1);
        return (t_current());
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count < 1 || count > 4) return throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 97:
      HASH_GUARD(0x27E7DBA875AD17E1LL, getflags) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getFlags", 0, 1);
        return (t_getflags());
      }
      break;
    case 98:
      HASH_GUARD(0x6FE9F691E4A6D962LL, getcsvcontrol) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getCsvControl", 0, 1);
        return (t_getcsvcontrol());
      }
      break;
    case 99:
      HASH_GUARD(0x638F2A56B8463A63LL, iswritable) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        return (t_iswritable());
      }
      break;
    case 101:
      HASH_GUARD(0x05D72365192CE465LL, fwrite) {
        if (count != 2) return throw_wrong_arguments("SplFileObject::fwrite", count, 2, 2, 1);
        return (t_fwrite(a0, a1));
      }
      break;
    case 103:
      HASH_GUARD(0x00DCC39EDB16AFE7LL, getpathinfo) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        if (count <= 0) return (t_getpathinfo());
        return (t_getpathinfo(a0));
      }
      HASH_GUARD(0x7EF5445C77054C67LL, seek) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::seek", count, 1, 1, 1);
        return (t_seek(a0));
      }
      break;
    case 106:
      HASH_GUARD(0x0F9EDEC32565D86ALL, getgroup) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        return (t_getgroup());
      }
      HASH_GUARD(0x6615B5496D03A6EALL, getsize) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        return (t_getsize());
      }
      HASH_GUARD(0x1670096FDE27AF6ALL, rewind) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 115:
      HASH_GUARD(0x7AE1BE187F18FDF3LL, fgets) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgets", 0, 1);
        return (t_fgets());
      }
      break;
    case 116:
      HASH_GUARD(0x265BDC54C992EE74LL, getmtime) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        return (t_getmtime());
      }
      break;
    case 120:
      HASH_GUARD(0x25070641C3D924F8LL, getpathname) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        return (t_getpathname());
      }
      break;
    case 122:
      HASH_GUARD(0x3786834B2A0CCB7ALL, isexecutable) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        return (t_isexecutable());
      }
      break;
    case 125:
      HASH_GUARD(0x4351578037A06E7DLL, getperms) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        return (t_getperms());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_splfileobject
Variant c_splfileobject::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_splfileobject
Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0xad:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getperms());
      }
      break;
    case 0xae:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswritable());
      }
      break;
    case 0x15e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::fscanf", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fscanf(a0));
      }
      break;
    case 0xaf:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getbasename());
        else return (t_getbasename(a0));
      }
      break;
    case 0xb0:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getpathname());
      }
      break;
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 0x15f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("SplFileObject::fseek", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fseek(a0, a1));
      }
      break;
    case 0xb1:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getgroup());
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 0x160:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::fgetss", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fgetss(a0));
      }
      break;
    case 0xb2:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setfileclass());
        else return (t_setfileclass(a0));
      }
      break;
    case 0x161:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("SplFileObject::fgetcsv", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fgetcsv());
        else if (count == 1) return (t_fgetcsv(a0));
        else if (count == 2) return (t_fgetcsv(a0, a1));
        else return (t_fgetcsv(a0, a1, a2));
      }
      break;
    case 0xb3:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setinfoclass());
        else return (t_setinfoclass(a0));
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 0x162:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("SplFileObject::setCsvControl", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setcsvcontrol());
        else if (count == 1) return (t_setcsvcontrol(a0));
        else if (count == 2) return (t_setcsvcontrol(a0, a1));
        else return (t_setcsvcontrol(a0, a1, a2));
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0xb4:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlinktarget());
      }
      break;
    case 0x163:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getCsvControl", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcsvcontrol());
      }
      break;
    case 0xb5:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isreadable());
      }
      break;
    case 0xb6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getrealpath());
      }
      break;
    case 0x11:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::setFlags", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setflags(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 0xb7:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getpathinfo());
        else return (t_getpathinfo(a0));
      }
      break;
    case 0x164:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::setMaxLineLen", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setmaxlinelen(a0));
      }
      break;
    case 0x165:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getMaxLineLen", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmaxlinelen());
      }
      break;
    case 0xb8:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getctime());
      }
      break;
    case 0xb9:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getpath());
      }
      break;
    case 0x166:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::ftruncate", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_ftruncate(a0));
      }
      break;
    case 0xba:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinode());
      }
      break;
    case 0x168:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fflush", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fflush());
      }
      break;
    case 0x167:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::eof", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_eof());
      }
      break;
    case 0xbb:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_islink());
      }
      break;
    case 0xbc:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getsize());
      }
      break;
    case 0xbe:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isfile());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 0x169:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgetc", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fgetc());
      }
      break;
    case 0x16a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fpassthru", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fpassthru());
      }
      break;
    case 0xbf:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getowner());
      }
      break;
    case 0xf9:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::hasChildren", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildren());
      }
      break;
    case 0x16b:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgets", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fgets());
      }
      break;
    case 0x15:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::seek", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_seek(a0));
      }
      break;
    case 0x16c:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("SplFileObject::flock", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_flock(a0, ref(a1)));
      }
      break;
    case 0xc0:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmtime());
      }
      break;
    case 0xc1:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdir());
      }
      break;
    case 0x16:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getFlags", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getflags());
      }
      break;
    case 0xc2:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getfileinfo());
        else return (t_getfileinfo(a0));
      }
      break;
    case 0xfa:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getChildren", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getchildren());
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 0x16e:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("SplFileObject::fwrite", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fwrite(a0, a1));
      }
      break;
    case 0x16d:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::ftell", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_ftell());
      }
      break;
    case 0xc4:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isexecutable());
      }
      break;
    case 0xc3:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getatime());
      }
      break;
    case 0xc5:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_openfile());
        else if (count == 1) return (t_openfile(a0));
        else if (count == 2) return (t_openfile(a0, a1));
        else return (t_openfile(a0, a1, a2));
      }
      break;
    case 0x16f:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fstat", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fstat());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    case 0xc7:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettype());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 0:
      HASH_GUARD(0x09637D7CA2E33F00LL, fgetc) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgetc", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fgetc());
      }
      break;
    case 6:
      HASH_GUARD(0x6B2EAD4A44934786LL, getrealpath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getrealpath());
      }
      HASH_GUARD(0x44CE4DB1CE7E9F86LL, flock) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("SplFileObject::flock", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_flock(a0, ref(a1)));
      }
      HASH_GUARD(0x1D3B08AA0AF50F06LL, gettype) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettype());
      }
      break;
    case 8:
      HASH_GUARD(0x1ADA46FCC8EFEC08LL, isdir) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdir());
      }
      break;
    case 10:
      HASH_GUARD(0x2FC3A6941D522E0ALL, setflags) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::setFlags", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setflags(a0));
      }
      break;
    case 14:
      HASH_GUARD(0x32ABF385AD4BE48ELL, getowner) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getowner());
      }
      break;
    case 15:
      HASH_GUARD(0x732EC1BDA8EC520FLL, getchildren) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getChildren", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getchildren());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 21:
      HASH_GUARD(0x40044334DA397C15LL, haschildren) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::hasChildren", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildren());
      }
      break;
    case 26:
      HASH_GUARD(0x2B7CAC006AF27F9ALL, fflush) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fflush", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fflush());
      }
      break;
    case 27:
      HASH_GUARD(0x5B33B55D4B7E339BLL, fpassthru) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fpassthru", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fpassthru());
      }
      break;
    case 28:
      HASH_GUARD(0x572E108C6731E29CLL, getbasename) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getbasename());
        else return (t_getbasename(a0));
      }
      break;
    case 29:
      HASH_GUARD(0x4C43532D60465F1DLL, isfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isfile());
      }
      break;
    case 30:
      HASH_GUARD(0x3E4E7C561D3A541ELL, fgetss) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::fgetss", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fgetss(a0));
      }
      break;
    case 31:
      HASH_GUARD(0x4BC19906B553C59FLL, getatime) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getatime());
      }
      break;
    case 35:
      HASH_GUARD(0x044B276686B77923LL, fscanf) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::fscanf", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fscanf(a0));
      }
      break;
    case 37:
      HASH_GUARD(0x5948407CA9CC4DA5LL, setfileclass) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setfileclass());
        else return (t_setfileclass(a0));
      }
      break;
    case 43:
      HASH_GUARD(0x0D6276BAB75513ABLL, getlinktarget) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlinktarget());
      }
      break;
    case 45:
      HASH_GUARD(0x1C1216F2B7C16CADLL, ftell) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::ftell", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_ftell());
      }
      break;
    case 47:
      HASH_GUARD(0x5640A4755D0078AFLL, getctime) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getctime());
      }
      break;
    case 53:
      HASH_GUARD(0x337DEC2D48BDFE35LL, openfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_openfile());
        else if (count == 1) return (t_openfile(a0));
        else if (count == 2) return (t_openfile(a0, a1));
        else return (t_openfile(a0, a1, a2));
      }
      break;
    case 55:
      HASH_GUARD(0x4CEC6AA30E43D437LL, setmaxlinelen) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::setMaxLineLen", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setmaxlinelen(a0));
      }
      break;
    case 56:
      HASH_GUARD(0x3C6D50F3BB8102B8LL, next) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      HASH_GUARD(0x0890F9052322E838LL, fstat) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fstat", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fstat());
      }
      break;
    case 63:
      HASH_GUARD(0x04C642C6C162243FLL, getpath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getpath());
      }
      HASH_GUARD(0x7D50FA42F9D4923FLL, getfileinfo) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getfileinfo());
        else return (t_getfileinfo(a0));
      }
      break;
    case 67:
      HASH_GUARD(0x5ACCF9166CD9D043LL, ftruncate) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::ftruncate", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_ftruncate(a0));
      }
      HASH_GUARD(0x794FAFD4412AEFC3LL, eof) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::eof", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_eof());
      }
      break;
    case 68:
      HASH_GUARD(0x6413CB5154808C44LL, valid) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 69:
      HASH_GUARD(0x5676046725D241C5LL, setinfoclass) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setinfoclass());
        else return (t_setinfoclass(a0));
      }
      break;
    case 73:
      HASH_GUARD(0x4282E0231F600049LL, fseek) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("SplFileObject::fseek", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fseek(a0, a1));
      }
      break;
    case 74:
      HASH_GUARD(0x01A800A73CD2604ALL, getinode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinode());
      }
      break;
    case 77:
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 78:
      HASH_GUARD(0x7E978C38D741664ELL, fgetcsv) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("SplFileObject::fgetcsv", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fgetcsv());
        else if (count == 1) return (t_fgetcsv(a0));
        else if (count == 2) return (t_fgetcsv(a0, a1));
        else return (t_fgetcsv(a0, a1, a2));
      }
      break;
    case 79:
      HASH_GUARD(0x569FC7D8E9401C4FLL, isreadable) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isreadable());
      }
      break;
    case 80:
      HASH_GUARD(0x3A335010F905ACD0LL, setcsvcontrol) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("SplFileObject::setCsvControl", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setcsvcontrol());
        else if (count == 1) return (t_setcsvcontrol(a0));
        else if (count == 2) return (t_setcsvcontrol(a0, a1));
        else return (t_setcsvcontrol(a0, a1, a2));
      }
      break;
    case 81:
      HASH_GUARD(0x56EDB60C824E8C51LL, key) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 88:
      HASH_GUARD(0x1D5801BB72C51C58LL, islink) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_islink());
      }
      break;
    case 90:
      HASH_GUARD(0x25F68E7910FE9CDALL, getmaxlinelen) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getMaxLineLen", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmaxlinelen());
      }
      break;
    case 92:
      HASH_GUARD(0x5B3A4A72846B21DCLL, current) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 97:
      HASH_GUARD(0x27E7DBA875AD17E1LL, getflags) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getFlags", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getflags());
      }
      break;
    case 98:
      HASH_GUARD(0x6FE9F691E4A6D962LL, getcsvcontrol) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getCsvControl", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcsvcontrol());
      }
      break;
    case 99:
      HASH_GUARD(0x638F2A56B8463A63LL, iswritable) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswritable());
      }
      break;
    case 101:
      HASH_GUARD(0x05D72365192CE465LL, fwrite) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("SplFileObject::fwrite", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fwrite(a0, a1));
      }
      break;
    case 103:
      HASH_GUARD(0x00DCC39EDB16AFE7LL, getpathinfo) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getpathinfo());
        else return (t_getpathinfo(a0));
      }
      HASH_GUARD(0x7EF5445C77054C67LL, seek) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::seek", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_seek(a0));
      }
      break;
    case 106:
      HASH_GUARD(0x0F9EDEC32565D86ALL, getgroup) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getgroup());
      }
      HASH_GUARD(0x6615B5496D03A6EALL, getsize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getsize());
      }
      HASH_GUARD(0x1670096FDE27AF6ALL, rewind) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    case 115:
      HASH_GUARD(0x7AE1BE187F18FDF3LL, fgets) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgets", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fgets());
      }
      break;
    case 116:
      HASH_GUARD(0x265BDC54C992EE74LL, getmtime) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmtime());
      }
      break;
    case 120:
      HASH_GUARD(0x25070641C3D924F8LL, getpathname) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getpathname());
      }
      break;
    case 122:
      HASH_GUARD(0x3786834B2A0CCB7ALL, isexecutable) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isexecutable());
      }
      break;
    case 125:
      HASH_GUARD(0x4351578037A06E7DLL, getperms) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getperms());
      }
      break;
    default:
      break;
  }
#endif
  return c_splfileinfo::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_splfileobject::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_splfileinfo::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_splfileobject = {
  c_splfileobject::os_getInit,
  c_splfileobject::os_get,
  c_splfileobject::os_lval,
  c_splfileobject::os_invoke,
  c_splfileobject::os_constant,
};
void c_splfileobject::init() {
  c_splfileinfo::init();
}
/* SRC: classes/splfile.php line 128 */
void c_splfileobject::t___construct(Variant v_filename, Variant v_open_mode //  = "r"
, Variant v_use_include_path //  = false
, Variant v_context //  = null
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::__construct);
  bool oldInCtor = gasInCtor(true);
  Variant v_file_name;

  x_hphp_splfileobject___construct(GET_THIS(), toString(v_file_name), toString(v_open_mode), toBoolean(v_use_include_path), v_context);
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/splfile.php line 135 */
Variant c_splfileobject::t_current() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::current);
  return x_hphp_splfileobject_current(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 139 */
bool c_splfileobject::t_eof() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::eof);
  return x_hphp_splfileobject_eof(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 143 */
bool c_splfileobject::t_fflush() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fflush);
  return x_hphp_splfileobject_fflush(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 147 */
String c_splfileobject::t_fgetc() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fgetc);
  return x_hphp_splfileobject_fgetc(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 151 */
Variant c_splfileobject::t_fgetcsv(CVarRef v_delimiter //  = ","
, CVarRef v_enclosure //  = "\""
, CVarRef v_escape //  = "\\"
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fgetcsv);
  return x_hphp_splfileobject_fgetcsv(GET_THIS(), toString(v_delimiter), toString(v_enclosure), toString(v_escape));
} /* function */
/* SRC: classes/splfile.php line 157 */
String c_splfileobject::t_fgets() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fgets);
  return x_hphp_splfileobject_fgets(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 161 */
String c_splfileobject::t_fgetss(CVarRef v_allowable_tags) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fgetss);
  return x_hphp_splfileobject_fgetss(GET_THIS(), toString(v_allowable_tags));
} /* function */
/* SRC: classes/splfile.php line 165 */
bool c_splfileobject::t_flock(CVarRef v_operation, Variant v_wouldblock) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::flock);
  return x_hphp_splfileobject_flock(GET_THIS(), ref(v_wouldblock));
} /* function */
/* SRC: classes/splfile.php line 169 */
int64 c_splfileobject::t_fpassthru() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fpassthru);
  return x_hphp_splfileobject_fpassthru(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 173 */
Variant c_splfileobject::t_fscanf(CVarRef v_format) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fscanf);
  return invoke("hphp_splfileobject_fscanf", Array(ArrayInit(1, true).setRef(0, toInt64(GET_THIS())).create()), 0x6DB71D850799D76ELL);
} /* function */
/* SRC: classes/splfile.php line 177 */
int64 c_splfileobject::t_fseek(CVarRef v_offset, CVarRef v_whence) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fseek);
  return x_hphp_splfileobject_fseek(GET_THIS(), toInt64(v_offset), toInt64(v_whence));
} /* function */
/* SRC: classes/splfile.php line 181 */
Variant c_splfileobject::t_fstat() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fstat);
  return x_hphp_splfileobject_fstat(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 185 */
int64 c_splfileobject::t_ftell() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::ftell);
  return x_hphp_splfileobject_ftell(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 189 */
bool c_splfileobject::t_ftruncate(CVarRef v_size) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::ftruncate);
  return x_hphp_splfileobject_ftruncate(GET_THIS(), toInt64(v_size));
} /* function */
/* SRC: classes/splfile.php line 193 */
int64 c_splfileobject::t_fwrite(CVarRef v_str, CVarRef v_length) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fwrite);
  return x_hphp_splfileobject_fwrite(GET_THIS(), toString(v_str), toInt64(v_length));
} /* function */
/* SRC: classes/splfile.php line 197 */
Variant c_splfileobject::t_getchildren() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::getChildren);
  return null;
} /* function */
/* SRC: classes/splfile.php line 201 */
Variant c_splfileobject::t_getcsvcontrol() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::getCsvControl);
  return x_hphp_splfileobject_getcvscontrol(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 205 */
int64 c_splfileobject::t_getflags() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::getFlags);
  return x_hphp_splfileobject_getflags(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 209 */
int64 c_splfileobject::t_getmaxlinelen() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::getMaxLineLen);
  return x_hphp_splfileobject_getmaxlinelen(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 213 */
bool c_splfileobject::t_haschildren() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::hasChildren);
  return false;
} /* function */
/* SRC: classes/splfile.php line 217 */
int64 c_splfileobject::t_key() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::key);
  return x_hphp_splfileobject_key(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 221 */
Variant c_splfileobject::t_next() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::next);
  return (x_hphp_splfileobject_next(GET_THIS()), null);
} /* function */
/* SRC: classes/splfile.php line 225 */
Variant c_splfileobject::t_rewind() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::rewind);
  return (x_hphp_splfileobject_rewind(GET_THIS()), null);
} /* function */
/* SRC: classes/splfile.php line 229 */
Variant c_splfileobject::t_seek(CVarRef v_line_pos) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::seek);
  return (x_hphp_splfileobject_seek(GET_THIS(), toInt64(v_line_pos)), null);
} /* function */
/* SRC: classes/splfile.php line 233 */
Variant c_splfileobject::t_setcsvcontrol(CVarRef v_delimiter //  = ","
, CVarRef v_enclosure //  = "\""
, CVarRef v_escape //  = "\\"
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::setCsvControl);
  return (x_hphp_splfileobject_setcsvcontrol(GET_THIS(), toString(v_delimiter), toString(v_enclosure), toString(v_escape)), null);
} /* function */
/* SRC: classes/splfile.php line 239 */
Variant c_splfileobject::t_setflags(CVarRef v_flags) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::setFlags);
  return (x_hphp_splfileobject_setflags(GET_THIS(), toInt64(v_flags)), null);
} /* function */
/* SRC: classes/splfile.php line 243 */
Variant c_splfileobject::t_setmaxlinelen(CVarRef v_max_len) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::setMaxLineLen);
  return (x_hphp_splfileobject_setmaxlinelen(GET_THIS(), toInt64(v_max_len)), null);
} /* function */
/* SRC: classes/splfile.php line 247 */
bool c_splfileobject::t_valid() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::valid);
  return x_hphp_splfileobject_valid(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 3 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_splfileinfo
Variant c_splfileinfo::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_splfileinfo
Variant c_splfileinfo::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_splfileinfo
Variant &c_splfileinfo::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_splfileinfo
void c_splfileinfo::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_splfileinfo
void c_splfileinfo::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_get_splfileinfo
Variant c_splfileinfo::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_splfileinfo
Variant c_splfileinfo::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_splfileinfo
Variant c_splfileinfo::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_exists_splfileinfo
bool c_splfileinfo::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_splfileinfo
bool c_splfileinfo::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_splfileinfo
bool c_splfileinfo::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_set_splfileinfo
Variant c_splfileinfo::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_splfileinfo
Variant c_splfileinfo::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_splfileinfo
Variant c_splfileinfo::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_lval_splfileinfo
Variant& c_splfileinfo::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_splfileinfo
Variant& c_splfileinfo::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_splfileinfo
Variant& c_splfileinfo::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_splfileinfo
Variant c_splfileinfo::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_splfileinfo
IMPLEMENT_CLASS(splfileinfo)
c_splfileinfo *c_splfileinfo::create(Variant v_file_name) {
  CountableHelper h(this);
  init();
  t___construct(v_file_name);
  return this;
}
ObjectData *c_splfileinfo::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_splfileinfo::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_splfileinfo::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
ObjectData *c_splfileinfo::cloneImpl() {
  c_splfileinfo *obj = NEW(c_splfileinfo)();
  cloneSet(obj);
  return obj;
}
void c_splfileinfo::cloneSet(c_splfileinfo *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_splfileinfo
Variant c_splfileinfo::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xad:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        return (t_getperms());
      }
      break;
    case 0xae:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        return (t_iswritable());
      }
      break;
    case 0xaf:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getbasename());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getbasename(arg0));
        }
      }
      break;
    case 0xb0:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        return (t_getpathname());
      }
      break;
    case 0xb1:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        return (t_getgroup());
      }
      break;
    case 0xb2:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setfileclass());
          CVarRef arg0((ad->getValue(pos)));
          return (t_setfileclass(arg0));
        }
      }
      break;
    case 0xb3:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setinfoclass());
          CVarRef arg0((ad->getValue(pos)));
          return (t_setinfoclass(arg0));
        }
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0xb4:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        return (t_getlinktarget());
      }
      break;
    case 0xb5:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        return (t_isreadable());
      }
      break;
    case 0xb6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        return (t_getrealpath());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 1) return throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0xb7:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getpathinfo());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getpathinfo(arg0));
        }
      }
      break;
    case 0xb8:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        return (t_getctime());
      }
      break;
    case 0xb9:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        return (t_getpath());
      }
      break;
    case 0xba:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        return (t_getinode());
      }
      break;
    case 0xbb:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        return (t_islink());
      }
      break;
    case 0xbc:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        return (t_getsize());
      }
      break;
    case 0xbe:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        return (t_isfile());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 0xbf:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        return (t_getowner());
      }
      break;
    case 0xc0:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        return (t_getmtime());
      }
      break;
    case 0xc1:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        return (t_isdir());
      }
      break;
    case 0xc2:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getfileinfo());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getfileinfo(arg0));
        }
      }
      break;
    case 0xc4:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        return (t_isexecutable());
      }
      break;
    case 0xc3:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        return (t_getatime());
      }
      break;
    case 0xc5:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_openfile());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_openfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_openfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_openfile(arg0, arg1, arg2));
        }
      }
      break;
    case 0xc7:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        return (t_gettype());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 5:
      HASH_GUARD(0x5676046725D241C5LL, setinfoclass) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setinfoclass());
          CVarRef arg0((ad->getValue(pos)));
          return (t_setinfoclass(arg0));
        }
      }
      break;
    case 6:
      HASH_GUARD(0x6B2EAD4A44934786LL, getrealpath) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        return (t_getrealpath());
      }
      HASH_GUARD(0x1D3B08AA0AF50F06LL, gettype) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        return (t_gettype());
      }
      break;
    case 8:
      HASH_GUARD(0x1ADA46FCC8EFEC08LL, isdir) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        return (t_isdir());
      }
      break;
    case 10:
      HASH_GUARD(0x01A800A73CD2604ALL, getinode) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        return (t_getinode());
      }
      break;
    case 13:
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 14:
      HASH_GUARD(0x32ABF385AD4BE48ELL, getowner) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        return (t_getowner());
      }
      break;
    case 15:
      HASH_GUARD(0x569FC7D8E9401C4FLL, isreadable) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        return (t_isreadable());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 24:
      HASH_GUARD(0x1D5801BB72C51C58LL, islink) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        return (t_islink());
      }
      break;
    case 28:
      HASH_GUARD(0x572E108C6731E29CLL, getbasename) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getbasename());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getbasename(arg0));
        }
      }
      break;
    case 29:
      HASH_GUARD(0x4C43532D60465F1DLL, isfile) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        return (t_isfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      HASH_GUARD(0x4BC19906B553C59FLL, getatime) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        return (t_getatime());
      }
      break;
    case 35:
      HASH_GUARD(0x638F2A56B8463A63LL, iswritable) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        return (t_iswritable());
      }
      break;
    case 37:
      HASH_GUARD(0x5948407CA9CC4DA5LL, setfileclass) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setfileclass());
          CVarRef arg0((ad->getValue(pos)));
          return (t_setfileclass(arg0));
        }
      }
      break;
    case 39:
      HASH_GUARD(0x00DCC39EDB16AFE7LL, getpathinfo) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getpathinfo());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getpathinfo(arg0));
        }
      }
      break;
    case 42:
      HASH_GUARD(0x0F9EDEC32565D86ALL, getgroup) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        return (t_getgroup());
      }
      HASH_GUARD(0x6615B5496D03A6EALL, getsize) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        return (t_getsize());
      }
      break;
    case 43:
      HASH_GUARD(0x0D6276BAB75513ABLL, getlinktarget) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        return (t_getlinktarget());
      }
      break;
    case 47:
      HASH_GUARD(0x5640A4755D0078AFLL, getctime) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        return (t_getctime());
      }
      break;
    case 52:
      HASH_GUARD(0x265BDC54C992EE74LL, getmtime) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        return (t_getmtime());
      }
      break;
    case 53:
      HASH_GUARD(0x337DEC2D48BDFE35LL, openfile) {
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_openfile());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_openfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_openfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_openfile(arg0, arg1, arg2));
        }
      }
      break;
    case 56:
      HASH_GUARD(0x25070641C3D924F8LL, getpathname) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        return (t_getpathname());
      }
      break;
    case 58:
      HASH_GUARD(0x3786834B2A0CCB7ALL, isexecutable) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        return (t_isexecutable());
      }
      break;
    case 61:
      HASH_GUARD(0x4351578037A06E7DLL, getperms) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        return (t_getperms());
      }
      break;
    case 63:
      HASH_GUARD(0x04C642C6C162243FLL, getpath) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        return (t_getpath());
      }
      HASH_GUARD(0x7D50FA42F9D4923FLL, getfileinfo) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getfileinfo());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getfileinfo(arg0));
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_splfileinfo
Variant c_splfileinfo::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xad:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        return (t_getperms());
      }
      break;
    case 0xae:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        return (t_iswritable());
      }
      break;
    case 0xaf:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        if (count <= 0) return (t_getbasename());
        return (t_getbasename(a0));
      }
      break;
    case 0xb0:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        return (t_getpathname());
      }
      break;
    case 0xb1:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        return (t_getgroup());
      }
      break;
    case 0xb2:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        if (count <= 0) return (t_setfileclass());
        return (t_setfileclass(a0));
      }
      break;
    case 0xb3:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        if (count <= 0) return (t_setinfoclass());
        return (t_setinfoclass(a0));
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0xb4:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        return (t_getlinktarget());
      }
      break;
    case 0xb5:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        return (t_isreadable());
      }
      break;
    case 0xb6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        return (t_getrealpath());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count != 1) return throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
        return (t___construct(a0), null);
      }
      break;
    case 0xb7:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        if (count <= 0) return (t_getpathinfo());
        return (t_getpathinfo(a0));
      }
      break;
    case 0xb8:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        return (t_getctime());
      }
      break;
    case 0xb9:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        return (t_getpath());
      }
      break;
    case 0xba:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        return (t_getinode());
      }
      break;
    case 0xbb:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        return (t_islink());
      }
      break;
    case 0xbc:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        return (t_getsize());
      }
      break;
    case 0xbe:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        return (t_isfile());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 0xbf:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        return (t_getowner());
      }
      break;
    case 0xc0:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        return (t_getmtime());
      }
      break;
    case 0xc1:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        return (t_isdir());
      }
      break;
    case 0xc2:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        if (count <= 0) return (t_getfileinfo());
        return (t_getfileinfo(a0));
      }
      break;
    case 0xc4:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        return (t_isexecutable());
      }
      break;
    case 0xc3:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        return (t_getatime());
      }
      break;
    case 0xc5:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        if (count <= 0) return (t_openfile());
        if (count == 1) return (t_openfile(a0));
        if (count == 2) return (t_openfile(a0, a1));
        return (t_openfile(a0, a1, a2));
      }
      break;
    case 0xc7:
      if (methodIndex.m_overloadIndex == 0x1) { 
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        return (t_gettype());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 5:
      HASH_GUARD(0x5676046725D241C5LL, setinfoclass) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        if (count <= 0) return (t_setinfoclass());
        return (t_setinfoclass(a0));
      }
      break;
    case 6:
      HASH_GUARD(0x6B2EAD4A44934786LL, getrealpath) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        return (t_getrealpath());
      }
      HASH_GUARD(0x1D3B08AA0AF50F06LL, gettype) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        return (t_gettype());
      }
      break;
    case 8:
      HASH_GUARD(0x1ADA46FCC8EFEC08LL, isdir) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        return (t_isdir());
      }
      break;
    case 10:
      HASH_GUARD(0x01A800A73CD2604ALL, getinode) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        return (t_getinode());
      }
      break;
    case 13:
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 14:
      HASH_GUARD(0x32ABF385AD4BE48ELL, getowner) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        return (t_getowner());
      }
      break;
    case 15:
      HASH_GUARD(0x569FC7D8E9401C4FLL, isreadable) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        return (t_isreadable());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 24:
      HASH_GUARD(0x1D5801BB72C51C58LL, islink) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        return (t_islink());
      }
      break;
    case 28:
      HASH_GUARD(0x572E108C6731E29CLL, getbasename) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        if (count <= 0) return (t_getbasename());
        return (t_getbasename(a0));
      }
      break;
    case 29:
      HASH_GUARD(0x4C43532D60465F1DLL, isfile) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        return (t_isfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
        return (t___construct(a0), null);
      }
      HASH_GUARD(0x4BC19906B553C59FLL, getatime) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        return (t_getatime());
      }
      break;
    case 35:
      HASH_GUARD(0x638F2A56B8463A63LL, iswritable) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        return (t_iswritable());
      }
      break;
    case 37:
      HASH_GUARD(0x5948407CA9CC4DA5LL, setfileclass) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        if (count <= 0) return (t_setfileclass());
        return (t_setfileclass(a0));
      }
      break;
    case 39:
      HASH_GUARD(0x00DCC39EDB16AFE7LL, getpathinfo) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        if (count <= 0) return (t_getpathinfo());
        return (t_getpathinfo(a0));
      }
      break;
    case 42:
      HASH_GUARD(0x0F9EDEC32565D86ALL, getgroup) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        return (t_getgroup());
      }
      HASH_GUARD(0x6615B5496D03A6EALL, getsize) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        return (t_getsize());
      }
      break;
    case 43:
      HASH_GUARD(0x0D6276BAB75513ABLL, getlinktarget) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        return (t_getlinktarget());
      }
      break;
    case 47:
      HASH_GUARD(0x5640A4755D0078AFLL, getctime) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        return (t_getctime());
      }
      break;
    case 52:
      HASH_GUARD(0x265BDC54C992EE74LL, getmtime) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        return (t_getmtime());
      }
      break;
    case 53:
      HASH_GUARD(0x337DEC2D48BDFE35LL, openfile) {
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        if (count <= 0) return (t_openfile());
        if (count == 1) return (t_openfile(a0));
        if (count == 2) return (t_openfile(a0, a1));
        return (t_openfile(a0, a1, a2));
      }
      break;
    case 56:
      HASH_GUARD(0x25070641C3D924F8LL, getpathname) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        return (t_getpathname());
      }
      break;
    case 58:
      HASH_GUARD(0x3786834B2A0CCB7ALL, isexecutable) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        return (t_isexecutable());
      }
      break;
    case 61:
      HASH_GUARD(0x4351578037A06E7DLL, getperms) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        return (t_getperms());
      }
      break;
    case 63:
      HASH_GUARD(0x04C642C6C162243FLL, getpath) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        return (t_getpath());
      }
      HASH_GUARD(0x7D50FA42F9D4923FLL, getfileinfo) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        if (count <= 0) return (t_getfileinfo());
        return (t_getfileinfo(a0));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_splfileinfo
Variant c_splfileinfo::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_splfileinfo
Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0xad:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getperms());
      }
      break;
    case 0xae:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswritable());
      }
      break;
    case 0xaf:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getbasename());
        else return (t_getbasename(a0));
      }
      break;
    case 0xb0:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getpathname());
      }
      break;
    case 0xb1:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getgroup());
      }
      break;
    case 0xb2:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setfileclass());
        else return (t_setfileclass(a0));
      }
      break;
    case 0xb3:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setinfoclass());
        else return (t_setinfoclass(a0));
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0xb4:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlinktarget());
      }
      break;
    case 0xb5:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isreadable());
      }
      break;
    case 0xb6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getrealpath());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 0xb7:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getpathinfo());
        else return (t_getpathinfo(a0));
      }
      break;
    case 0xb8:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getctime());
      }
      break;
    case 0xb9:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getpath());
      }
      break;
    case 0xba:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinode());
      }
      break;
    case 0xbb:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_islink());
      }
      break;
    case 0xbc:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getsize());
      }
      break;
    case 0xbe:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isfile());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 0xbf:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getowner());
      }
      break;
    case 0xc0:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmtime());
      }
      break;
    case 0xc1:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdir());
      }
      break;
    case 0xc2:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getfileinfo());
        else return (t_getfileinfo(a0));
      }
      break;
    case 0xc4:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isexecutable());
      }
      break;
    case 0xc3:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getatime());
      }
      break;
    case 0xc5:
      if (methodIndex.m_overloadIndex == 0x1) { 
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_openfile());
        else if (count == 1) return (t_openfile(a0));
        else if (count == 2) return (t_openfile(a0, a1));
        else return (t_openfile(a0, a1, a2));
      }
      break;
    case 0xc7:
      if (methodIndex.m_overloadIndex == 0x1) { 
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettype());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 5:
      HASH_GUARD(0x5676046725D241C5LL, setinfoclass) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setinfoclass());
        else return (t_setinfoclass(a0));
      }
      break;
    case 6:
      HASH_GUARD(0x6B2EAD4A44934786LL, getrealpath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getrealpath());
      }
      HASH_GUARD(0x1D3B08AA0AF50F06LL, gettype) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettype());
      }
      break;
    case 8:
      HASH_GUARD(0x1ADA46FCC8EFEC08LL, isdir) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdir());
      }
      break;
    case 10:
      HASH_GUARD(0x01A800A73CD2604ALL, getinode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinode());
      }
      break;
    case 13:
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 14:
      HASH_GUARD(0x32ABF385AD4BE48ELL, getowner) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getowner());
      }
      break;
    case 15:
      HASH_GUARD(0x569FC7D8E9401C4FLL, isreadable) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isreadable());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 24:
      HASH_GUARD(0x1D5801BB72C51C58LL, islink) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_islink());
      }
      break;
    case 28:
      HASH_GUARD(0x572E108C6731E29CLL, getbasename) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getbasename());
        else return (t_getbasename(a0));
      }
      break;
    case 29:
      HASH_GUARD(0x4C43532D60465F1DLL, isfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isfile());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      HASH_GUARD(0x4BC19906B553C59FLL, getatime) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getatime());
      }
      break;
    case 35:
      HASH_GUARD(0x638F2A56B8463A63LL, iswritable) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswritable());
      }
      break;
    case 37:
      HASH_GUARD(0x5948407CA9CC4DA5LL, setfileclass) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setfileclass());
        else return (t_setfileclass(a0));
      }
      break;
    case 39:
      HASH_GUARD(0x00DCC39EDB16AFE7LL, getpathinfo) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getpathinfo());
        else return (t_getpathinfo(a0));
      }
      break;
    case 42:
      HASH_GUARD(0x0F9EDEC32565D86ALL, getgroup) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getgroup());
      }
      HASH_GUARD(0x6615B5496D03A6EALL, getsize) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getsize());
      }
      break;
    case 43:
      HASH_GUARD(0x0D6276BAB75513ABLL, getlinktarget) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlinktarget());
      }
      break;
    case 47:
      HASH_GUARD(0x5640A4755D0078AFLL, getctime) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getctime());
      }
      break;
    case 52:
      HASH_GUARD(0x265BDC54C992EE74LL, getmtime) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmtime());
      }
      break;
    case 53:
      HASH_GUARD(0x337DEC2D48BDFE35LL, openfile) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_openfile());
        else if (count == 1) return (t_openfile(a0));
        else if (count == 2) return (t_openfile(a0, a1));
        else return (t_openfile(a0, a1, a2));
      }
      break;
    case 56:
      HASH_GUARD(0x25070641C3D924F8LL, getpathname) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getpathname());
      }
      break;
    case 58:
      HASH_GUARD(0x3786834B2A0CCB7ALL, isexecutable) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isexecutable());
      }
      break;
    case 61:
      HASH_GUARD(0x4351578037A06E7DLL, getperms) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getperms());
      }
      break;
    case 63:
      HASH_GUARD(0x04C642C6C162243FLL, getpath) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getpath());
      }
      HASH_GUARD(0x7D50FA42F9D4923FLL, getfileinfo) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getfileinfo());
        else return (t_getfileinfo(a0));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_splfileinfo::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_splfileinfo = {
  c_splfileinfo::os_getInit,
  c_splfileinfo::os_get,
  c_splfileinfo::os_lval,
  c_splfileinfo::os_invoke,
  c_splfileinfo::os_constant,
};
void c_splfileinfo::init() {
}
/* SRC: classes/splfile.php line 5 */
void c_splfileinfo::t___construct(Variant v_file_name) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::__construct);
  bool oldInCtor = gasInCtor(true);
  x_hphp_splfileinfo___construct(GET_THIS(), toString(v_file_name));
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/splfile.php line 9 */
String c_splfileinfo::t_getpath() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getPath);
  return x_hphp_splfileinfo_getpath(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 13 */
String c_splfileinfo::t_getfilename() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getFilename);
  return x_hphp_splfileinfo_getfilename(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 17 */
Object c_splfileinfo::t_getfileinfo(CVarRef v_class_name //  = ""
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getFileInfo);
  return x_hphp_splfileinfo_getfileinfo(GET_THIS(), toString(v_class_name));
} /* function */
/* SRC: classes/splfile.php line 21 */
String c_splfileinfo::t_getbasename(CVarRef v_suffix //  = ""
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getBasename);
  return x_hphp_splfileinfo_getbasename(GET_THIS(), toString(v_suffix));
} /* function */
/* SRC: classes/splfile.php line 25 */
String c_splfileinfo::t_getpathname() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getPathname);
  return x_hphp_splfileinfo_getpathname(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 29 */
Object c_splfileinfo::t_getpathinfo(CVarRef v_class_name //  = ""
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getPathInfo);
  return x_hphp_splfileinfo_getpathinfo(GET_THIS(), toString(v_class_name));
} /* function */
/* SRC: classes/splfile.php line 33 */
int64 c_splfileinfo::t_getperms() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getPerms);
  return x_hphp_splfileinfo_getperms(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 37 */
int64 c_splfileinfo::t_getinode() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getInode);
  return x_hphp_splfileinfo_getinode(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 41 */
int64 c_splfileinfo::t_getsize() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getSize);
  return x_hphp_splfileinfo_getsize(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 45 */
int64 c_splfileinfo::t_getowner() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getOwner);
  return x_hphp_splfileinfo_getowner(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 49 */
int64 c_splfileinfo::t_getgroup() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getGroup);
  return x_hphp_splfileinfo_getgroup(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 53 */
int64 c_splfileinfo::t_getatime() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getATime);
  return x_hphp_splfileinfo_getatime(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 57 */
int64 c_splfileinfo::t_getmtime() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getMTime);
  return x_hphp_splfileinfo_getmtime(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 61 */
int64 c_splfileinfo::t_getctime() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getCTime);
  return x_hphp_splfileinfo_getctime(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 65 */
String c_splfileinfo::t_gettype() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getType);
  return x_hphp_splfileinfo_gettype(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 69 */
bool c_splfileinfo::t_iswritable() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::isWritable);
  return x_hphp_splfileinfo_iswritable(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 73 */
bool c_splfileinfo::t_isreadable() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::isReadable);
  return x_hphp_splfileinfo_isreadable(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 77 */
bool c_splfileinfo::t_isexecutable() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::isExecutable);
  return x_hphp_splfileinfo_isexecutable(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 81 */
bool c_splfileinfo::t_isfile() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::isFile);
  return x_hphp_splfileinfo_isfile(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 85 */
bool c_splfileinfo::t_isdir() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::isDir);
  return x_hphp_splfileinfo_isdir(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 89 */
bool c_splfileinfo::t_islink() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::isLink);
  return x_hphp_splfileinfo_islink(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 93 */
String c_splfileinfo::t_getlinktarget() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getLinkTarget);
  return x_hphp_splfileinfo_getlinktarget(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 97 */
Variant c_splfileinfo::t_getrealpath() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getRealPath);
  return x_hphp_splfileinfo_getrealpath(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 101 */
String c_splfileinfo::t___tostring() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::__toString);
  return x_hphp_splfileinfo___tostring(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 105 */
Object c_splfileinfo::t_openfile(CVarRef v_mode //  = "r"
, CVarRef v_use_include_path //  = false
, CVarRef v_context //  = null_variant
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::openFile);
  return x_hphp_splfileinfo_openfile(GET_THIS(), toString(v_mode), toBoolean(v_use_include_path), v_context);
} /* function */
/* SRC: classes/splfile.php line 111 */
Variant c_splfileinfo::t_setfileclass(CVarRef v_class_name //  = "SplFileObject"
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::setFileClass);
  return (x_hphp_splfileinfo_setfileclass(GET_THIS(), toString(v_class_name)), null);
} /* function */
/* SRC: classes/splfile.php line 115 */
Variant c_splfileinfo::t_setinfoclass(CVarRef v_class_name //  = "SplFileInfo"
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::setInfoClass);
  return (x_hphp_splfileinfo_setinfoclass(GET_THIS(), toString(v_class_name)), null);
} /* function */
Object co_splfileobject(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_splfileobject)())->dynCreate(params, init));
}
Object co_splfileinfo(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_splfileinfo)())->dynCreate(params, init));
}
Variant pm_php$classes$splfile_php(bool incOnce /* = false */, LVariableTable* variables /* = NULL */) {
  {
    DECLARE_SYSTEM_GLOBALS(g);
    bool &alreadyRun = g->run_pm_php$classes$splfile_php;
    if (alreadyRun) { if (incOnce) return true;}
    else alreadyRun = true;
    if (!variables) variables = g;
  }
  PSEUDOMAIN_INJECTION(run_init::classes/splfile.php);
  DECLARE_SYSTEM_GLOBALS(g);
  LVariableTable *gVariables __attribute__((__unused__)) = get_variable_table();
  return true;
} /* function */

///////////////////////////////////////////////////////////////////////////////
}
